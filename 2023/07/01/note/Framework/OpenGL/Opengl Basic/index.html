<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="It is this intellectual activity of inquiry, seeking, rather than summative answers, that make one a philosopher, because summative answers can easily be reduced to unthinking dogmas and slogans that require no thought or understanding at all.">
    <meta name="author" content="Dionysen">
    
        <title>
            
                OpenGL-2 基础 |
                    
                        DIONYSEN BLOG
        </title>

        <link
            href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600&family=Noto+Serif+SC:wght@400;600;700&display=swap"
            rel="stylesheet">

        
<link rel="stylesheet" href="/css/style.css">

            <link rel="shortcut icon" href="/images/logo.svg">
                <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
                    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
                        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
                            <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
                                <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"dionysen.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066cc","right_side_width":"500px","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.png","font_size":"16px","font_family":"Open Sans, Noto Serif SC, serif","code_font_family":"Fira Code, Noto Serif SC, serif, monospace","code_font_size":"0.96rem","static-shadow":true,"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.jpg","background_img_dark":"/images/bg_dark.jpg","description":"或许，正如蒙田所说，所有知识最多只是可能、合理和有效。或许，根本就没有这样的“基础”以及由此建立起来的知识大厦，只有多重交织的网络。人们可能会像蒙田和怀疑论者那样主张，我们的知识永远不会是确定的（除非在极其微不足道的事情上或特殊的环境下）。","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{"enable":false},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"gitalk","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":"Dionysen","github_admins":null,"repository":"BlogCDN","client_id":"5297a6c30ff4654f692f","client_secret":"ef4506ab93254f2d4e7b41c04958e94bd131a3b6","proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":false,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"left","copyright_info":true},"mermaid":{"enable":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.0.0"></head>
<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               DIONYSEN BLOG
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="https://dionysen.github.io/en/"
                            >
                                ENGLISH
                            </a>
                        </li>
                    
                    
                        <li class="menu-item flex-center toggle-show-toc">
                            <i class="fas fa-list"></i>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                       
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="https://dionysen.github.io/en/">ENGLISH</a>
                </li>
            
            <!-- <li class="menu-item tool-dark-light-toggle flex-center">
                <i class="fas fa-moon"></i>
            </li> -->
        </ul>
    </div>
    <li class="menu-item tool-dark-light-toggle flex-center">
        <i class="fas fa-moon"></i>
    </li>
    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">OpenGL-2 基础</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Dionysen</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-07-01 14:25</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <!-- <i class="fas fa-folder"></i>&nbsp; -->
            <ul>
                
                    <li>
                        <i class="fas fa-chevron-circle-right"></i>&nbsp<a href="/categories/%E9%80%92%E5%BD%92%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C-%C2%B7-%E7%BC%96%E7%A8%8B/">递归这个世界 · 编程</a>&nbsp;
                    </li>
                
                    <li>
                        <i class="fas fa-chevron-circle-right"></i>&nbsp<a href="/categories/%E9%80%92%E5%BD%92%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C-%C2%B7-%E7%BC%96%E7%A8%8B/%E6%A1%86%E6%9E%B6/">框架</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
        <span class="article-tags article-meta-item">
            <br/>
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/CPP/"><i class="fas fa-hashtag"></i>&nbsp;CPP</a>
                    </li>
                
                    <li>
                        <a href="/tags/OpenGL/"><i class="fas fa-hashtag"></i>&nbsp;OpenGL</a>
                    </li>
                
                    <li>
                        <a href="/tags/Graphic/"><i class="fas fa-hashtag"></i>&nbsp;Graphic</a>
                    </li>
                
                    <li>
                        <a href="/tags/Computer/"><i class="fas fa-hashtag"></i>&nbsp;Computer</a>
                    </li>
                
            </ul>
        </span>
    


    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;&nbsp;<span>6k 字</span>
        </span>
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                
                <blockquote>
<p><em>着色器</em>需要用特定的语言编写，GLSL是一种类C的语言，专门用来写着色器程序。</p>
</blockquote>
<p>程序结构： </p>
<ol>
<li>声明版本</li>
<li>输入和输出变量</li>
<li>uniform和main函数</li>
</ol>
<span id="more"></span>

<h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><p>一个典型的着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于顶点着色器，输入变量即顶点属性。</p>
<p>能声明的顶点属性是有上限的，一般由硬件来决定。</p>
<p>你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nrAttributes;</span><br><span class="line"><span class="built_in">glGetIntegerv</span>(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Maximum nr of vertex attributes supported: &quot;</span> &lt;&lt; nrAttributes &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常情况下它至少会返回16个，大部分情况下是够用了。</p>
</blockquote>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>GLSL中包含C等其它语言大部分的默认基础数据类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>uint</code>和<code>bool</code>。GLSL也有两种容器类型，分别是向量(Vector)和矩阵(Matrix)。</p>
<h5 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h5><p>GLSL中的向量是一个可以包含有2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（<code>n</code>代表分量的数量）：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>vecn</code></td>
<td align="left">包含<code>n</code>个float分量的默认向量（因为<code>float</code>是默认的数据类型）</td>
</tr>
<tr>
<td align="left"><code>bvecn</code></td>
<td align="left">包含<code>n</code>个bool分量的向量</td>
</tr>
<tr>
<td align="left"><code>ivecn</code></td>
<td align="left">包含<code>n</code>个int分量的向量</td>
</tr>
<tr>
<td align="left"><code>uvecn</code></td>
<td align="left">包含<code>n</code>个unsigned int分量的向量</td>
</tr>
<tr>
<td align="left"><code>dvecn</code></td>
<td align="left">包含<code>n</code>个double分量的向量</td>
</tr>
</tbody></table>
<p>多数情况使用<code>vecn</code>，这样已经够用了。</p>
<p>一个向量的分量可以通过<code>vec.x</code>这种方式获取，这里<code>x</code>是指这个向量的第一个分量。你可以分别使用<code>.x</code>、<code>.y</code>、<code>.z</code>和<code>.w</code>来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用<code>rgba</code>，或是对纹理坐标使用<code>stpq</code>访问相同的分量。</p>
<p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec2</span> someVec;</span><br><span class="line"><span class="type">vec4</span> differentVec = someVec.xyxx;</span><br><span class="line"><span class="type">vec3</span> anotherVec = differentVec.zyw;</span><br><span class="line"><span class="type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;</span><br></pre></td></tr></table></figure>

<h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><p>GLSL定义了<code>in</code>和<code>out</code>关键字专门来实现输入和输出。</p>
<p><code>layout (location = 0)</code>定义一个标识，这样才能链接到顶点数据。</p>
<blockquote>
<p>你也可以忽略<code>layout (location = 0)</code>标识符，通过在OpenGL代码中使用glGetAttribLocation查询属性位置值(Location)，但着色器中设置它们会更容易理解而且节省你（和OpenGL）的工作量。</p>
</blockquote>
<p>片段着色器，它需要一个<code>vec4</code>颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。</p>
<p>如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。</p>
<p>如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。</p>
<p><strong>顶点着色器</strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>片段着色器</strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶点着色器中声明了一个vertexColor变量作为<code>vec4</code>输出，并在片段着色器中声明了一个类似的vertexColor。由于它们名字相同且类型相同，片段着色器中的vertexColor就和顶点着色器中的vertexColor链接了。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。</p>
<p>结果如下：</p>
<img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.jsdelivr.net/gh/Dionysen/BlogCDN@main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-21%20171123.png"
                      style="zoom:80%;" 
                >

<h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。</p>
<p><strong>uniform是全局的(Global)。</strong></p>
<ul>
<li><p>uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。</p>
</li>
<li><p>无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个uniform的vec4，即<code>ourColor</code>，并且把片段着色器的输出颜色设置为uniform的值，之后无需再通过顶点着色器修改它，而可以直接在程序中修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> timeValue = <span class="built_in">glfwGetTime</span>(); <span class="comment">// 获取运行的秒数</span></span><br><span class="line"><span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;  <span class="comment">// 使用sin函数让颜色从0-1之间变化，结果储存在greenValue中</span></span><br><span class="line"><span class="type">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>); <span class="comment">// 通过函数glGetUniformLocation查询uniform ourColor的位置值，找不到返回-1</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glUniform4f</span>(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>); <span class="comment">// 设置uniform的值</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你<strong>必须</strong>先使用程序（调用<code>glUseProgram()</code>)，因为它是在当前激活的着色器程序中设置uniform的。</p>
<blockquote>
<p>❗如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</p>
</blockquote>
<p>修改后的全部源码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>; <span class="comment">//回调函数的声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>; <span class="comment">// 处理对窗口的输入</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;gl_Position = vec4(aPos, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建片段着色器程序的源码，使用c风格的常量字符串存储</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource =</span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;uniform vec4 ourColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main() &#123;\n&quot;</span></span><br><span class="line">        <span class="comment">//&quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot; // 此处设置片段颜色为黄色</span></span><br><span class="line">        <span class="string">&quot;FragColor = ourColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// -------------- 1. glfw的初始化 ----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------- 2. 使用glfw创建窗口 ---------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">// 此函数使指定窗口的 OpenGL 或 OpenGL ES 上下文成为调用线程的当前上下文</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(</span><br><span class="line">        window,</span><br><span class="line">        framebuffer_size_callback); <span class="comment">// 回调函数，保证每次窗口大小调整时，重新绘制</span></span><br><span class="line">    <span class="comment">// --------------- 3. glad：加载OpenGL所有的函数指针 ---------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------- 4. 创建和编译着色器 ---------------</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vertexShader; <span class="comment">// 创建顶点着色器索引</span></span><br><span class="line">    vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">// 创建顶点着色器</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(</span><br><span class="line">        vertexShader, <span class="number">1</span>, &amp;vertexShaderSource,</span><br><span class="line">        <span class="literal">NULL</span>); <span class="comment">// 为顶点着色器添加源码，第二个参数是添加的源码中字符串的数量，第三个先设置为NULL</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertexShader); <span class="comment">// 编译顶点着色器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> success;        <span class="comment">// 创建编译状态指示变量</span></span><br><span class="line">    <span class="type">char</span> info_log[<span class="number">512</span>]; <span class="comment">// 创建用以存储log的数组</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS,</span><br><span class="line">        &amp;success); <span class="comment">// 获取状态和log，输出到变量和数组中</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;          <span class="comment">// 如果编译失败，打印错误信息和log</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, info_log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span></span><br><span class="line">            &lt;&lt; info_log &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS,</span><br><span class="line">        &amp;success); <span class="comment">// 获取状态和log，输出到变量和数组中</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;          <span class="comment">// 如果编译失败，打印错误信息和log</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, info_log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span></span><br><span class="line">            &lt;&lt; info_log &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --------------- 5. 链接着色器 ---------------</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把着色器添加到着色器程序中</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(shaderProgram); <span class="comment">// 链接着色器程序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success); <span class="comment">// 异常检测</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, info_log);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINK_FAILED\n&quot;</span></span><br><span class="line">            &lt;&lt; info_log &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUseProgram</span>(</span><br><span class="line">        shaderProgram); <span class="comment">// 调用此函数后，渲染和着色器调用都会使用此前所写的着色器了</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragmentShader); <span class="comment">// 链接完成之后就可以删除着色器了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------- 6. 创建顶点数据缓冲区 ---------------</span></span><br><span class="line">    <span class="type">float</span> vertices[] =</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span> </span><br><span class="line">    &#125;; <span class="comment">// top</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);              <span class="comment">// 创建缓冲区</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO); <span class="comment">// 绑定缓冲区</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 告诉GPU如何读取顶点数据 ----------</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),</span><br><span class="line">        (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>); <span class="comment">// 启用顶点属性</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------- 7. 窗口绘制循环 ---------------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新uniform颜色</span></span><br><span class="line">        <span class="type">float</span> timeValue = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        <span class="type">float</span> greenValue = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">sin</span>(timeValue) / <span class="number">2.0</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="type">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line">        <span class="built_in">glUniform4f</span>(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this</span></span><br><span class="line"><span class="comment">// frame and react accordingly</span></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback</span></span><br><span class="line"><span class="comment">// function executes</span></span><br><span class="line"><span class="comment">// ----------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width</span></span><br><span class="line">    <span class="comment">// and height will be significantly larger than specified on retina</span></span><br><span class="line">    <span class="comment">// displays.</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为一个三角形，颜色在绿色和黑色之间周期性变换：</p>
<img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.jsdelivr.net/gh/Dionysen/BlogCDN/img/image-20230621210304885.png"
                      alt="image-20230621210304885" style="zoom:80%;" 
                >

<img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.jsdelivr.net/gh/Dionysen/BlogCDN/img/image-20230621210318410.png"
                      alt="image-20230621210318410" style="zoom:80%;" 
                >

<h4 id="更多属性"><a href="#更多属性" class="headerlink" title="更多属性"></a>更多属性</h4><p>把颜色数据添加为3个float值至vertices数组，把三角形的三个角分别指定为红色、绿色和蓝色：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于现在有更多的数据要发送到顶点着色器，有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是用<code>layout</code>标识符来把aColor属性的位置值设置为1：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不再使用uniform来传递片段的颜色了，现在使用<code>ourColor</code>输出变量，必须再修改一下片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新一下顶点格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);              <span class="comment">// 创建缓冲区</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO); <span class="comment">// 绑定缓冲区</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------- 告诉GPU如何读取顶点数据 ----------</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>); <span class="comment">// 启用顶点属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>))); <span class="comment">// 最后一个是偏移量，因为前面的是位置，后面的是颜色</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br></pre></td></tr></table></figure>

<p>绘制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="comment">// -----</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line">    <span class="comment">// render</span></span><br><span class="line">    <span class="comment">// -----</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.jsdelivr.net/gh/Dionysen/BlogCDN/img/image-20230621211945373.png"
                      alt="image-20230621211945373"
                ></p>
<p>只给定了三个位置和三个颜色，却出现了一个类似于调色一样的东西，这是因为光栅化阶段会进行插值，生成比给定的顶点多得多的顶点，比如可能由上万个。</p>
<h4 id="着色器类"><a href="#着色器类" class="headerlink" title="着色器类"></a>着色器类</h4><p>主要是读取着色器程序的源码，编译，创建着色器程序，链接，有一个使用着色器的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="comment">// constructor generates the shader on the fly</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">Shader</span>(<span class="type">const</span> <span class="type">char</span>* vertexPath, <span class="type">const</span> <span class="type">char</span>* fragmentPath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. retrieve the vertex/fragment source code from filePath</span></span><br><span class="line">        std::string vertexCode;</span><br><span class="line">        std::string fragmentCode;</span><br><span class="line">        std::ifstream vShaderFile;</span><br><span class="line">        std::ifstream fShaderFile;</span><br><span class="line">        <span class="comment">// ensure ifstream objects can throw exceptions:</span></span><br><span class="line">        vShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">        fShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// open files</span></span><br><span class="line">            vShaderFile.<span class="built_in">open</span>(vertexPath);</span><br><span class="line">            fShaderFile.<span class="built_in">open</span>(fragmentPath);</span><br><span class="line">            std::stringstream vShaderStream, fShaderStream;</span><br><span class="line">            <span class="comment">// read file&#x27;s buffer contents into streams</span></span><br><span class="line">            vShaderStream &lt;&lt; vShaderFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">            fShaderStream &lt;&lt; fShaderFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">            <span class="comment">// close file handlers</span></span><br><span class="line">            vShaderFile.<span class="built_in">close</span>();</span><br><span class="line">            fShaderFile.<span class="built_in">close</span>();</span><br><span class="line">            <span class="comment">// convert stream into string</span></span><br><span class="line">            vertexCode   = vShaderStream.<span class="built_in">str</span>();</span><br><span class="line">            fragmentCode = fShaderStream.<span class="built_in">str</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::ifstream::failure&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* vShaderCode = vertexCode.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * fShaderCode = fragmentCode.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="comment">// 2. compile shaders</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vertex, fragment;</span><br><span class="line">        <span class="comment">// vertex shader</span></span><br><span class="line">        vertex = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">        <span class="built_in">glShaderSource</span>(vertex, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">glCompileShader</span>(vertex);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(vertex, <span class="string">&quot;VERTEX&quot;</span>);</span><br><span class="line">        <span class="comment">// fragment Shader</span></span><br><span class="line">        fragment = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">        <span class="built_in">glShaderSource</span>(fragment, <span class="number">1</span>, &amp;fShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">glCompileShader</span>(fragment);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(fragment, <span class="string">&quot;FRAGMENT&quot;</span>);</span><br><span class="line">        <span class="comment">// shader Program</span></span><br><span class="line">        ID = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">        <span class="built_in">glAttachShader</span>(ID, vertex);</span><br><span class="line">        <span class="built_in">glAttachShader</span>(ID, fragment);</span><br><span class="line">        <span class="built_in">glLinkProgram</span>(ID);</span><br><span class="line">        <span class="built_in">checkCompileErrors</span>(ID, <span class="string">&quot;PROGRAM&quot;</span>);</span><br><span class="line">        <span class="comment">// delete the shaders as they&#x27;re linked into our program now and no longer necessary</span></span><br><span class="line">        <span class="built_in">glDeleteShader</span>(vertex);</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// activate the shader</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUseProgram</span>(ID); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// utility uniform functions</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBool</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">bool</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;         </span><br><span class="line">        <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), (<span class="type">int</span>)value); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInt</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">int</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFloat</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">float</span> value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// utility function for checking shader compilation/linking errors.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkCompileErrors</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> shader, std::string type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> success;</span><br><span class="line">        <span class="type">char</span> infoLog[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">if</span> (type != <span class="string">&quot;PROGRAM&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">            <span class="keyword">if</span> (!success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">glGetShaderInfoLog</span>(shader, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glGetProgramiv</span>(shader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">            <span class="keyword">if</span> (!success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">glGetProgramInfoLog</span>(shader, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用着色器时，要用绝对路径。</strong></p>
<h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>纹理坐标的范围通常是从(0, 0)到(1, 1)，超出部分可以设置环绕方式：</p>
<table>
<thead>
<tr>
<th align="left">环绕方式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GL_REPEAT</td>
<td align="left">对纹理的默认行为。重复纹理图像。</td>
</tr>
<tr>
<td align="left">GL_MIRRORED_REPEAT</td>
<td align="left">和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>
</tr>
<tr>
<td align="left">GL_CLAMP_TO_EDGE</td>
<td align="left">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>
</tr>
<tr>
<td align="left">GL_CLAMP_TO_BORDER</td>
<td align="left">超出的坐标为用户指定的边缘颜色。</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://cdn.jsdelivr.net/gh/Dionysen/BlogCDN/img/image-20230629112410026.png"
                      alt="image-20230629112410026"
                ></p>
<h4 id="纹理的生成过程"><a href="#纹理的生成过程" class="headerlink" title="纹理的生成过程"></a>纹理的生成过程</h4><p>加载stb_image库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>添加一个纹理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> textureID;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width, height, nrComponents;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* data = <span class="built_in">stbi_load</span>(path, &amp;width, &amp;height, &amp;nrComponents, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    GLenum format = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (nrComponents == <span class="number">1</span>)</span><br><span class="line">        format = GL_RED;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nrComponents == <span class="number">3</span>)</span><br><span class="line">        format = GL_RGB;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nrComponents == <span class="number">4</span>)</span><br><span class="line">        format = GL_RGBA;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, format, width, height, <span class="number">0</span>, format, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Texture failed to load at path: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时纹理对象储存在一个可以通过<code>textureID</code>找到的地方。在顶点着色器中传入纹理桌标，再传给片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器是通过采样器访问纹理对象的。</p>
<p><strong>采样器(Sampler)</strong> ：它以纹理类型作为后缀，比如<code>sampler1D</code>、<code>sampler3D</code>，或在我们的例子中的<code>sampler2D</code>。我们可以简单声明一个<code>uniform sampler2D</code>把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。</p>
<p>用GLSL内建的<code>texture</code>函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure>

<p>绘制图形前，绑定纹理，就会自动地把纹理赋值给片段着色器的采样器。</p>
<blockquote>
<p>在一些驱动中，必须要对每个采样器uniform都附加上纹理单元才可以。</p>
</blockquote>
<h4 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h4><p>一个片段着色器可以有多个纹理，一个纹理的位置通常称为一个纹理单元。默认的纹理单元是0，是默认激活的，因此只有一个时不需要手动分配位置和激活。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure>

<p>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用<code>glBindTexture</code>的时候，无需激活任何纹理单元。</p>
<blockquote>
<p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p>
</blockquote>
<p>如果一个片段着色器绑定多个纹理单元，应该这样做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture1;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">... <span class="comment">// 创建纹理1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture2;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">... <span class="comment">// 创建纹理2</span></span><br></pre></td></tr></table></figure>

<p>在片段着色器中创建两个采样器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> sampler_texture1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> sampler_texture2;</span><br></pre></td></tr></table></figure>

<p>告诉OpenGL采样器对应的纹理单元</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ourShader.<span class="built_in">use</span>(); <span class="comment">// 不要忘记在设置uniform变量之前激活着色器程序！</span></span><br><span class="line">ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;sampler_texture1&quot;</span>, <span class="number">0</span>); <span class="comment">// 使用着色器类设置</span></span><br><span class="line">ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;sampler_texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 也可以手动设置</span></span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;sampler_texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;sampler_texture2&quot;</span>), <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后再渲染循环中分别激活并绑定纹理到对应的纹理单元</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br></pre></td></tr></table></figure>

<p>最后片段着色器可以使用纹理了</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br></pre></td></tr></table></figure>

<p>所以总体的连接在于，创建的纹理可以通过ID绑定到对应的纹理单元上，设置采样器分配纹理单元，最后通过texture函数采样纹理，赋值给片段。</p>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>理论上，变换共有三种：旋转，位移，缩放。</p>
<blockquote>
<p>矩阵求逆是一项对于着色器开销很大的运算，因为它必须在场景中的每一个顶点上进行，所以应该尽可能地避免在着色器中进行求逆运算。以学习为目的的话这样做还好，但是对于一个高效的应用来说，你最好先在CPU上计算出法线矩阵，再通过uniform把它传递给着色器（就像模型矩阵一样）。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">glm::mat4 trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>); <span class="comment">// 矩阵的初始化是必要的</span></span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line">std::cout &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 以上代码是创建一个向量，然后用一个变换矩阵乘以此向量，达到变换向量的目的，输出结果为210</span></span><br></pre></td></tr></table></figure>

<h4 id="实现3D"><a href="#实现3D" class="headerlink" title="实现3D"></a>实现3D</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create transformations</span></span><br><span class="line">glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>() * glm::<span class="built_in">radians</span>(<span class="number">50.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"><span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></span><br><span class="line">view = glm::<span class="built_in">translate</span>(view, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="type">float</span>)SCR_WIDTH / (<span class="type">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br></pre></td></tr></table></figure>

<p>注意，矩阵的运算是从右向左的，因此顶点着色器中相乘时应为：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="摄像机类"><a href="#摄像机类" class="headerlink" title="摄像机类"></a>摄像机类</h4><p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些可能用到的常量</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Camera_Movement</span> &#123; FORWARD, BACKWARD, LEFT, RIGHT, UP, DOWN, FASTER_FORWARD, FASTER_BACKWARD, FASTER_LEFT, FASTER_RIGHT &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 摄像机默认值</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> YAW = <span class="number">-90.0f</span>; <span class="comment">// 偏航角度</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PITCH = <span class="number">0.0f</span>; <span class="comment">// 上仰角度</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> SPEED = <span class="number">5.0f</span>; <span class="comment">// 摄像机移动速度，虽然实际是整个空间的物体同时在移动</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> SENSITIVITY = <span class="number">0.1f</span>; <span class="comment">// 鼠标灵敏度，用以计算镜头转向</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> ZOOM = <span class="number">45.0f</span>;       <span class="comment">// 视野，观察空间的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// An abstract camera class that processes input and calculates the</span></span><br><span class="line"><span class="comment">// corresponding Euler Angles, Vectors and Matrices for use in OpenGL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 摄像机属性</span></span><br><span class="line">    glm::vec3 Position; <span class="comment">// 摄像机位置向量</span></span><br><span class="line">    glm::vec3 Front;    <span class="comment">// 方向向量，摄像机指向的目标的方向</span></span><br><span class="line">    glm::vec3 Up; <span class="comment">// 上向量，也即y轴正方向，叉乘方向向量可得右向量</span></span><br><span class="line">    glm::vec3 Right;   <span class="comment">// 右向量，摄像机空间x轴的正方向</span></span><br><span class="line">    glm::vec3 WorldUp; <span class="comment">// 上向量</span></span><br><span class="line">    <span class="comment">// 有了三个互相垂直的轴，外加一个平移向量，即可创建一个矩阵，可以用这个矩阵乘以任何向量来将其变换到那个空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// euler Angles</span></span><br><span class="line">    <span class="type">float</span> Yaw;</span><br><span class="line">    <span class="type">float</span> Pitch;</span><br><span class="line">    <span class="comment">// camera options</span></span><br><span class="line">    <span class="type">float</span> MovementSpeed;</span><br><span class="line">    <span class="type">float</span> MouseSensitivity;</span><br><span class="line">    <span class="type">float</span> Zoom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个向量创建摄像机：</span></span><br><span class="line">    <span class="comment">// 主要参数为：位置，默认为原点;上向量，默认为010；方向向量为00-1,</span></span><br><span class="line">    <span class="comment">// 其他均可以为默认</span></span><br><span class="line">    <span class="built_in">Camera</span>(glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">           glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>), <span class="type">float</span> yaw = YAW,</span><br><span class="line">           <span class="type">float</span> pitch = PITCH)</span><br><span class="line">        : <span class="built_in">Front</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">MovementSpeed</span>(SPEED),</span><br><span class="line">          <span class="built_in">MouseSensitivity</span>(SENSITIVITY), <span class="built_in">Zoom</span>(ZOOM) &#123;</span><br><span class="line">        Position = position;</span><br><span class="line">        WorldUp = up;</span><br><span class="line">        Yaw = yaw;</span><br><span class="line">        Pitch = pitch;</span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用标量创建摄像机</span></span><br><span class="line">    <span class="comment">// 主要参数为：位置，默认为原点;上向量，默认为010；方向向量为00-1,</span></span><br><span class="line">    <span class="comment">// 其他均可以为默认</span></span><br><span class="line">    <span class="built_in">Camera</span>(<span class="type">float</span> posX, <span class="type">float</span> posY, <span class="type">float</span> posZ, <span class="type">float</span> upX, <span class="type">float</span> upY, <span class="type">float</span> upZ,</span><br><span class="line">           <span class="type">float</span> yaw, <span class="type">float</span> pitch)</span><br><span class="line">        : <span class="built_in">Front</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">MovementSpeed</span>(SPEED),</span><br><span class="line">          <span class="built_in">MouseSensitivity</span>(SENSITIVITY), <span class="built_in">Zoom</span>(ZOOM) &#123;</span><br><span class="line">        Position = glm::<span class="built_in">vec3</span>(posX, posY, posZ);</span><br><span class="line">        WorldUp = glm::<span class="built_in">vec3</span>(upX, upY, upZ);</span><br><span class="line">        Yaw = yaw;</span><br><span class="line">        Pitch = pitch;</span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns the view matrix calculated using Euler Angles and the LookAt</span></span><br><span class="line">    <span class="comment">// Matrix</span></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">()</span> <span class="comment">// 生成观察矩阵</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// return glm::lookAt(Position, Position + Front, Up);</span></span><br><span class="line">        <span class="comment">// //</span></span><br><span class="line">        <span class="comment">// lookat函数只需要一个位置，一个目标，和一个上向量，它会自己创建一个观察矩阵，此观察矩阵点乘空间中的物体，即可将物体变换到此观察空间中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------ 以下为自己的lookat：</span></span><br><span class="line">        <span class="comment">// 1. Position = known</span></span><br><span class="line">        <span class="comment">// 2. Calculate cameraDirection</span></span><br><span class="line">        glm::vec3 zaxis = glm::<span class="built_in">normalize</span>(-Front);</span><br><span class="line">        <span class="comment">// 3. Get positive right axis vector</span></span><br><span class="line">        glm::vec3 xaxis =</span><br><span class="line">            glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(glm::<span class="built_in">normalize</span>(WorldUp), zaxis));</span><br><span class="line">        <span class="comment">// 4. Calculate camera up vector</span></span><br><span class="line">        glm::vec3 yaxis = glm::<span class="built_in">cross</span>(zaxis, xaxis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create translation and rotation matrix</span></span><br><span class="line">        <span class="comment">// In glm we access elements as mat[col][row] due to column-major layout</span></span><br><span class="line">        glm::mat4 translation = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>); <span class="comment">// Identity matrix by default</span></span><br><span class="line">        translation[<span class="number">3</span>][<span class="number">0</span>] = -Position.x;         <span class="comment">// Third column, first row</span></span><br><span class="line">        translation[<span class="number">3</span>][<span class="number">1</span>] = -Position.y;</span><br><span class="line">        translation[<span class="number">3</span>][<span class="number">2</span>] = -Position.z;</span><br><span class="line">        glm::mat4 rotation = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        rotation[<span class="number">0</span>][<span class="number">0</span>] = xaxis.x; <span class="comment">// First column, first row</span></span><br><span class="line">        rotation[<span class="number">1</span>][<span class="number">0</span>] = xaxis.y;</span><br><span class="line">        rotation[<span class="number">2</span>][<span class="number">0</span>] = xaxis.z;</span><br><span class="line">        rotation[<span class="number">0</span>][<span class="number">1</span>] = yaxis.x; <span class="comment">// First column, second row</span></span><br><span class="line">        rotation[<span class="number">1</span>][<span class="number">1</span>] = yaxis.y;</span><br><span class="line">        rotation[<span class="number">2</span>][<span class="number">1</span>] = yaxis.z;</span><br><span class="line">        rotation[<span class="number">0</span>][<span class="number">2</span>] = zaxis.x; <span class="comment">// First column, third row</span></span><br><span class="line">        rotation[<span class="number">1</span>][<span class="number">2</span>] = zaxis.y;</span><br><span class="line">        rotation[<span class="number">2</span>][<span class="number">2</span>] = zaxis.z;</span><br><span class="line">        <span class="keyword">return</span> rotation * translation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processes input received from any keyboard-like input system. Accepts</span></span><br><span class="line">    <span class="comment">// input parameter in the form of camera defined ENUM (to abstract it from</span></span><br><span class="line">    <span class="comment">// windowing systems)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessKeyboard</span><span class="params">(Camera_Movement direction, <span class="type">float</span> deltaTime)</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> velocity = MovementSpeed * deltaTime; <span class="comment">// 设定速度</span></span><br><span class="line">        <span class="comment">// 根据方向调整方向向量</span></span><br><span class="line">        <span class="keyword">if</span> (direction == FORWARD)</span><br><span class="line">            Position += Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == BACKWARD)</span><br><span class="line">            Position -= Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == LEFT)</span><br><span class="line">            Position -= Right * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == RIGHT)</span><br><span class="line">            Position += Right * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == UP)</span><br><span class="line">            Position.y += velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == DOWN)</span><br><span class="line">            Position.y -= velocity;</span><br><span class="line">        <span class="comment">// Position.y = 0.0f; // 确保不会偏离xz平面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setting faster</span></span><br><span class="line">        <span class="keyword">if</span> (direction == FASTER_FORWARD)</span><br><span class="line">            Position += Front * (velocity * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction == FASTER_BACKWARD)</span><br><span class="line">            Position -= Front * (velocity * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction == FASTER_LEFT)</span><br><span class="line">            Position -= Right * (velocity * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (direction == FASTER_RIGHT)</span><br><span class="line">            Position += Right * (velocity * <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processes input received from a mouse input system. Expects the offset</span></span><br><span class="line">    <span class="comment">// value in both the x and y direction.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessMouseMovement</span><span class="params">(<span class="type">float</span> xoffset, <span class="type">float</span> yoffset,</span></span></span><br><span class="line"><span class="params"><span class="function">                              GLboolean constrainPitch = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">        xoffset *= MouseSensitivity; <span class="comment">// x方向的鼠标偏离</span></span><br><span class="line">        yoffset *= MouseSensitivity; <span class="comment">// y方向的鼠标偏离</span></span><br><span class="line"></span><br><span class="line">        Yaw += xoffset;   <span class="comment">// 偏航</span></span><br><span class="line">        Pitch += yoffset; <span class="comment">// 仰角</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constrainPitch) <span class="comment">// 确保仰角足够大时屏幕不会被翻转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">                Pitch = <span class="number">89.0f</span>;</span><br><span class="line">            <span class="keyword">if</span> (Pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">                Pitch = <span class="number">-89.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update Front, Right and Up Vectors using the updated Euler angles</span></span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processes input received from a mouse scroll-wheel event. Only requires</span></span><br><span class="line">    <span class="comment">// input on the vertical wheel-axis</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessMouseScroll</span><span class="params">(<span class="type">float</span> yoffset)</span> <span class="comment">// 处理缩放</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Zoom -= (<span class="type">float</span>)yoffset;</span><br><span class="line">        <span class="keyword">if</span> (Zoom &lt; <span class="number">1.0f</span>)</span><br><span class="line">            Zoom = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">if</span> (Zoom &gt; <span class="number">45.0f</span>)</span><br><span class="line">            Zoom = <span class="number">45.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 从更新后的相机的欧拉角计算方向向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// calculate the new Front vector</span></span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">        <span class="comment">// 同时重新计算了右向量和上向量</span></span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        <span class="comment">// 将向量归一化，因为你向上或向下看的次数越多，它们的长度就越接近0，这会导致移动速度变慢。</span></span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">OpenGL-2 基础</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">Dionysen</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2023-07-01 14:25:01</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2023/07/01/note/Framework/OpenGL/Opengl Basic/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/CPP/"><i class="fa-solid fa-hashtag"></i>&nbsp;CPP</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/OpenGL/"><i class="fa-solid fa-hashtag"></i>&nbsp;OpenGL</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/Graphic/"><i class="fa-solid fa-hashtag"></i>&nbsp;Graphic</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/Computer/"><i class="fa-solid fa-hashtag"></i>&nbsp;Computer</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023/07/03/note/Experience/Unicode%20error/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">VSCode - argument of type &#34;const char *&#34; is incompatible with parameter of type &#34;LPCWSTR&#34; 错误的解决方法</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/06/29/note/Framework/OpenGL/Win32OpenGL/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">基于Win32的OpenGL3.3</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            
            <div class="pjax-reload" id="load-comments">显示评论</div>
            
                <div class="comment-container">
                    

<div class="comments-container" id="comments-show" style="display: none;">
    <div id="comments-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments"></i>&nbsp;评论
    </div>
    
        
            

    <div class="gitalk-comment-container">
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.css">
        <script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
        <script data-pjax>
          function loadGitalk() {
            let __gitalk__pathname = decodeURI(location.pathname);
            const __gitalk__pathnameLength = __gitalk__pathname.length;
            const __gitalk__pathnameMaxLength = 50;
            if (__gitalk__pathnameLength > __gitalk__pathnameMaxLength) {
              __gitalk__pathname = __gitalk__pathname.substring(0, __gitalk__pathnameMaxLength - 3) + '...';
            }

            try {
              Gitalk && new Gitalk({
                clientID: '5297a6c30ff4654f692f',
                clientSecret: 'ef4506ab93254f2d4e7b41c04958e94bd131a3b6',
                repo: 'BlogCDN',
                owner: 'Dionysen',
                admin: 'Dionysen',
                id: __gitalk__pathname,
                proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
                language: 'zh-CN'
              }).render('gitalk-container');
            } catch (e) {
              window.Gitalk = null;
            }
          }

          if ('true' === 'true') {
            const loadGitalkTimeout = setTimeout(() => {
              loadGitalk();
              clearTimeout(loadGitalkTimeout);
            }, 1000);
          } else {
            window.addEventListener('DOMContentLoaded', loadGitalk);
          }
        </script>
    </div>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">着色器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%91%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">向量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-number">1.2.</span> <span class="nav-text">输入与输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Uniform"><span class="nav-number">1.3.</span> <span class="nav-text">Uniform</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.</span> <span class="nav-text">更多属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text">着色器类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B9%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">纹理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">纹理的生成过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E5%8D%95%E5%85%83"><span class="nav-number">2.2.</span> <span class="nav-text">纹理单元</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E6%8D%A2"><span class="nav-number">3.</span> <span class="nav-text">变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B03D"><span class="nav-number">3.1.</span> <span class="nav-text">实现3D</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">摄像机类</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2026
            
                <!-- &nbsp;<i class="fas fa-heart icon-animate"></i> -->
                &nbsp;<a href="/">Dionysen</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
            </div>
        
        <!-- <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div> -->
        <p id="hitokoto_all"><a target="_blank" rel="noopener" href="https://hitokoto.cn/" id="hitokoto_text">获取诗词中 ... </a></p>
        <script async data-pjax
            >
            fetch('https://v1.hitokoto.cn/?c=i')
                .then(function (res){
                return res.json();
            })
            .then(function (data) {
                var hitokoto_all = document.getElementById('hitokoto_all');
                hitokoto_all.innerText =  data.hitokoto + "  —— " + data.from_who +"《" + data.from + "》" ; 
            })
            .catch(function (err) {
                console.error(err);
            })   
        </script>
        
            <script async data-pjax >
                var toggleButton = document.getElementById("load-comments");
                var commentsContainer = document.getElementById("comments-show");
                toggleButton.addEventListener("click", function() {
                    if (commentsContainer.style.display === "none") {
                        commentsContainer.style.display = "block";
                        toggleButton.innerHTML = "隐藏评论";
                    } else {
                        commentsContainer.style.display = "none";
                        toggleButton.innerHTML = "显示评论";
                    }
                });
            </script>
        
       
        
        
    </div>
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        <!-- 
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
         -->

        <!-- go comment -->
        <!-- 
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
         -->
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li> 

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>



    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        window.mermaid = mermaid;
        // 确保在 KEEP 对象初始化后再执行
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof KEEP !== 'undefined' && KEEP.utils) {
                KEEP.utils.mermaidInit();
            }
        });
    </script>
    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/mermaid.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });
     

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
