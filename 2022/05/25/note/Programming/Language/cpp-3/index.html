<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="It is this intellectual activity of inquiry, seeking, rather than summative answers, that make one a philosopher, because summative answers can easily be reduced to unthinking dogmas and slogans that require no thought or understanding at all.">
    <meta name="author" content="Dionysen">
    
        <title>
            
                C Plus Plus - Enhancement |
                    
                        DIONYSEN BLOG
        </title>

        <link
            href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600&family=Noto+Serif+SC:wght@400;600;700&display=swap"
            rel="stylesheet">

        
<link rel="stylesheet" href="/css/style.css">

            <link rel="shortcut icon" href="/images/logo.svg">
                <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
                    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
                        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
                            <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
                                <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"dionysen.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066cc","right_side_width":"500px","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.png","font_size":"16px","font_family":"Open Sans, Noto Serif SC, serif","code_font_family":"Fira Code, Noto Serif SC, serif, monospace","code_font_size":"0.96rem","static-shadow":true,"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.jpg","background_img_dark":"/images/bg_dark.jpg","description":"或许，正如蒙田所说，所有知识最多只是可能、合理和有效。或许，根本就没有这样的“基础”以及由此建立起来的知识大厦，只有多重交织的网络。人们可能会像蒙田和怀疑论者那样主张，我们的知识永远不会是确定的（除非在极其微不足道的事情上或特殊的环境下）。","font_color":null,"hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{"enable":false},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"gitalk","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":"Dionysen","github_admins":null,"repository":"BlogCDN","client_id":"5297a6c30ff4654f692f","client_secret":"ef4506ab93254f2d4e7b41c04958e94bd131a3b6","proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":false,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":false},"img_align":"left","copyright_info":true},"mermaid":{"enable":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.0.0"></head>
<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               DIONYSEN BLOG
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="https://dionysen.github.io/en/"
                            >
                                ENGLISH
                            </a>
                        </li>
                    
                    
                        <li class="menu-item flex-center toggle-show-toc">
                            <i class="fas fa-list"></i>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                       
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="https://dionysen.github.io/en/">ENGLISH</a>
                </li>
            
            <!-- <li class="menu-item tool-dark-light-toggle flex-center">
                <i class="fas fa-moon"></i>
            </li> -->
        </ul>
    </div>
    <li class="menu-item tool-dark-light-toggle flex-center">
        <i class="fas fa-moon"></i>
    </li>
    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">C Plus Plus - Enhancement</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Dionysen</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2022-05-25 17:34</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <!-- <i class="fas fa-folder"></i>&nbsp; -->
            <ul>
                
                    <li>
                        <i class="fas fa-chevron-circle-right"></i>&nbsp<a href="/categories/%E9%80%92%E5%BD%92%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C-%C2%B7-%E7%BC%96%E7%A8%8B/">递归这个世界 · 编程</a>&nbsp;
                    </li>
                
                    <li>
                        <i class="fas fa-chevron-circle-right"></i>&nbsp<a href="/categories/%E9%80%92%E5%BD%92%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C-%C2%B7-%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
        <span class="article-tags article-meta-item">
            <br/>
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Programming/"><i class="fas fa-hashtag"></i>&nbsp;Programming</a>
                    </li>
                
                    <li>
                        <a href="/tags/cpp/"><i class="fas fa-hashtag"></i>&nbsp;cpp</a>
                    </li>
                
            </ul>
        </span>
    


    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;&nbsp;<span>17.3k 字</span>
        </span>
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                
                <p>本阶段主要针对cpp<em><strong>泛型编程</strong></em>和<em><strong>STL</strong></em>技术做详细讲解，探讨cpp更深层的使用</p>
<span id="more"></span>

<h2 id="一、模板"><a href="#一、模板" class="headerlink" title="一、模板"></a>一、模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong><br>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul>
<li><p>cpp另一种编程思想称为 <em><strong>泛型编程</strong></em> ，主要利用的技术就是模板</p>
</li>
<li><p>cpp提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p>
</li>
</ul>
<h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：<br>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。<br><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong><br>template  —  声明创建模板<br>typename  — 表面其后面的符号是一种数据类型，可以用class代替<br>T    —   通用的数据类型，名称可以替换，通常为大写字母<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> temp = a;</span><br><span class="line"> a = b;</span><br><span class="line"> b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line"> <span class="type">double</span> temp = a;</span><br><span class="line"> a = b;</span><br><span class="line"> b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> T temp = a;</span><br><span class="line"> a = b;</span><br><span class="line"> b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="comment">//swapInt(a, b);</span></span><br><span class="line"> <span class="comment">//利用模板实现交换</span></span><br><span class="line"> <span class="comment">//1、自动类型推导</span></span><br><span class="line"> <span class="built_in">mySwap</span>(a, b);</span><br><span class="line"> <span class="comment">//2、显示指定类型</span></span><br><span class="line"> <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数模板利用关键字 template</p>
</li>
<li><p>使用函数模板有两种方式：自动类型推导、显示指定类型</p>
</li>
<li><p>模板的目的是为了提高复用性，将类型参数化</p>
</li>
</ul>
<h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li>
<li>模板必须要确定出T的数据类型，才可以使用<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> T temp = a;</span><br><span class="line"> a = b;</span><br><span class="line"> b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"> <span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line"> <span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line"> <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试<br>示例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> T temp = a;</span><br><span class="line"> a = b;</span><br><span class="line"> b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">   &#123;</span><br><span class="line">    max = j;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//测试char数组</span></span><br><span class="line"> <span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line"> <span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line"> <span class="built_in">mySort</span>(charArr, num);</span><br><span class="line"> <span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//测试int数组</span></span><br><span class="line"> <span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line"> <span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"> <span class="built_in">mySort</span>(intArr, num);</span><br><span class="line"> <span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板可以提高代码复用，需要熟练掌握</p>
<h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"> <span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"> <span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line"> <span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"> <span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line"> myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"> <span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line"> <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"> <span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"> <span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line"> <span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> <span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"> <span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的<br><strong>例如：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了<br>再例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行<br>因此cpp为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> string m_Name;</span><br><span class="line"> <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (a *** b)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> ( p1.m_Name  *** p2.m_Name &amp;&amp; p1.m_Age *** p2.m_Age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line"> <span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line"> <span class="keyword">if</span> (ret)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a *** b &quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"> <span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line"> <span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line"> <span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line"> <span class="keyword">if</span> (ret)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1 *** p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>利用具体化的模板，可以解决自定义类型的通用化</p>
</li>
<li><p>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</p>
</li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。<br><strong>语法：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong><br>template  —  声明创建模板<br>typename  — 表面其后面的符号是一种数据类型，可以用class代替<br>T    —   通用的数据类型，名称可以替换，通常为大写字母<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> NameType mName;</span><br><span class="line"> AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line"> Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line"> P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> NameType mName;</span><br><span class="line"> AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line"> Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line"> p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line"> p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类模板使用只能用显示指定类型方式</p>
</li>
<li><p>类模板中的模板参数列表可以有默认参数</p>
</li>
</ul>
<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> T obj;</span><br><span class="line"> <span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> MyClass&lt;Person1&gt; m;</span><br><span class="line"> m.<span class="built_in">fun1</span>();</span><br><span class="line"> <span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式<br>一共有三种传入方式：</li>
</ul>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> NameType mName;</span><br><span class="line"> AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line"> <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> p.<span class="built_in">showPerson</span>();</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line"> <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"> p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line"> <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="built_in">test03</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过类模板创建的对象，可以有三种方式向函数中进行传参</p>
</li>
<li><p>使用比较广泛是第一种：指定传入的类型</p>
</li>
</ul>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"> T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//class Son:public Base  //错误，cpp编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Son c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Son2</span>()</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//成员函数类内声明</span></span><br><span class="line"> <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> T1 m_Name;</span><br><span class="line"> T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"> <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"> <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"> p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式<br>问题：</li>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到<br>解决：</li>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制<br><strong>示例：</strong><br>person.hpp中代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> T1 m_Name;</span><br><span class="line"> T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"> <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"> <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"> p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现<br>全局函数类内实现 - 直接在类内声明友元即可<br>全局函数类外实现 - 需要提前让编译器知道全局函数的存在<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p);</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line"> <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line"> <span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> T1 m_Name;</span><br><span class="line"> T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line"> <span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line"> <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//test01();</span></span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量<br><strong>示例：</strong><br>myArray.hpp中代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//构造函数</span></span><br><span class="line"> <span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">  pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//拷贝构造</span></span><br><span class="line"> <span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line">   <span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line">   <span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line"> MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">   <span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line"> T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//尾插法</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity *** <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//尾删法</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size *** <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取数组容量</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取数组大小</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//析构</span></span><br><span class="line"> ~<span class="built_in">MyArray</span>()</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">   <span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"> <span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"> <span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类模板案例—数组类封装.cpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">  cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">printIntArray</span>(array1);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line"> array2.<span class="built_in">Pop_back</span>();</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">printIntArray</span>(array2);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> string m_Name;</span><br><span class="line"> <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//创建数组</span></span><br><span class="line"> <span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"> <span class="comment">//插入数据</span></span><br><span class="line"> pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line"> pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line"> pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line"> pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line"> pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"> <span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//test01();</span></span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够利用所学知识点实现通用的数组</p>
<h2 id="二、STL"><a href="#二、STL" class="headerlink" title="二、STL"></a>二、STL</h2><h3 id="初识容器"><a href="#初识容器" class="headerlink" title="初识容器"></a>初识容器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 创建容器</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);<span class="comment">//向容器中放数据</span></span><br><span class="line">v.<span class="built_in">begin</span>() <span class="comment">//返回第一个元素</span></span><br><span class="line">v.<span class="built_in">end</span>()  <span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="comment">/* 遍历 */</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it ++)&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"> cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>存放自定义数据的时候，初始化容器数据是要使用数据类型的构造函数。访问时使用<code>(*it).member</code></p>
</li>
<li><p>存放对象指针：<code>vector&lt;class *&gt; v</code> ，放入数据时要放入地址：<code>v.push_back(&amp;Object)</code></p>
</li>
<li><p>容器嵌套容器：<code>vector&lt;vector&lt;int&gt;&gt; v</code>，遍历时要用嵌套<code>for</code>循环。<br>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持<code>++</code>、<code>***</code>、<code>!=</code></td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持<code>++</code></td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持<code>++</code>、<code>***</code>、<code>!=</code></td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持<code>++</code>、<code>--</code>，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持<code>++</code>、<code>--</code>、<code>[n]</code>、<code>-n</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
</tr>
<tr>
<td>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>本质上是一个类<br><code>char *</code>是一个指针，而<code>string</code>是一个类，内部封装了<code>char *</code>，来管理这个字符串，所以<code>string</code>是一个<code>char *</code>型的容器</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>find</td>
<td>查找</td>
</tr>
<tr>
<td>copy</td>
<td>拷贝</td>
</tr>
<tr>
<td>delete</td>
<td>删除</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
</tr>
<tr>
<td>insert</td>
<td>插入</td>
</tr>
</tbody></table>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str;</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n, <span class="type">char</span> c);<span class="comment">//使用n个字符c初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">char</span> c);<span class="comment">//字符赋值给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串</span></span><br></pre></td></tr></table></figure>

<p>带operator&#x3D;的是等号运算符重载，即可以用另一个数据和<code>=</code>给其赋值，assingn则是成员函数，需要调用函数才能赋值</p>
<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> c);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> string&amp; str);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//同operator+=(const string&amp; str)</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>; <span class="comment">//字符串s中从pos开始的n个字符连接到字符串结尾</span></span><br></pre></td></tr></table></figure>

<h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//查找字符c最后一次出现位置</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string&amp; str)</span></span>;<span class="comment">//替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n,<span class="type">const</span> <span class="type">char</span>* s)</span></span>;<span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>

<p>ﬁnd查找是从左往后，rﬁnd从右往左<br>ﬁnd找到字符串后返回查找的第一个字符位置，找不到返回-1<br>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</p>
<h4 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="comment">//比较ASCII码</span></span><br><span class="line"><span class="comment">//= 返回0</span></span><br><span class="line"><span class="comment">//&gt; 返回1</span></span><br><span class="line"><span class="comment">//&lt; 返回-1</span></span><br></pre></td></tr></table></figure>

<h4 id="单个字符存取"><a href="#单个字符存取" class="headerlink" title="单个字符存取"></a>单个字符存取</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//通过[]方式取字符</span></span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure>

<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;<span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string&amp; str)</span></span>;<span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c</span></span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串子串"><a href="#字符串子串" class="headerlink" title="字符串子串"></a>字符串子串</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>单端数组，可以动态扩展，但扩展时不是直接接上，而是寻找更大的空间拷贝过去，释放原来的空间</p>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v;<span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, element);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector &amp;vec); <span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">assign</span>(begin, end);<span class="comment">//将[begin, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, element);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br></pre></td></tr></table></figure>

<h4 id="容量和大小"><a href="#容量和大小" class="headerlink" title="容量和大小"></a>容量和大小</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">empty</span>(); <span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">capacity</span>(); <span class="comment">//容器的容量</span></span><br><span class="line"><span class="built_in">size</span>(); <span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num); <span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num, elem); <span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除</span></span><br></pre></td></tr></table></figure>

<h4 id="插入和删除-1"><a href="#插入和删除-1" class="headerlink" title="插入和删除"></a>插入和删除</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(ele);<span class="comment">//尾部插入元素ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(const_iterator pos, ele);<span class="comment">//迭代器指向位置pos插入元素ele</span></span><br><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele); <span class="comment">//迭代器指向位置pos插入count个元素ele</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);</span><br><span class="line"><span class="comment">//删除迭代器指向的元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end); <span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>

<h4 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx);<span class="comment">//返回索引idx所指的数据</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>

<h4 id="两个容器交换"><a href="#两个容器交换" class="headerlink" title="两个容器交换"></a>两个容器交换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(vec);</span><br><span class="line"><span class="comment">// 将vec与本身的元素互换</span></span><br></pre></td></tr></table></figure>

<h4 id="预留空间"><a href="#预留空间" class="headerlink" title="预留空间"></a>预留空间</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reserve</span>(<span class="type">int</span> len); <span class="comment">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>

<p>目的是减少动态扩展时的扩展次数</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端数组，头尾均可插入或删除，头部插入比vector快，但访问元素的速度没有vector快<br>deque是一片连续的内存空间</p>
<h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值-2"><a href="#赋值-2" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br></pre></td></tr></table></figure>

<h4 id="容量和大小-1"><a href="#容量和大小-1" class="headerlink" title="容量和大小"></a>容量和大小</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque.<span class="built_in">empty</span>(); <span class="comment">//判断容器是否为空</span></span><br><span class="line">deque.<span class="built_in">size</span>(); <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num); <span class="comment">//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num, elem); <span class="comment">//重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>

<h4 id="插入和删除-2"><a href="#插入和删除-2" class="headerlink" title="插入和删除"></a>插入和删除</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除容器第一个数据</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem); <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem); <span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end); <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>(); <span class="comment">//清空容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end); <span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos); <span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure>

<p>数据存取：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx);<span class="comment">//返回索引idx所指的数据</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>

<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(iterator beg, iterator end)</span><br><span class="line"><span class="comment">//对beg和end区间内元素进行排序</span></span><br></pre></td></tr></table></figure>

<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>先进后出，只有顶部的元素才可以使用，因此无法遍历，push入栈，pop出栈</p>
<h4 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数：</span></span><br><span class="line">stack&lt;T&gt; stk;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式</span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="comment">//赋值操作：</span></span><br><span class="line">stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);</span><br><span class="line"><span class="comment">//数据存取：</span></span><br><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="comment">//大小操作：</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断堆栈是否为空</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回栈的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>先进先出，一端进一端出，只有头尾可以被使用，因此也不能遍历</p>
<h4 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数：</span></span><br><span class="line">queue&lt;T&gt; que;<span class="comment">//queue采用模板类实现，queue对象的默认构造形式</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="type">const</span> queue &amp;que);<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="comment">//赋值操作：</span></span><br><span class="line">queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);</span><br><span class="line"><span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="comment">//数据存取：</span></span><br><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br><span class="line"><span class="comment">//大小操作：</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断堆栈是否为空</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回栈的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>链表，一系列指针链组成，是一个双向循环链表，储存不是连续的内存空间，list的迭代器只支持前移和后移，属于双向迭代器<br>采用动态储存分配，不会造成内存浪费或溢出，插入删除只需要修改指针，灵活，但空间和时间消耗大<br><strong>重要性质：</strong> 插入和删除都不会造成原有的迭代器失效，<code>vector</code>是不可以的<br>另外<code>list</code>和<code>vector</code>是最常用的两个容器，各有优缺点</p>
<h4 id="常用接口-2"><a href="#常用接口-2" class="headerlink" title="常用接口"></a>常用接口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">list&lt;T&gt; lst;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list &amp;lst);</span><br><span class="line"><span class="built_in">swap</span>(lst);</span><br><span class="line"><span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="comment">//将lst与本身的元素互换。</span></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="built_in">size</span>(); <span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>(); <span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">resize</span>(num); <span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">resize</span>(num, elem); <span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br><span class="line"><span class="comment">//存取</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素。</span></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转链表</span></span><br><span class="line"><span class="built_in">sort</span>();<span class="comment">//链表排序</span></span><br></pre></td></tr></table></figure>

<h3 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h3><p>所有元素在插入时就被自动排列<br>属关联式容器，底层结构是<em><strong>二叉树</strong></em>实现的<br><code>set</code>不允许有重复的元素，<code>multiset</code>可以有重复的元素；<code>set</code>插入数据后会返回结果，表示是否插入成功，而<code>multiset</code>一定可以成功，所以不会检测数据</p>
<h4 id="常用接口-3"><a href="#常用接口-3" class="headerlink" title="常用接口"></a>常用接口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造：</span></span><br><span class="line">set&lt;T&gt; st;<span class="comment">//默认构造函数：</span></span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set &amp;st);<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="comment">//赋值：</span></span><br><span class="line">set&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set &amp;st);</span><br><span class="line"><span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="comment">//大小和交换</span></span><br><span class="line"><span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回容器中元素的数目</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">swap</span>(st);<span class="comment">//交换两个集合容器</span></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="built_in">insert</span>(elem);<span class="comment">//在容器中插入元素。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg, end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(elem);<span class="comment">//删除容器中值为elem的元素。</span></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="built_in">count</span>(key);<span class="comment">//统计key的元素个数</span></span><br></pre></td></tr></table></figure>

<p>set的默认排序规则为从小到大，利用仿函数可以改变规则</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"> set&lt;<span class="type">int</span>&gt; set_1;</span><br><span class="line"> set_1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"> set_1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"> set_1.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"> set_1.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line"> set_1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"> set_1.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> it = set_1.<span class="built_in">begin</span>(); it != set_1.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> set&lt;<span class="type">int</span>, myCompare&gt; set_2;</span><br><span class="line"> set_2.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"> set_2.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"> set_2.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"> set_2.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"> set_2.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line"> set_2.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> it = set_2.<span class="built_in">begin</span>(); it != set_2.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span> ;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用自定义数据类型时，set必须指定排序规则才可以插入数据</p>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>成对出现的数据可以使用pair</p>
<h4 id="常用接口-4"><a href="#常用接口-4" class="headerlink" title="常用接口"></a>常用接口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建方式</span></span><br><span class="line"><span class="function">pair&lt;type, type&gt; <span class="title">p</span> <span class="params">( value1, value2 )</span></span>;</span><br><span class="line">pair&lt;type, type&gt; p = <span class="built_in">make_pair</span>( value1, value2 );</span><br></pre></td></tr></table></figure>

<h3 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h3><p>所有的元素都是<code>pair</code>，其中第一个元素是<code>key</code>，第二个是<code>value</code>，所有元素都会根据元素的<code>key</code>进行自动排序<br>属于关联式容器，底层结构是用二叉树实现<br>可以通过<code>key</code>值快速找到<code>value</code><br><code>map</code>不能有重复的<code>key</code>，<code>multimap</code>可以有重复的<code>key</code></p>
<h4 id="常用接口-5"><a href="#常用接口-5" class="headerlink" title="常用接口"></a>常用接口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造：</span></span><br><span class="line">map&lt;T1, T2&gt; mp;<span class="comment">//map默认构造函数:</span></span><br><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map &amp;mp);<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="comment">//赋值：</span></span><br><span class="line">map&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map &amp;mp);</span><br><span class="line"><span class="comment">//大小和交换</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">swap</span>(st);<span class="comment">//交换两个集合容器</span></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="built_in">insert</span>(elem);<span class="comment">//在容器中插入元素。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg, end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(key);<span class="comment">//删除容器中值为key的元素。</span></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="built_in">count</span>(key);<span class="comment">//统计key的元素个数</span></span><br></pre></td></tr></table></figure>

<p>也可以利用仿函数指定排序规则</p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>重载函数调用操作符的类，其对象称为函数对象<br>函数对象使用重载时，行为类似函数调用，所以也叫仿函数<br>是一个类而非函数<br>函数对象可以有参数也可以有返回值<br>但函数对象超出普通函数的概念，有自己的状态<br>函数对象可以作为参数进行传递</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">add</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">add</span>()&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add add;</span><br><span class="line">    add.<span class="built_in">operator</span>()(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    add.<span class="built_in">operator</span>()(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    add.<span class="built_in">operator</span>()(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    add.<span class="built_in">operator</span>()(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; add.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The keys of cpp comparing to c language is Object-oriented and Generic programming.</p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>类似于find,可查找字符串中某个字符出现的次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcdefgaaadsasafas&quot;</span>;</span><br><span class="line"><span class="type">int</span> numOfA = s.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>map</code>类的数据使用<code>count</code>的时候，传入的参数应是<code>key</code>而非<code>value</code>。</p>
<h2 id="三、函数对象"><a href="#三、函数对象" class="headerlink" title="三、函数对象"></a>三、函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong><br><strong>本质：</strong><br>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</li>
</ul>
<h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递<br><strong>示例:</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v1 + v2;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> MyAdd myAdd;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">MyPrint</span>()</span><br><span class="line"> &#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">  count++; <span class="comment">//统计使用次数</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> MyPrint myPrint;</span><br><span class="line"> <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> MyPrint myPrint;</span><br><span class="line"> <span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello cpp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//test01();</span></span><br><span class="line"> <span class="comment">//test02();</span></span><br><span class="line"> <span class="built_in">test03</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line"> <span class="keyword">if</span> (it *** v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数只有一个的谓词，称为一元谓词</li>
</ul>
<h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"> <span class="comment">//默认从小到大</span></span><br><span class="line"> <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line"> <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数只有两个的谓词，称为二元谓词</li>
</ul>
<h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象<br><strong>分类:</strong></li>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数<br><strong>用法：</strong></li>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include &lt;functional&gt;</code></li>
</ul>
<h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算<br><strong>仿函数原型：</strong></li>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                &#x2F;&#x2F;加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              &#x2F;&#x2F;减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    &#x2F;&#x2F;乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         &#x2F;&#x2F;除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         &#x2F;&#x2F;取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           &#x2F;&#x2F;取反仿函数<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></li>
</ul>
<h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>实现关系对比<br><strong>仿函数原型：</strong></p>
</li>
<li><p><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    &#x2F;&#x2F;等于</p>
</li>
<li><p><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            &#x2F;&#x2F;不等于</p>
</li>
<li><p><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      &#x2F;&#x2F;大于</p>
</li>
<li><p><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          &#x2F;&#x2F;大于等于</p>
</li>
<li><p><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           &#x2F;&#x2F;小于</p>
</li>
<li><p><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               &#x2F;&#x2F;小于等于<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//自己实现仿函数</span></span><br><span class="line"> <span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"> <span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line"> <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关系仿函数中最常用的就是<code>greater&lt;&gt;</code>大于</p>
<h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>实现逻辑运算<br><strong>函数原型：</strong></p>
</li>
<li><p><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              &#x2F;&#x2F;逻辑与</p>
</li>
<li><p><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                &#x2F;&#x2F;逻辑或</p>
</li>
<li><p><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              &#x2F;&#x2F;逻辑非<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line"> vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line"> v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"> <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑仿函数实际应用较少，了解即可</li>
</ul>
<h2 id="四、STL常用算法"><a href="#四、STL常用算法" class="headerlink" title="四、STL常用算法"></a>四、STL常用算法</h2><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p><strong>概述</strong>:</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li>
<li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法<br><strong>算法简介：</strong></li>
<li><code>for_each</code>     &#x2F;&#x2F;遍历容器</li>
<li><code>transform</code>   &#x2F;&#x2F;搬运容器到另一个容器中</li>
</ul>
<h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器<br><strong>函数原型：</strong></li>
<li><code>for_each(iterator beg, iterator end, _func);</code><br>&#x2F;&#x2F; 遍历算法 遍历容器元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; _func 函数或者函数对象<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//遍历算法</span></span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for_each</code>在实际开发中是最常用遍历算法，需要熟练掌握</li>
</ul>
<h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中<br><strong>函数原型：</strong></li>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code><br>&#x2F;&#x2F;beg1 源容器开始迭代器<br>&#x2F;&#x2F;end1 源容器结束迭代器<br>&#x2F;&#x2F;beg2 目标容器开始迭代器<br>&#x2F;&#x2F;_func 函数或者函数对象<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"> vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"> <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"> for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>搬运的目标容器必须要提前开辟空间，否则无法正常搬运<br>也可以用来转换大小写：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),str.<span class="built_in">begin</span>(),::tolower); <span class="built_in">transform</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),str.<span class="built_in">begin</span>(),::toupper);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p>
<ul>
<li>掌握常用的查找算法<br><strong>算法简介：</strong></li>
<li><code>find</code>                     &#x2F;&#x2F;查找元素</li>
<li><code>find_if</code>               &#x2F;&#x2F;按条件查找元素</li>
<li><code>adjacent_find</code>    &#x2F;&#x2F;查找相邻重复元素</li>
<li><code>binary_search</code>    &#x2F;&#x2F;二分查找法</li>
<li><code>count</code>                   &#x2F;&#x2F;统计元素个数</li>
<li><code>count_if</code>             &#x2F;&#x2F;按条件统计元素个数</li>
</ul>
<h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()<br><strong>函数原型：</strong></p>
</li>
<li><p><code>find(iterator beg, iterator end, value);</code><br>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 查找的元素<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"> <span class="keyword">if</span> (it *** v.<span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//重载***</span></span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>***(<span class="type">const</span> Person&amp; p)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name *** p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age *** p.m_Age)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> string m_Name;</span><br><span class="line"> <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vector&lt;Person&gt; v;</span><br><span class="line"> <span class="comment">//创建数据</span></span><br><span class="line"> <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"> v.<span class="built_in">push_back</span>(p1);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p2);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p3);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"> vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line"> <span class="keyword">if</span> (it *** v.<span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></li>
</ul>
<h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>按条件查找元素<br><strong>函数原型：</strong></p>
</li>
<li><p><code>find_if(iterator beg, iterator end, _Pred);</code><br>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line"> <span class="keyword">if</span> (it *** v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> string m_Name;</span><br><span class="line"> <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vector&lt;Person&gt; v;</span><br><span class="line"> <span class="comment">//创建数据</span></span><br><span class="line"> <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"> v.<span class="built_in">push_back</span>(p1);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p2);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p3);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"> vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line"> <span class="keyword">if</span> (it *** v.<span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//test01();</span></span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>find_if</code>按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</li>
</ul>
<h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>查找相邻重复元素<br><strong>函数原型：</strong></p>
</li>
<li><p><code>adjacent_find(iterator beg, iterator end);</code><br>&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"> <span class="comment">//查找相邻重复元素</span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"> <span class="keyword">if</span> (it *** v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>面试题中如果出现查找相邻重复元素，记得用STL中的<code>adjacent_find</code>算法</li>
</ul>
<h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>查找指定元素是否存在<br><strong>函数原型：</strong></p>
</li>
<li><p><code>bool binary_search(iterator beg, iterator end, value);</code><br>&#x2F;&#x2F; 查找指定的元素，查到 返回true  否则false<br>&#x2F;&#x2F; 注意: 在<strong>无序序列中不可用</strong><br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 查找的元素<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//二分查找</span></span><br><span class="line"> <span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 二分查找法查找效率很高，值得注意的是<em><strong>查找的容器中元素必须的有序序列</strong></em></p>
<h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>统计元素个数<br><strong>函数原型：</strong></p>
</li>
<li><p><code>count(iterator beg, iterator end, value);</code><br>&#x2F;&#x2F; 统计元素出现次数<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 统计的元素<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"> <span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>***(<span class="type">const</span> Person &amp; p)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age *** p.m_Age)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> string m_Name;</span><br><span class="line"> <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;Person&gt; v;</span><br><span class="line"> <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"> v.<span class="built_in">push_back</span>(p1);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p2);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p3);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"> <span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//test01();</span></span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>统计自定义数据类型时候，需要配合重载 <code>operator***</code></li>
</ul>
<h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>按条件统计元素个数<br><strong>函数原型：</strong></p>
</li>
<li><p><code>count_if(iterator beg, iterator end, _Pred);</code><br>&#x2F;&#x2F; 按条件统计元素出现次数<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; _Pred 谓词<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"> <span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> string m_Name;</span><br><span class="line"> <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;Person&gt; v;</span><br><span class="line"> <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"> <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"> v.<span class="built_in">push_back</span>(p1);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p2);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p3);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"> v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"> <span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//test01();</span></span><br><span class="line"> <span class="built_in">test02</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按值统计用<code>count</code>，按条件统计用<code>count_if</code></li>
</ul>
<h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法<br><strong>算法简介：</strong></li>
<li><code>sort</code>             &#x2F;&#x2F;对容器内元素进行排序</li>
<li><code>random_shuffle</code>   &#x2F;&#x2F;洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge</code>           &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       &#x2F;&#x2F; 反转指定范围的元素</li>
</ul>
<h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>对容器内元素进行排序<br><strong>函数原型：</strong></p>
</li>
<li><p><code>sort(iterator beg, iterator end, _Pred);</code><br>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F;  beg    开始迭代器<br>&#x2F;&#x2F;  end    结束迭代器<br>&#x2F;&#x2F; _Pred  谓词<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"> <span class="comment">//sort默认从小到大排序</span></span><br><span class="line"> <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//从大到小排序</span></span><br><span class="line"> <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sort</code>属于开发中最常用的算法之一，需熟练掌握</li>
</ul>
<h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>洗牌   指定范围内的元素随机调整次序<br><strong>函数原型：</strong></p>
</li>
<li><p><code>random_shuffle(iterator beg, iterator end);</code><br>&#x2F;&#x2F; 指定范围内的元素随机调整次序<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//打乱顺序</span></span><br><span class="line"> <span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>random_shuffle</code>洗牌算法比较实用，使用时记得加随机数种子</li>
</ul>
<h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>两个容器元素合并，并存储到另一容器中<br><strong>函数原型：</strong></p>
</li>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br>&#x2F;&#x2F; 容器元素合并，并存储到另一容器中<br>&#x2F;&#x2F; 注意: 两个容器必须是<strong>有序的</strong><br>&#x2F;&#x2F; beg1   容器1开始迭代器<br>&#x2F;&#x2F; end1   容器1结束迭代器<br>&#x2F;&#x2F; beg2   容器2开始迭代器<br>&#x2F;&#x2F; end2   容器2结束迭代器<br>&#x2F;&#x2F; dest    目标容器开始迭代器<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">  v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line"> <span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line"> vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"> <span class="comment">//合并  需要两个有序序列</span></span><br><span class="line"> <span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line"> for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>merge</code>合并的两个容器必须的有序序列</li>
</ul>
<h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>将容器内元素进行反转<br><strong>函数原型：</strong></p>
</li>
<li><p><code>reverse(iterator beg, iterator end);</code><br>&#x2F;&#x2F; 反转指定范围的元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>reverse</code>反转区间内元素，面试题可能涉及到</li>
</ul>
<h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法<br><strong>算法简介：</strong></li>
<li><code>copy</code>                      &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if</code>          &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     &#x2F;&#x2F; 互换两个容器的元素</li>
</ul>
<h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>容器内指定范围的元素拷贝到另一容器中<br><strong>函数原型：</strong></p>
</li>
<li><p><code>copy(iterator beg, iterator end, iterator dest);</code><br>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F; beg  开始迭代器<br>&#x2F;&#x2F; end  结束迭代器<br>&#x2F;&#x2F; dest 目标起始迭代器<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"> v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line"> <span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"> for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用<code>copy</code>算法在拷贝时，目标容器记得提前开辟空间</li>
</ul>
<h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>将容器内指定范围的旧元素修改为新元素<br><strong>函数原型：</strong></p>
</li>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code><br>&#x2F;&#x2F; 将区间内旧元素 替换成 新元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; oldvalue 旧元素<br>&#x2F;&#x2F; newvalue 新元素<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>replace</code>会替换区间内满足条件的元素</li>
</ul>
<h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong></p>
<ul>
<li><p>将区间内满足条件的元素，替换成指定元素<br><strong>函数原型：</strong></p>
</li>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code><br>&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; _pred 谓词<br>&#x2F;&#x2F; newvalue 替换的新元素<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>replace_if</code>按条件查找，可以利用仿函数灵活筛选满足的条件</li>
</ul>
<h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>互换两个容器的元素<br><strong>函数原型：</strong></p>
</li>
<li><p><code>swap(container c1, container c2);</code><br>&#x2F;&#x2F; 互换两个容器的元素<br>&#x2F;&#x2F; c1容器1<br>&#x2F;&#x2F; c2容器2<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line"> for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">swap</span>(v1, v2);</span><br><span class="line"> for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>swap</code>交换容器时，注意交换的容器要同种类型</li>
</ul>
<h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li><p>掌握常用的算术生成算法<br><strong>注意：</strong></p>
</li>
<li><p>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code><br><strong>算法简介：</strong></p>
</li>
<li><p><code>accumulate</code>      &#x2F;&#x2F; 计算容器元素累计总和</p>
</li>
<li><p><code>fill</code>                 &#x2F;&#x2F; 向容器中添加元素</p>
</li>
</ul>
<h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>计算区间内 容器元素累计总和<br><strong>函数原型：</strong></p>
</li>
<li><p><code>accumulate(iterator beg, iterator end, value);</code><br>&#x2F;&#x2F; 计算容器元素累计总和<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 起始值<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>accumulate</code>使用时头文件注意是 <code>numeric</code>，这个算法很实用</li>
</ul>
<h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>向容器中填充指定的元素<br><strong>函数原型：</strong></p>
</li>
<li><p><code>fill(iterator beg, iterator end, value);</code><br>&#x2F;&#x2F; 向容器中填充元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 填充的值<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"> v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"> <span class="comment">//填充</span></span><br><span class="line"> <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"> for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用<code>fill</code>可以将容器区间内元素填充为指定的值</li>
</ul>
<h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法<br><strong>算法简介：</strong></li>
<li><code>set_intersection</code>          &#x2F;&#x2F; 求两个容器的交集</li>
<li><code>set_union</code>                       &#x2F;&#x2F; 求两个容器的并集</li>
<li><code>set_difference</code>              &#x2F;&#x2F; 求两个容器的差集</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>求两个容器的交集<br><strong>函数原型：</strong></p>
</li>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br>&#x2F;&#x2F; 求两个集合的交集<br>&#x2F;&#x2F; <strong>注意：两个集合必须是有序序列</strong><br>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">  v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"> <span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line"> vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"> <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator itEnd =</span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"> for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>求两个集合的并集<br><strong>函数原型：</strong></p>
</li>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br>&#x2F;&#x2F; 求两个集合的并集<br>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong><br>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"> <span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line"> vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"> <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator itEnd =</span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"> for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li><p>求两个集合的差集<br><strong>函数原型：</strong></p>
</li>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br>&#x2F;&#x2F; 求两个集合的差集<br>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong><br>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"> <span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line"> vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"> <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator itEnd =</span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"> for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line"> itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"> for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">C Plus Plus - Enhancement</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">Dionysen</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2022-05-25 17:34:01</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2022/05/25/note/Programming/Language/cpp-3/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Programming/"><i class="fa-solid fa-hashtag"></i>&nbsp;Programming</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/cpp/"><i class="fa-solid fa-hashtag"></i>&nbsp;cpp</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2022/05/25/note/Programming/Language/cpp-2/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">C Plus Plus - Core</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2022/05/25/note/Programming/Language/cpp-4/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C Plus Plus - Skill</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            
            <div class="pjax-reload" id="load-comments">显示评论</div>
            
                <div class="comment-container">
                    

<div class="comments-container" id="comments-show" style="display: none;">
    <div id="comments-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments"></i>&nbsp;评论
    </div>
    
        
            

    <div class="gitalk-comment-container">
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.css">
        <script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
        <script data-pjax>
          function loadGitalk() {
            let __gitalk__pathname = decodeURI(location.pathname);
            const __gitalk__pathnameLength = __gitalk__pathname.length;
            const __gitalk__pathnameMaxLength = 50;
            if (__gitalk__pathnameLength > __gitalk__pathnameMaxLength) {
              __gitalk__pathname = __gitalk__pathname.substring(0, __gitalk__pathnameMaxLength - 3) + '...';
            }

            try {
              Gitalk && new Gitalk({
                clientID: '5297a6c30ff4654f692f',
                clientSecret: 'ef4506ab93254f2d4e7b41c04958e94bd131a3b6',
                repo: 'BlogCDN',
                owner: 'Dionysen',
                admin: 'Dionysen',
                id: __gitalk__pathname,
                proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
                language: 'zh-CN'
              }).render('gitalk-container');
            } catch (e) {
              window.Gitalk = null;
            }
          }

          if ('true' === 'true') {
            const loadGitalkTimeout = setTimeout(() => {
              loadGitalk();
              clearTimeout(loadGitalkTimeout);
            }, 1000);
          } else {
            window.addEventListener('DOMContentLoaded', loadGitalk);
          }
        </script>
    </div>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.</span> <span class="nav-text">一、模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 模板的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 函数模板语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 函数模板注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 函数模板案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.2.4 普通函数与函数模板的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">1.2.5.</span> <span class="nav-text">1.2.5 普通函数与函数模板的调用规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">1.2.6.</span> <span class="nav-text">1.2.6 模板的局限性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1 类模板语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2 类模板与函数模板区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3 类模板中成员函数创建时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">1.3.4 类模板对象做函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-5-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.5.</span> <span class="nav-text">1.3.5 类模板与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-6-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.6.</span> <span class="nav-text">1.3.6 类模板成员函数类外实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-7-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="nav-number">1.3.7.</span> <span class="nav-text">1.3.7 类模板分文件编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-8-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83"><span class="nav-number">1.3.8.</span> <span class="nav-text">1.3.8 类模板与友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-9-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B"><span class="nav-number">1.3.9.</span> <span class="nav-text">1.3.9 类模板案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81STL"><span class="nav-number">2.</span> <span class="nav-text">二、STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E5%AE%B9%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">初识容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">2.2.</span> <span class="nav-text">string</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC"><span class="nav-number">2.2.2.</span> <span class="nav-text">赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-number">2.2.3.</span> <span class="nav-text">字符串拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2"><span class="nav-number">2.2.4.</span> <span class="nav-text">查找替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">2.2.5.</span> <span class="nav-text">字符串的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96"><span class="nav-number">2.2.6.</span> <span class="nav-text">单个字符存取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">2.2.7.</span> <span class="nav-text">插入和删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E4%B8%B2"><span class="nav-number">2.2.8.</span> <span class="nav-text">字符串子串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">2.3.</span> <span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">容量和大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-1"><span class="nav-number">2.3.4.</span> <span class="nav-text">插入和删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="nav-number">2.3.5.</span> <span class="nav-text">数据存取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%AE%B9%E5%99%A8%E4%BA%A4%E6%8D%A2"><span class="nav-number">2.3.6.</span> <span class="nav-text">两个容器交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4"><span class="nav-number">2.3.7.</span> <span class="nav-text">预留空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">2.4.</span> <span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F-1"><span class="nav-number">2.4.3.</span> <span class="nav-text">容量和大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-2"><span class="nav-number">2.4.4.</span> <span class="nav-text">插入和删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.5.</span> <span class="nav-text">排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-number">2.5.</span> <span class="nav-text">stack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.1.</span> <span class="nav-text">常用接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-number">2.6.</span> <span class="nav-text">queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-1"><span class="nav-number">2.6.1.</span> <span class="nav-text">常用接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">2.7.</span> <span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-2"><span class="nav-number">2.7.1.</span> <span class="nav-text">常用接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E5%92%8Cmultiset"><span class="nav-number">2.8.</span> <span class="nav-text">set和multiset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-3"><span class="nav-number">2.8.1.</span> <span class="nav-text">常用接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pair"><span class="nav-number">2.9.</span> <span class="nav-text">pair</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-4"><span class="nav-number">2.9.1.</span> <span class="nav-text">常用接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E5%92%8Cmultimap"><span class="nav-number">2.10.</span> <span class="nav-text">map和multimap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-5"><span class="nav-number">2.10.1.</span> <span class="nav-text">常用接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.11.</span> <span class="nav-text">函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count"><span class="nav-number">2.12.</span> <span class="nav-text">count</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">三、函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.</span> <span class="nav-text">4.1 函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.1.</span> <span class="nav-text">4.1.1 函数对象概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">4.1.2  函数对象使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E8%B0%93%E8%AF%8D"><span class="nav-number">3.2.</span> <span class="nav-text">4.2  谓词</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E8%B0%93%E8%AF%8D%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.1.</span> <span class="nav-text">4.2.1 谓词概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D"><span class="nav-number">3.2.2.</span> <span class="nav-text">4.2.2 一元谓词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D"><span class="nav-number">3.2.3.</span> <span class="nav-text">4.2.3 二元谓词</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.3.</span> <span class="nav-text">4.3 内建函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%84%8F%E4%B9%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">4.3.1 内建函数对象意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E7%AE%97%E6%9C%AF%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">4.3.2 算术仿函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.3.</span> <span class="nav-text">4.3.3 关系仿函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.4.</span> <span class="nav-text">4.3.4 逻辑仿函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">四、STL常用算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Algorithm"><span class="nav-number"></span> <span class="nav-text">Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">0.1.</span> <span class="nav-text">5.1 常用遍历算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-for-each"><span class="nav-number">0.1.1.</span> <span class="nav-text">5.1.1 for_each</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-transform"><span class="nav-number">0.1.2.</span> <span class="nav-text">5.1.2 transform</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">0.2.</span> <span class="nav-text">5.2 常用查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-find"><span class="nav-number">0.2.1.</span> <span class="nav-text">5.2.1 find</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-find-if"><span class="nav-number">0.2.2.</span> <span class="nav-text">5.2.2 find_if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-adjacent-find"><span class="nav-number">0.2.3.</span> <span class="nav-text">5.2.3 adjacent_find</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-binary-search"><span class="nav-number">0.2.4.</span> <span class="nav-text">5.2.4 binary_search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5-count"><span class="nav-number">0.2.5.</span> <span class="nav-text">5.2.5 count</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-6-count-if"><span class="nav-number">0.2.6.</span> <span class="nav-text">5.2.6 count_if</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">0.3.</span> <span class="nav-text">5.3 常用排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-sort"><span class="nav-number">0.3.1.</span> <span class="nav-text">5.3.1 sort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-random-shuffle"><span class="nav-number">0.3.2.</span> <span class="nav-text">5.3.2 random_shuffle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-merge"><span class="nav-number">0.3.3.</span> <span class="nav-text">5.3.3 merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4-reverse"><span class="nav-number">0.3.4.</span> <span class="nav-text">5.3.4 reverse</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">0.4.</span> <span class="nav-text">5.4 常用拷贝和替换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-copy"><span class="nav-number">0.4.1.</span> <span class="nav-text">5.4.1 copy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-replace"><span class="nav-number">0.4.2.</span> <span class="nav-text">5.4.2 replace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3-replace-if"><span class="nav-number">0.4.3.</span> <span class="nav-text">5.4.3 replace_if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-4-swap"><span class="nav-number">0.4.4.</span> <span class="nav-text">5.4.4 swap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="nav-number">0.5.</span> <span class="nav-text">5.5 常用算术生成算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-accumulate"><span class="nav-number">0.5.1.</span> <span class="nav-text">5.5.1 accumulate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-fill"><span class="nav-number">0.5.2.</span> <span class="nav-text">5.5.2 fill</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95"><span class="nav-number">0.6.</span> <span class="nav-text">5.6 常用集合算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1-set-intersection"><span class="nav-number">0.6.1.</span> <span class="nav-text">5.6.1 set_intersection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-2-set-union"><span class="nav-number">0.6.2.</span> <span class="nav-text">5.6.2 set_union</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-3-set-difference"><span class="nav-number">0.6.3.</span> <span class="nav-text">5.6.3  set_difference</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2025
            
                <!-- &nbsp;<i class="fas fa-heart icon-animate"></i> -->
                &nbsp;<a href="/">Dionysen</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
            </div>
        
        <!-- <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div> -->
        <p id="hitokoto_all"><a target="_blank" rel="noopener" href="https://hitokoto.cn/" id="hitokoto_text">获取诗词中 ... </a></p>
        <script async data-pjax
            >
            fetch('https://v1.hitokoto.cn/?c=i')
                .then(function (res){
                return res.json();
            })
            .then(function (data) {
                var hitokoto_all = document.getElementById('hitokoto_all');
                hitokoto_all.innerText =  data.hitokoto + "  —— " + data.from_who +"《" + data.from + "》" ; 
            })
            .catch(function (err) {
                console.error(err);
            })   
        </script>
        
            <script async data-pjax >
                var toggleButton = document.getElementById("load-comments");
                var commentsContainer = document.getElementById("comments-show");
                toggleButton.addEventListener("click", function() {
                    if (commentsContainer.style.display === "none") {
                        commentsContainer.style.display = "block";
                        toggleButton.innerHTML = "隐藏评论";
                    } else {
                        commentsContainer.style.display = "none";
                        toggleButton.innerHTML = "显示评论";
                    }
                });
            </script>
        
       
        
        
    </div>
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        <!-- 
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
         -->

        <!-- go comment -->
        <!-- 
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
         -->
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li> 

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>



    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        window.mermaid = mermaid;
        // 确保在 KEEP 对象初始化后再执行
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof KEEP !== 'undefined' && KEEP.utils) {
                KEEP.utils.mermaidInit();
            }
        });
    </script>
    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/mermaid.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });
     

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
