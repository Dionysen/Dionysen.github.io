[{"title":"AI设想","url":"/2025/03/03/note/Algorithm/AI/","content":"最基本的框架。\n\n\n概念：感知到的印象加以符号印记，即人脑中的概念是符号到印象的映射。如苹果-&gt;真实的感受（红色的果子，甜的口感，有汁水，有果皮）。可见，概念之中包含概念，包含是逻辑关系的一种。\n逻辑关系：分类（也即哲学&#x2F;思考的本源）的依据。相等、不等；包含、并列；大于、小于；相加、相减；有、无；数学在此之上一层。\n输入：感知，语料、图料（这些足够了）。\n输出：文本（语言），图像（图像语言）。LLM不无道理，计算机与外界交互主要是这两点。声音是文本的扩展。\n目的：这个极为重要，是生命区别与非生命最重要的特征。AI的目的应该是学习（最初），然后服务人类（最后）。\n记忆：概念的网络。苹果属于水果，包含水果皮，果肉，果核等，水果皮又包含…从一点出发，可扩展至所有节点，这张大网包含了所有的概念与概念之间的关系。关系并非单一的关系，如不等与大于可以同时存在。\n回忆：概念的检索，忘记应该是存储的失败而不是检索的失败，否则数据无限膨胀，人的大脑也是删除不重要的记忆来保持容量的，当然也许还有别的机制，如记忆融合，压缩等。\n思考：概念的重组。\n评判：基于已有的记忆，套用到当前思考对象上，合乎逻辑则对，否则错。\n学习：概念网络的编织。\n巩固学习：网络的构成比较复杂，网络结构需要加强印证，且随时可能被改变（被什么改变？于人类而言是实践，AI呢？逻辑内禀于人类的大脑，可能因为世界本身的规则，人类不需要很困难就可以学会1+1&#x3D;2，AI如何学会。事实上人类不要学习1+1&#x3D;2，而是纯感知即可得出此结论，AI如何得出？）。\n创造像人类一样的AI，第一步：不要创造像人类一样的AI。去创造像草履虫一样的AI。\n","categories":["递归这个世界 · 编程","算法"],"tags":["Programming","Data structure","Algorithm"]},{"title":"Algorithm","url":"/2023/05/25/note/Algorithm/Algorithm/","content":"\n同一个问题，不同的算法，结果一样而所消耗资源不一样\n\n大O表示法：算法的时间复杂度通常用大O符号表述，定义为 T[n] &#x3D; O(f(n)) 。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。\n\n\n时间复杂度\n常数阶 O(1)代码中没有影响到其所用时间的变量如：\nvoid swapTwoInts(int &amp;a, int &amp;b)&#123;    int temp = a;    a = b;    b = temp;&#125;\n\n线性阶 O(n)代码中有变量可以影响到执行所用的时间，它们的关系是线性的如：\nint sum ( int n )&#123;    int ret = 0;    for ( int i = 0 ; i &lt;= n ; i ++)&#123;        ret += i;    &#125;    return ret;&#125;\n\n平方阶 O(n${^2}$)\n\n\n代码中的变量与执行代码所用时间的关系是平方如遍历for循环嵌套for循环\n\n对数阶 O(logn)在二分查找中，通过while循环，成2倍数的缩减搜索范围，也就是说需要经过log2^n次可以跳出循环。\n\nint binarySearch( int arr[], int n , int target)&#123;    int l = 0, r = n - 1;    while ( l &lt;= r) &#123;        int mid = l + (r - l) / 2;        if (arr[mid] == target) return mid;        if (arr[mid] &gt; target ) r = mid - 1;        else l = mid + 1;    &#125;    return -1;&#125;\n\n以下代码也是O(logn)的时间复杂度\n// 整形转成字符串string intToString ( int num )&#123;    string s = &quot;&quot;;    // n 经过几次“除以10”的操作后，等于0    while (num )&#123;        s += &#x27;0&#x27; + num%10;        num /= 10;    &#125;    reverse(s)        return s;&#125;\n\n\n线性对数阶 O(nlogn)将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)\nvoid hello ()&#123;    for( m = 1 ; m &lt; n ; m++)&#123;        i = 1;        while( i &lt; n )&#123;            i = i * 2;        &#125;    &#125;&#125;\n\n空间复杂度\n递归与迭代递归：函数中调用函数本身\n迭代：每次迭代的结果作为下一次迭代的初始值\n\nProgram &#x3D; Data Structure + Algorithm\n\nComplexityHow to judge a algorithm?How to contrast diferent algorithms?Big O Notation: The limiting case of the time or space required by the algorithm as the computational magnitude increases.\n\nT(n) &#x3D; O(f(n))\n\nTime Complexity\nExample 1:\n\nfor (int i = 1; i &lt;= n; i++)&#123;    x++;&#125;\n\nThe time complexity of the for loop is O(n).\n\nExample 2:\n\nfor (int i = 1; i &lt;= n; i++)&#123;    x++;&#125;for (int i = 1; i &lt;= n; i++)&#123;    for (int j = 1; j &lt;= n; j++)&#123;        x++;    &#125;&#125;\n\nThere are a single for loop and a double for loop, and the complexity of the former is O(n) and the latter is O(n$^{2}$) . So when n tends to be infinite, the complexity of whole algorithm is O(n$^{2}$).\nAnalysis of Commonly used time complexity order\n\nConstant order O(1)int x = 0;int y = 1;int temp = x;x = y;y = temp;\n\nAs long as there is no complex logic such as loops or recursion, the code is O(1) complex no matter how many lines of code are executed.\nLinear order O(n)for (int i = 1; i &lt;= n; i++) &#123;    x++;&#125;\n\nIn this code, the for loop is executed n times, so the computation time varies with n, so this kind of code can be expressed by O(n).\nThe logarithmic order O(log n)int i = 1;while(i &lt; n) &#123;    i = i * 2;&#125;\n\nIn the above loop, each time i is multiplied by 2, which means each time i is a step closer to n. So how many cycles does it take for i to be equal to or greater than n, which is solving for 2${^x}$ is equal to n. The answer is x &#x3D; log 2${^n}$. So after log 2${^n}$ cycles, i is going to be greater than or equal to n, and that’s the end of the code. So the complexity of this code is O(log n).\nLinear log order O(nlog n)for(int i = 0; i &lt;= n: i++) &#123;    int x = 1;    while(x &lt; n) &#123;        x = x * 2;    &#125;&#125;\n\nLinear log order O(nlog n) is easy to understand, which means you loop through O(log n) code n times. Each loop is order O(log n),  n * log n = n(log n).\nSquared square order O(n${^2}$)for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= n; j++) &#123;        x++;    &#125;&#125;\n\nO(n${^2}$) is essentially n*n, if we change the number of cycles in the inner layer to m:\nfor (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;        x++;    &#125;&#125;\n\nThe complexity becomes n * m &#x3D; O(nm).\nSpace ComplexitySince “time complexity” is not the amount of time a program consumes, “space complexity” is not used to calculate the amount of space a program consumes. As the magnitude of the problem increases, the amount of memory a program needs to allocate may also increase, and “space complexity” reflects the tendency of memory space to increase.\nO(1) Space complexityint x = 0;int y = 0;x++;y++;\n\nThe space allocated by x and y does not change with the amount of data processed, so the space complexity is O(1).\nO(n) Space complexityint[] newArray = new int[n];for (int i = 0; i &lt; n; i++) &#123;    newArray[i] = i;&#125;\n\nIn this code, we create an array of length nand then assign values to the elements in the loop. Therefore, the “space complexity” of this code depends on the length of newArray, which is n, so S(n) &#x3D; O(n).\nSorting AlgorithmsSearching is a very important step in computers, but it is often difficult to find a specific number from unordered data. Binary searching, as we mentioned earlier, only works in sorted arrays. So the sorting algorithm is a very important job, and if we can sort the numbers, then we can save a lot of effort when we’re looking for a particular number.\nThere are many sorting algorithms, and each has its own advantages and disadvantages:\n\n\n\nAlgorithm\nTime Complexity(Best)\nTime Complexity(Average)\nTime Complexity(Worst)\nSpace Complexity\n\n\n\nQuiksort\nΩ(n log(n))\nΘ(n log(n))\nΩ(n${^2}$)\nO(log(n))\n\n\nMergesort\nΩ(n log(n))\nΘ(n log(n))\nO(n log(n))\nO(n)\n\n\nTimesort\nΩ(n)\nΘ(n log(n))\nO(n log(n))\nO(n)\n\n\nHeapsort\nΩ(n log(n))\nΘ(n log(n))\nO(n log(n))\nO(1)\n\n\nBubble Sort\nΩ(n)\nΘ(n${^2}$)\nO(n${^2}$)\nO(1)\n\n\nInsertion Sort\nΩ(n)\nΘ(n${^2}$)\nO(n${^2}$)\nO(1)\n\n\nSelection Sort\nΩ(n${^2}$)\nΘ(n${^2}$)\nO(n${^2}$)\nO(1)\n\n\nTree Sort\nΩ(n log(n))\nΘ(n log(n))\nO(n${^2}$)\nO(n)\n\n\nShell Sort\nΩ(n log(n))\nΘ(n (log(n))${^2}$)\nO(n (log(n))${^2}$)\nO(1)\n\n\nBucket Sort\nΩ(n+k)\nΘ(n+k)\nO(n${^2}$)\nO(n)\n\n\nRadix Sort\nΩ(nk)\nΘ(nk)\nO(nk)\nO(n+k)\n\n\nCounting Sort\nΩ(n+k)\nΘ(n+k)\nO(n+k)\nO(k)\n\n\nCubesort\nΩ(n)\nΘ(n log(n))\nO(n log(n))\nO(n)\n\n\nInsertion SortInsertion sort is a simple and intuitive sorting algorithm. In insertion sort, we process the unsorted elements from front to back. For each element, we compare it to the previously sorted elements, find the corresponding position, and insert.\nEssentially, for each element to be processed, we only care about its relationship to the previous element, and we only deal with the elements after the current element in the next round.\nSpecific steps:\n\nStarting with the second element (the first new element to be sorted), the sequence of previous elements is scanned backwards\nIf the current scanned element is larger than the current element, the scanned element is moved to the next bit\nRepeat Step 2 until you find a position less than or equal to the new element\nInsert the new element at that location\nRepeat Steps 1 through 4 for subsequent elements\n\nvoid inseritonSort(int arr[], int arrayLength) &#123;    for (int i = 1; i &lt; arrayLength; i++) &#123;        int cur = arr[i];        int inseritonIndex = i - 1;        while (inseritonIndex &gt;= 0 &amp;&amp; arr[inseritonIndex] &gt; cur) &#123;            arr[inseritonIndex + 1] = arr[inseritonIndex];            inseritonIndex--;        &#125;        arr[inseritonIndex + 1] = cur;    &#125;&#125;\n\n\nT(n) &#x3D; O(n${^2}$)\nS(n) &#x3D; O(1)\n\nQuick SortQuicksort is a Divide and Conquer algorithm in which we turn big problems into small ones, and solve the small ones one by one, so that when the small ones are solved, the big ones will be solved.\nThe basic idea of quicksort is to pick a target element and then put the target element in the correct position in the array. The array is then split into two subarrays based on the sorted elements, using the same method and the same operation for the unsorted range.\nSpecific steps:\n\nFor the current array, we’re going to use the last element as our pivot\nAll elements smaller than the base number are ranked before the base number, and those larger than the base number are ranked after the base number\nOnce the base number is in place, the element is split into two front and back subarrays based on the cardinality position\nUse steps 1 through 4 recursively for subarrays until the subarray is 1 or less in length\n\nvoid swap(int arr[], int a, int b) &#123;    int temp = arr[a];    arr[a] = arr[b];    arr[b] = temp;&#125;int partition(int arr[], int left, int right) &#123;    int pivot = arr[right];    int leftIndex = left;    int rightIndex = right - 1;    while (1) &#123;        while (leftIndex &lt; right &amp;&amp; arr[leftIndex] &lt;= pivot) &#123;            leftIndex++;        &#125;        while (rightIndex &gt;= left &amp;&amp; arr[rightIndex] &gt; pivot) &#123;            rightIndex--;        &#125;        if (leftIndex &gt; rightIndex) break;        swap(arr, leftIndex, rightIndex);    &#125;    swap(arr, leftIndex, right);    return leftIndex;&#125;void quickSort(int arr[], int left, int right) &#123;    if (left &gt;= right) return;    int partitionIndex = partition(arr, left, right);    quickSort(arr, left, partitionIndex - 1);    quickSort(arr, partitionIndex + 1, right);&#125;void printArray(int arr[], int arrayLength) &#123;    for (int i = 0; i &lt; arrayLength; i++) &#123;        std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; &quot;\\n&quot;;&#125;\n\n\nT(n) &#x3D; O(n${^2}$).  Average time complexity is O(n(log n)).S(n) &#x3D; O(n). Average time complexity is O(log n).\n\n","categories":["递归这个世界 · 编程","算法"],"tags":["Programming"]},{"title":"二叉树","url":"/2023/07/19/note/Algorithm/BinaryTree/","content":"struct TreeNode &#123;    int val;    TreeNode* left;    TreeNode* right;    TreeNode(int v) : val(v), left(nullptr), right(nullptr) &#123;&#125;&#125;;\n\n二叉树是一种常见的树状数据结构，它由节点（Node）和边（Edge）组成。每个节点最多有两个子节点，分别称为左子节点（Left Child）和右子节点（Right Child）。\n\n\n基本概念\n根节点（Root Node）：二叉树的顶部节点，没有父节点的节点。\n叶子节点（Leaf Node）：没有子节点的节点，也称为终端节点。\n内部节点（Internal Node）：除了叶子节点之外的其他节点。\n子树（Subtree）：以某个节点为根的子树，由该节点及其所有后代节点组成。\n深度（Depth）：从根节点到某个节点的唯一路径上的边数，根节点的深度为0。\n高度（Height）：从某个节点到其最远叶子节点的路径上的边数，叶子节点的高度为0。\n\n二叉树类型\n二叉搜索树（Binary Search Tree）：左子节点的值小于等于父节点的值，右子节点的值大于等于父节点的值。\n\nstruct TreeNode &#123;    int val;    TreeNode* left;    TreeNode* right;    TreeNode(int v) : val(v), left(nullptr), right(nullptr) &#123;&#125;&#125;;// 插入操作TreeNode* insertNode(TreeNode* root, int val) &#123;    if (root == nullptr) &#123;        return new TreeNode(val);    &#125;    if (val &lt; root-&gt;val) &#123;        root-&gt;left = insertNode(root-&gt;left, val);    &#125; else &#123;        root-&gt;right = insertNode(root-&gt;right, val);    &#125;    return root;&#125;// 查找操作TreeNode* searchNode(TreeNode* root, int val) &#123;    if (root == nullptr || root-&gt;val == val) &#123;        return root;    &#125;    if (val &lt; root-&gt;val) &#123;        return searchNode(root-&gt;left, val);    &#125; else &#123;        return searchNode(root-&gt;right, val);    &#125;&#125;// 中序遍历void inorderTraversal(TreeNode* root) &#123;    if (root) &#123;        inorderTraversal(root-&gt;left);        std::cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;        inorderTraversal(root-&gt;right);    &#125;&#125;\n\n\n完全二叉树（Complete Binary Tree）：除了最后一层外，其他层的节点数达到最大，并且最后一层的节点依次从左到右排列。\n\n满二叉树（Full Binary Tree）：除了叶子节点外，每个节点都有两个子节点。\n\n平衡二叉树（Balanced Binary Tree）：任意节点的左子树和右子树的高度差不超过1。\n\n\n二叉树操作\n插入节点：向二叉树中添加新的节点。\n删除节点：从二叉树中移除指定节点。\n查找节点：在二叉树中搜索具有特定值的节点。\n\n遍历按照特定顺序访问二叉树中的所有节点，包括前序遍历、中序遍历、后序遍历和层序遍历等。\n三种遍历方式，关键是看每一个子树根节点的顺序：\n\n\n\n遍历方式\n顺序\n\n\n\n先序遍历\n根-左-右\n\n\n中序遍历\n左-根-右\n\n\n后序遍历\n左-右-根\n\n\n递归写法：\n// 先序遍历void preorderTraversalRecursive(TreeNode* root) &#123;    if (root == nullptr) &#123;        return;    &#125;    std::cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;  // 输出当前节点的值    preorderTraversalRecursive(root-&gt;left);  // 递归遍历左子树    preorderTraversalRecursive(root-&gt;right);  // 递归遍历右子树&#125;\n\n迭代写法：\n// 先序遍历void preorderTraversalIterative(TreeNode* root) &#123;    if (root == nullptr) &#123;        return;    &#125;    std::stack&lt;TreeNode*&gt; nodeStack;    nodeStack.push(root);    while (!nodeStack.empty()) &#123;        TreeNode* node = nodeStack.top();        nodeStack.pop();        std::cout &lt;&lt; node-&gt;val &lt;&lt; &quot; &quot;;  // 输出当前节点的值        if (node-&gt;right != nullptr) &#123;            nodeStack.push(node-&gt;right);        &#125;        if (node-&gt;left != nullptr) &#123;            nodeStack.push(node-&gt;left);        &#125;    &#125;&#125;\n\n","categories":["递归这个世界 · 编程","算法"],"tags":["Programming"]},{"title":"Data Structure","url":"/2023/05/25/note/Algorithm/DataStrucuture/","content":"ArrayArray has fixed size and contiguous memory. New elements cannot be appended. You can use memory address to access elements of Array. \nchar a[5] = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;,&#125;; C++ counts food tags from `0`, so `a[0] = &#x27;h&#x27;` and `a[1] = &#x27;e&#x27;`.Random access using `a[i]` has `O(1)` time complexity.Units of array can be modified. \na[0] = &#x27;b&#x27;;\nresult:\nbello\n\n\nDynamic Allocation of ArraysA size-n array can be created in this way:\nchar a[n];\n\nBut when writing the code, n must be known.\nIf n is unknown, how dose the program run?\nchar* a = NULL;int n; // array size cin &gt;&gt; n; // read in the size. e.g., get n = 5a = new char[n];\n\nNow a is an empty array whose size is 5.\n// store somrthing in the arraya[0] = &#x27;h&#x27;;a[1] = &#x27;e&#x27;;a[2] = &#x27;l&#x27;;a[3] = &#x27;l&#x27;;a[4] = &#x27;o&#x27;;\n\nWhen done, free memory. Otherwise, memory leak can happen.\ndelete [] a;a = NULL;\n\n\n\nRemoving an element in the middle has O(n) time complexity. Require moving the remaining items leftward.\nVectorVector is almost the same as array.\nThe main difference is that vector’s capacity can automatically grow.\nNew elements can be appended using push_back() in O(1) time(on average). \nThe last element can be removed using pop_back() in O(1) time.\nstd::vector&lt;char&gt; v = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;; v.push_back();v.pop_back();v.erase(v.begin() + 1);\n\nVector can delete an element in the middle using erase() in O(n) time. So it is not better to do this.\nstd::vector&lt;char&gt; v(100);cout &lt;&lt; v.size();\t\t// print &quot;100&quot;cout &lt;&lt; v.capacity();\t// print &quot;100&quot;// thenv.push_back(&#x27;x&#x27;);cout &lt;&lt; v.size();\t\t// print &quot;101&quot;cout &lt;&lt; v.capacity();\t// print &quot;200&quot;\n\nWhen size is going to exceed capacity, program will create a new array of capacity 200, copy the 100 elements from the old array to the new, put  the new element in the 101st position and free the old array from memory.\nListA NodeA node contains a data and two pointers that one points to the previous node and another points to the next node.\nDoubly Linked Liststd::list&lt;char&gt; l = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;; \n\ncout &lt;&lt; l[2];\t\t// does not workl[0] = &#x27;a&#x27;;\t\t\t// does not work\n\nlist&lt;char&gt;::iterator iter = l.begin();cout &lt;&lt; *iter;\t\t// print &#x27;h&#x27;iter++;cout &lt;&lt; *iter;\t\t// print &#x27;e&#x27;*iter = &#x27;a&#x27;;push_back();push.front();\n\nDiference\n\n\n\nArray\nVector\nList\n\n\n\nSize\nfixed\ncan increase and decrease\ncan increase and decrease\n\n\nMemory\ncontiguous\ncontiguous\nnot contiguous\n\n\n\n\n\n\nArray\nVector\nList\n\n\n\nRand Access\nO(1)\nO(1)\n—\n\n\npush_back()\n—\nO(1)(average)\nO(1)\n\n\npop_back()\n—\nO(1)\nO(1)\n\n\ninsert()\n—\nO(n)(average)\nO(1)\n\n\nerase()\n—\nO(n)(average)\nO(1)\n\n\nWhich shall we use?\nArray: Fixed size throughout.\nVector: \n\nRandom access(i.e., read or write the i-th element) is fast.\nInsertion and deletion at the end are fas.\ninsertion and deletion in the front and midddle are slow.\n\nList:\n\nSequentially visiting elements is fast; random access is not allowed.\nFrequent insertion and deletion at any position are OK.\n\nBinary Searchint arr[] = &#123;3, 5, 12, 16, 17, 26, 32, 51, 53, 64&#125;;\n\nInputs: (i) an array whose elements are in the accending order and (ii) a key.\nGoal: Search for the key in the array. If found, return its index; if not found, return -1.\nExamle 1:\n\nSearch for the elemnt 53.\nReturn 8.\n\nExample 2:\n\nSearch for the element 9.\nReturn -1.\n\nExample: key = 26.  Use two variables left and right pointing to the front of the array and the back respectively. \nint search(int arr[], int left, int right, int key)&#123;    while (left &lt;= right) &#123;        int mid = (left + right) / 2;        if (key == arr[mid])            return mid;        if (key &gt; arr[mid])            left = mid + 1;        else            right = mid - 1;    &#125;    return -1;&#125;\n\nHow to suport both search and insertion?\nstd::vector&lt;int&gt; v = &#123;3, 5, 12, 16, 17, 26, 32, 51, 53, 64&#125;;\n\nThe ascending order must be kept; otherwisem search would take O(n) time.Inserting an item into the middle has O(n) time complexity(on average).Can we perform binary search in the list?No, Given left and right, we cannot get mid efficiently.\n\n\n\n\nSearch\nInsertion\n\n\n\nVector\nO(log n)\nO(n)\n\n\nList\nO(n)\nO(1)\n\n\nSkip List\nO(log n)\nO(log n)\n\n\n","categories":["递归这个世界 · 编程","数据结构"],"tags":["Programming","Data Structure"]},{"title":"Singly Linked list","url":"/2023/05/25/note/Algorithm/linked_list/","content":"Now we implement a singly linked list with C++.\n\nLinked list is a Data structure that contains a variable and a pointer pointing to the next node.\n\n\n\nStorage of dataFirst of all, a data structure is needed to store the variable and the pointer. It can be coded:\nstruct Node &#123;       int val;       Node* next;       Node()           : val(0)           , next(nullptr)       &#123;       &#125;       Node(int x)           : val(x)           , next(nullptr)       &#123;       &#125;       Node(int x, Node* next)           : val(x)           , next(next)       &#123;       &#125;   &#125;;\n\nThree constructors are packaged in the struct Node, which can help us create a head of a linked list conveniently.\nNode *head = new Node();Node *head = new Node(0);Node *head = new Node(0, nullptr);\n\nThere are three ways to create a pointer head. Using first way, you can create a pointer head pointing to a node that has a variable val = 0 and a nullptr (a pointer pointing nothing). And the second way, you create a same head but you must assign a value to val of the node pointed to by head. The last, you even can link a node to the head requiring you give a pointer pointing to the next node.\nThen, how to handle the linked list?\nLinked list classclass ListNode &#123;public:    struct Node &#123;        int val;        Node* next;        Node()            : val(0)            , next(nullptr)        &#123;        &#125;        Node(int x)            : val(x)            , next(nullptr)        &#123;        &#125;        Node(int x, Node* next)            : val(x)            , next(next)        &#123;        &#125;    &#125;;    ListNode()    &#123;        this-&gt;head = nullptr;    &#125;    Node* head; \tvoid assign(int val);    int at(int pos);    void set(int pos, int val);    void del(int pos);    int find(int val);    void print();&#125;;\n\nvoid ListNode::assign(int val)&#123;    Node* p = new Node(val);    Node* last = this-&gt;head;    if (last) &#123;        while (last-&gt;next) &#123;            last = last-&gt;next;        &#125;        last-&gt;next = p;    &#125; else &#123;        head = p;    &#125;&#125;int ListNode::at(int pos)&#123;    int index = 0;    Node* p = this-&gt;head;    while (index != pos) &#123;        p = p-&gt;next;        index++;    &#125;    return p-&gt;val;&#125;void ListNode::set(int pos, int val)&#123;    int index = 0;    Node* p = this-&gt;head;    while (index != pos) &#123;        p = p-&gt;next;        index++;    &#125;    p-&gt;val = val;&#125;void ListNode::del(int pos)&#123;    Node* p = this-&gt;head;    if (pos == 0) &#123;        head = head-&gt;next;        delete p;    &#125; else &#123;        int index = 0;        Node* p = this-&gt;head;        Node* q;        for (q = nullptr; p; q = p, p = p-&gt;next) &#123;            if (index == pos - 1) &#123;                q-&gt;next = p-&gt;next;                delete p;                break;            &#125;            index++;        &#125;    &#125;&#125;int ListNode::find(int val)&#123;    Node* p;    int index = 0;    for (p = this-&gt;head; p; p = p-&gt;next) &#123;        if (p-&gt;val == val) &#123;            return index;        &#125;        index++;    &#125;    return -1;&#125;void ListNode::print()&#123;    Node* p;    cout &lt;&lt; &quot;[&quot;;    for (p = this-&gt;head; p; p = p-&gt;next) &#123;        cout &lt;&lt; p-&gt;val;        if (p-&gt;next) &#123;            cout &lt;&lt; &quot;, &quot;;        &#125;    &#125;    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    ListNode* node = new ListNode;    node-&gt;assign(1);    node-&gt;assign(2);    node-&gt;assign(3);    node-&gt;assign(4);    node-&gt;assign(5);    node-&gt;print();    cout &lt;&lt; node-&gt;find(2) &lt;&lt; endl;    node-&gt;del(2);    node-&gt;print();    cout &lt;&lt; node-&gt;at(2) &lt;&lt; endl;    node-&gt;set(2, 9);    node-&gt;print();    return 0;&#125;\n\nMerge Two LinkedListNode *mergeList(ListNode *l1, ListNode *l2) &#123;    Node *p, *q, *temp, *newList;    if (l1-&gt;head-&gt;val &gt;        l2-&gt;head-&gt;val) &#123; // make ptr &quot;p&quot; is the head of small list        newList = l2-&gt;head;        p = l2-&gt;head;        q = l1-&gt;head;    &#125; else &#123;        newList = l1-&gt;head;        p = l1-&gt;head;        q = l2-&gt;head;    &#125;    while (p != nullptr &amp;&amp; q != nullptr) &#123;        if (q-&gt;val &gt;= p-&gt;val) &#123;            temp = q-&gt;next;            q-&gt;next = p-&gt;next;            p-&gt;next = q;            q = temp;            p = p-&gt;next-&gt;next;        &#125; else &#123;            temp = p-&gt;next;            p-&gt;next = q-&gt;next;            q-&gt;next = p;            p = temp;            q = q-&gt;next-&gt;next;        &#125;    &#125;    if (q != nullptr) &#123;        p-&gt;next = q;    &#125;    return newList;&#125;\n\n\n\n","categories":["递归这个世界 · 编程","数据结构"],"tags":["Programming","Data structure","Algorithm"]},{"title":"Network","url":"/2023/05/25/note/Computer/network/","content":"\n💻计算机网络基础知识。\n\n\n\n总体脉络一、物理层许多电脑想相互通讯，需要建立连接\n\n当只有两台电脑时，只需要一根网线，即可以通信（IO、中断、缓冲区、操作系统）\n两个、三个、四个……随着电脑数量增多，难以使任意两个都连接起来，否则网线密密麻麻混乱不堪\n使用一个中间设备，将所有电脑都与此设备相连，中间的转发全由这个设备完成，与之前本质上一样，只是网口与网线的数量减少了，不再那么混乱；设备名为集线器，仅仅将电信号转发到所有出口（广播），没有做任何处理，因此它属于物理层\n转发到了所有出口，每一个连接到集线器的设备都有一个全局唯一的名字作为标识，即 MAC 地址，此时发送数据只需要在数据包的头部拼接上 MAC 地址即可让接受者判断是否为发给自己的数据包\n\n\n\n\nMAC 地址\n端口\n\n\n\naa-aa-aa-aa-aa-aa\n1\n\n\nbb-bb-bb-bb-bb-bb\n2\n\n\ncc-cc-cc-cc-cc-cc\n3\n\n\ndd-dd-dd-dd-dd-dd\n4\n\n\n虽然这样布局干净很多，但是本来只需要发送给一个电脑的数据，现在要发给连接到集线器的所有电脑，这样既不安全又不节省网络资源\n二、数据链路层如果把集线器变得更加智能，只发送给目标 MAC 地址指向的那台电脑就好了\n\n使用交换机维护一张 MAC 地址表，记录着每个 MAC 地址的设备所在的端口，数据到达交换机会通过自动发送给其 MAC 地址所映射的端口上，这样的传输方式称为以太网\n通过发送和接受数据，交换机读取所有设备的 MAC 地址与端口并建立 MAC 地址表\n\n交换机 A：\n\n\n\nMAC 地址\n端口\n\n\n\naa-aa-aa-aa-aa-aa\n1\n\n\nbb-bb-bb-bb-bb-bb\n2\n\n\ncc-cc-cc-cc-cc-cc\n3\n\n\ndd-dd-dd-dd-dd-dd\n4\n\n\nee-ee-ee-ee-ee-ee\n5\n\n\nff-ff-ff-ff-ff-ff\n5\n\n\ngg-gg-gg-gg-gg-gg\n5\n\n\nhh-hh-hh-hh-hh-hh\n5\n\n\n 交换机 B：\n\n\n\nMAC 地址\n端口\n\n\n\naa-aa-aa-aa-aa-aa\n1\n\n\nbb-bb-bb-bb-bb-bb\n1\n\n\ncc-cc-cc-cc-cc-cc\n1\n\n\ndd-dd-dd-dd-dd-dd\n1\n\n\nee-ee-ee-ee-ee-ee\n2\n\n\nff-ff-ff-ff-ff-ff\n3\n\n\ngg-gg-gg-gg-gg-gg\n4\n\n\nhh-hh-hh-hh-hh-hh\n5\n\n\n\n机器数量越来越多，只需要将更多的交换机相连，每个交换机会有个别端口映射为别的交换机\n\n此时只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了\n但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万\n三、网络层交换机已经无法记录如此庞大的映射关系了\n问题在于交换机中映射到其他交换机的端口会有与这些端口数相同的 MAC 地址数，这会使 MAC 地址表无比庞大\n\n将很每一个交换机都接入一个新的设备，这个设备跟电脑一样拥有自己独立的 MAC 地址，同时还能把数据包做一次转发，我们称之为路由器\n\n\n路由器：一台独立的拥有 MAC 地址的设备，并且可以把数据包做一次转发\n\n\n路由器的每一个端口都有独立的 MAC 地址\n此时如果有两个电脑需要数据传输，如果同处于一个交换机下，则不需要通过路由器，如何判断是否需要通过路由器\nMAC 地址是出厂分配的，全球唯一，因此引入一个新的地址，每台机器分配一个 32 位（二进制）的编号，即 IP 地址；此时每台电脑既有自己的 MAC 地址又有自己的 IP 地址；IP 地址在软件层面上，可以随时修改，MAC 地址在硬件层面，不能修改\n此时在两台设备之间传输的信息就包含了两个头部，数据链路层头部和网络层头部\n两个 IP 处于同一个子网就直接通过交换机发送出去，不在同一个子网就交给路由器处理，192.168.0. xxx 开头一样的属于同一个子网；计算如何判断？答案是通过子网掩码：计算机通过将 IP 地址和子网掩码进行与运算\n\n\n如某机器的子网掩码为 255.255.255.0，四台电脑的 IP 地址：A 电脑：192.168.0.1 &amp; 225.225.225.0 &#x3D; 192.168.0.0B 电脑：192.168.0.2 &amp; 225.225.225.0 &#x3D; 192.168.0.0C 电脑：192.168.1.1 &amp; 225.225.225.0 &#x3D; 192.168.1.0D 电脑：192.168.1.2 &amp; 225.225.225.0 &#x3D; 192.168.1.0计算的结果相等，就属于同一个子网子网掩码其实是表示 IP 地址前多少位表示子网的网段\n\n\n当 A 想与 C 通信时，将 A 和 C 的 IP 地址分别与 A 的子网掩码进行 &amp; 运算，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发送给路由器\n\n但是 A 如何知道哪一个是路由器呢？\n\n对于 A 来说，它只能把包发送到同处于子网下的某一个 IP 上，所以只需要在 A 电脑内配置一个默认网关，也即路由器的 IP 地址路由器如何知道 C 在哪里？\n路由器收到包含 IP 地址的数据包，需要判断从哪个端口发送出去，由于子网掩码其实是表示 IP 地址前多少位表示子网的网段，因此可以把 IP 地址与子网掩码合并表示，如 192.168.0.0（255.255.255.0） 可以表示为 192.168.0.0/24（24 表示子网掩码占 24 个字节），路由器通过路由表判断将一个子网下的都转发到对应的端口发送数据包的数据链路层需要知道 MAC 地址，但是只知道 IP 地址怎么办？\n答案是 arp 协议；每个电脑都有一张 arp 缓存表，记录着 IP 地址与 MAC 地址的对应关系\n一开始 arp 缓存表是空的，每台电脑都会广播 arp 请求，收到的电脑会响应也即返回自己的 MAC 地址，此时电脑收到返回会更新自己的 arp 表\n\n综上，每台电脑都会有如下配置：\n\n\n\nIP 地址：\n192.168.0.1\n\n\n\nMAC 地址：\nAA-AA-AA-AA-AA-AA\n\n\n子网掩码：\n255.255.255.0\n\n\n默认网关：\n192.168.0.254\n\n\n一共涉及三张表：\n\n交换机中有 MAC 地址表用于映射 MAC 地址和它的端口\n路由器中有路由表用于映射 IP 地址与它的端口\n电脑和路由器中都有 arp 缓存表用于缓存 IP 和 MAC 地址的映射关系\n\n三张表的建立：\n\nMAC 地址是通过以太网内各节点之间不断通过交换机通讯而完善的\n路由表是各种路由算法+人工配制完善的\narp 缓存是不断通过 arp 协议的请求逐步完善的\n\n分视角分析电脑视角\n首先要知道自己的 IP 和对方的 IP\n通过子网掩码判断两者是否在同一个子网\n同一个子网就直接通过 arp 协议获取对方的 MAC 地址发送过去\n不在同一个子网则通过 arp 协议获取默认网关的 MAC 地址发送过去\n\n交换机视角\n收到的数据包必须有目标的 MAC 地址\n通过 MAC 地址查询映射关系\n查到就按照映射关系从指定端口发送出去\n查不到就所有端口都发送\n\n路由器视角\n\n收到的数据包必须包含目标的 IP 地址\n通过路由表查询映射关系\n查到了就按照映射关系从制定端口发送出去\n查不到则返回一个路由不可达的数据包\n\n\n网络层（IP 协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的\n\n四、传输层只需要获取对方的 IP 地址，数据包就可以在任意两台的电脑之间进行传输了，但是当一台电脑接收到一个数据包时，具体应该交给哪一个程序（进程） 呢？\n为了把通信的进程区分开来，就给每一个进程分配一个数字编号，也即端口号；然后在传输的数据包上要加上传输层的头部，即源端口号与目标端口号\n","categories":["经验与技巧与踩坑 · 杂项","计算机技术"],"tags":["Network","Protocol"]},{"title":"多线程基础","url":"/2023/05/25/note/Computer/thread/","content":"\n多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。\t\t\t——WIki-Pedia\n\n\n\n基本概念查看进程\nps -ef | grep &lt;name&gt;\n\n查看线程\nps -xH | grep &lt;name&gt;\n\n查看端口\nnetstat -ant | grep 8080\n\npthread_exit(0);//使用pthread_exit(0);或者return (void*)0;结束当前线程，而非return;// 使用exit(0)会结束当前进程（进程中所有的线程都会终止\n\n多线程参数传递可以使用强制类型转换：\nint i = -10;void *ptr = (void*)(long)i;int j = (int)(long)ptr; //此时j == i == -10\n\n线程资源的回收线程有两种状态，jonable和unjoinable，如果为前者，子线程主函数终止时（自己退出或pthread_exit(0)），资源不会被释放，这种线程称为僵尸线程。\n创建线程时，默认为joinable.\n资源回收有四种方法：\n\n在主线程中调用pthread_join(),但一般不用，因为会发生阻塞\n创建线程前，调用pthread_attr_setdetachstate设置属性\n\npthread_attr_t attr;pthread_attr_init(&amp;attr);pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);pthread_create(&amp;pthid, &amp;attr, mainFund, NULL);\n\n\n创建之后，设置为detached状态：pthread_detach(pthid);\n在线程主函数中调用pthread_detach：pthread_detach(pthread_self());\n\n可以使用pthread_join(pthid, (void**)&amp;i)来获取线程结束后的返回值。在线程主函数中使用return (void *) number来设置线程的返回值，可以告诉主线程子线程的情况。 \n线程的取消线程的取消：int pthread_cancel(pthread_t thread**);** 被取消的线程返回值为-1\n可以在子线程的主函数中使用函数设置是否可以被取消：\npthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);//orpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);//也可以保留旧的状态：int oldState;pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;oldState);//线程创建时默认为可以取消\n\n子线程中调用pthread_setcanceltype改变取消的方式：\npthread_testcancel(); // 设置取消点pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL); // 立即取消pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL); // 延时取消，延时到取消点再取消\n\n线程清理子线程退出时需要释放资源、锁和回滚事务等；\n善后的代码一般写在清理函数中，清理函数必须成对出现：\nvoid cleanfunc(void *arg) &#123;/*Do something*/&#125;//在子线程中pthread_cleanup_push(cleanfunc, NULL);pthread_cleanup_pop(1);\n\n线程的信号处理函数只能有一个，所有线程收到信号都会调用这一个。\n线程池C11封装了线程库thread.\n构造函数：\ntemplate&lt;typename _Callable , typename... _Args, typename  = _Require&lt;__not_same&lt;_Callable&gt;&gt;&gt; std::thread::thread (_Callable &amp;&amp; __f, _Args &amp;&amp;... __args) [inline],  [explicit]\n\n线程同步：多个线程协商如何合理的使用资源。\n递归互斥锁允许线程多次申请加锁，可以解决同一线程多次加锁造成的死锁的问题。\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","Thread"]},{"title":"Samsung玩机经验","url":"/2022/11/21/note/Experience/Samsung/","content":"三星玩机经验。\n\n\n注意事项\n卸载不需要的系统软件：刷完欧版系统，没有过多预装软件，可以不用卸载，不用的可以长按禁用\n\n三星解bl锁之前一定要退出账号\n刷完海外版固件，oem依然是解开的状态，但是有一个kg锁需要打开（prenormal是锁着的状态，checking是解开的状态），方式是进行系统更新检查，检查可能提醒无法进行更新，但无所谓，重启进入刷机模式就能看到已经解锁，此时可以刷magisk修补包了\nDex模式下使用谷歌输入法条件：已Root使用termux，输入命令：\nsudo ime set com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME\n更换主题更换主题，尤其是更换自定义图标时，最好先应用一下默认主题，在换上自己的主题，否则会存在一些自定义图标不生效的情况。\n","categories":["经验与技巧与踩坑 · 杂项","Android"],"tags":["Mobile phone","root","ROM"]},{"title":"Android上使用硬件加速运行OpenGL程序","url":"/2024/08/09/note/Experience/android-opengl/","content":"Proot-distro(Debian)+termux-x11. \n已弃坑，性能损失依然太大，且平板内存不够。\n\n\n安装Termux和Termux-x11.更新源：\n如果想要手动更换 Termux APT 源的话，可以编辑 /data/data/com.termux/files/usr/etc/apt/sources.list 为如下内容\nnano /data/data/com.termux/files/usr/etc/apt/sources.list# 编辑为如下deb https://mirrors.ustc.edu.cn/termux/apt/termux-main stable main\n\n或者，你也可以使用 sed 命令进行文本替换：\nsed -i &#x27;s@packages.termux.org@mirrors.ustc.edu.cn/termux@&#x27; $PREFIX/etc/apt/sources.listpkg up\n\n注：Termux 会自动将环境变量 $PREFIX 设定为 /data/data/com.termux/files/usr。\npkg up\n\n安装proot-distropkg in proot-distroproot-distro install debianproot-distro login debianpasswd rootnano /etc/apt/sources.list# 默认注释了源码仓库，如有需要可自行取消注释deb http://mirrors.ustc.edu.cn/debian bookworm main contrib non-free non-free-firmware# deb-src http://mirrors.ustc.edu.cn/debian bookworm main contrib non-free non-free-firmwaredeb http://mirrors.ustc.edu.cn/debian bookworm-updates main contrib non-free non-free-firmware# deb-src http://mirrors.ustc.edu.cn/debian bookworm-updates main contrib non-free non-free-firmware# backports 软件源，请按需启用# deb http://mirrors.ustc.edu.cn/debian bookworm-backports main contrib non-free non-free-firmware# deb-src http://mirrors.ustc.edu.cn/debian bookworm-backports main contrib non-free non-free-firmwareapt update &amp;&amp; apt upgrade# 添加用户等apt install sudouseradd -m -s /bin/bash usernamepasswd username...\n\n退出debian，安装包含Zink的virglrenderer。\npkg install tur-repopkg update -y &amp;&amp; pkg upgrade -ypkg install mesa-zink virglrenderer-mesa-zink vulkan-loader-android\n\n使用\n打开Termux，执行：\n\nMESA_LOADER_DRIVER_OVERRIDE=zink GALLIUM_DRIVER=zink ZINK_DESCRIPTORS=lazy virgl_test_server --use-egl-surfaceless --use-gles &amp;\n\n\n打开Termux-x11，回到Termux，执行\n\nexport DISPLAY=:0termux-x11 :0 &amp;\n\n\n打开新session（可以在.termux&#x2F;termux.properties中设置快捷键），以普通账户登录proot，加上共享tmp的参数：\n\nproot-distro login debian --user user --shared-tmp\n\n\n启动软件或桌面环境\n\n软件：\nexport DISPLAY=:0GALLIUM_DRIVER=virpipe MESA_GL_VERSION_OVERRIDE=4.0 glmark2# 如果程序要求OpenGL版本为4.5GALLIUM_DRIVER=virpipe MESA_GL_VERSION_OVERRIDE=4.5 glmark2# 或GALLIUM_DRIVER=llvmpipe MESA_GL_VERSION_OVERRIDE=4.5 glmark2\n\n桌面环境xfce4：\nexport DISPLAY=:0dbus-launch --exit-with-session startxfce4 &amp;\n\n","categories":["经验与技巧与踩坑 · 杂项","Android"],"tags":["Linux","Android","OpenGL"]},{"title":"glfw 与 windows 的宏定义冲突 APIENTRY","url":"/2025/06/19/note/Experience/apientry/","content":"C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.26100.0\\shared\\minwindef.h(130): warning C4005: “APIENTRY”: 宏重定义\n\n\nAPIENTRY使用GLFW库时总是遇到这个问题，编译时警告宏重定义，遇到多次了，比较容易处理。\n本质上是因为GLFW的glfw3.h与minwindef.h（被Windows.h包含）中都定义了APIENTRY宏：\nGLFW：\n\nWindows：\n不同点在于，GLFW中进行了保护，如果之前已有定义，就不再处理，而windows头文件中没有处理，因此，解决这个问题，要么将Windows.h放到glfw3.h之前，要么在包含Windows.h之前取消APIENTRY的定义。\n但当我把项目中所有的glfw3.h和Windows.h都找出来且调整了顺序之后，警告依然存在。\n最后才发现，原来忘记了，我在预编译头文件中包含了Windows.h，而在其他文件中包含预编译头时没有注意顺序，或者即使注意了顺序，也被clang-format格式化了。\n格式化clang-format可以把代码变得整齐有序，且拥有很强大的风格定制能力。\n我只需要保证在包含头文件时，预编译头在最前面即可：（不，还是主头文件放在最前吧）\n# 允许排序#includeSortIncludes: true# Include 分组方式: Preserve, Merge, RegroupIncludeBlocks: Regroup# Include 分类规则 (数字越小优先级越高)IncludeCategories:  # 0. 预编译头文件 - 最高优先级  - Regex: &#x27;^&quot;PreCompiled\\.h&quot;$&#x27;    Priority: 1    SortPriority: 1  # 1. Windows 系统头文件  - Regex: &#x27;^&lt;[Ww]indows\\.h&gt;$&#x27;    Priority: 2    SortPriority: 2  # 2. GLEW 头文件  - Regex: &#x27;^&lt;GL/glew\\.h&gt;$&#x27;    Priority: 3    SortPriority: 3  # 3. GLFW 头文件    - Regex: &#x27;^&lt;GLFW/.*\\.h&gt;$&#x27;    Priority: 4     SortPriority: 4  # 4. 其他系统/标准库头文件  - Regex: &#x27;^&lt;.*\\.h&gt;$&#x27;    Priority: 5    SortPriority: 5  - Regex: &#x27;^&lt;.*&gt;$&#x27;    Priority: 6    SortPriority: 6  # 6. 其他项目头文件  - Regex: &#x27;^&quot;.*&quot;$&#x27;    Priority: 7    SortPriority: 7    # 主头文件识别正则表达式IncludeIsMainRegex: &#x27;(Test)?$&#x27;\n\n这样重新格式化所有代码，问题自然而然解决了。\n","categories":["经验与技巧与踩坑 · 杂项","cpp"],"tags":["Windows","GLFW"]},{"title":"在Windows的硬盘上创建liveCD引导启动linux安装","url":"/2023/08/18/note/Experience/livecd-on-disk/","content":"装完Archlinux发现忘记安装iwd和dhcpcd了，无法联网，又没有额外的U盘制作liveCD，因此开辟出一块硬盘分区来引导临时系统。\n\n\n步骤\n首先下载EasyUEFI，网上随便下都行。\n\n然后下载系统镜像：archlinux-2023.08.01-x86_64.iso。\n\n使用Windows自带的磁盘管理工具或DiskGenius分出一块空闲的分区，大小最好在5G以上（最小多少我也没有试），然后格式化成FAT32的格式。将镜像文件archlinux-2023.08.01-x86_64.iso解压到这个分区中。\n\n打开EasyUEFI，选择管理EFI启动项：\n\n\n\n然后创建新项：\n描述是启动项的名字，随便写一个能分辨的即可。\n\n文件路径要找到刚刚解压到新分区的efi文件，不同的发行版可能有所不同，一般名字为grub.efi或BOOT64.efi，路径基本上都是/EFI/BOOT/*.efi：\n\n\n\n然后就可以重启电脑，选择启动项了。\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","UEFI","liveCD"]},{"title":"Qt相关问题杂项","url":"/2023/10/20/note/Experience/qt-questions/","content":"使用在线安装器换源以加快下载速度。\n\n参考清华大学镜像站 - Qt 软件仓库镜像使用帮助。\n\n\n\n以下内容为复制上述链接中的内容。\n\n通过以下链接下载在线安装器\nhttps://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/\n\n通过\n# linuxinstaller --mirror https://mirrors.tuna.tsinghua.edu.cn/qt# windowsinstaller.exe --mirror https://mirrors.tuna.tsinghua.edu.cn/qt\n\n使用该镜像。\nQt在Windows下配置环境变量\nPATH：在环境变量（PATH）中添加Qt安装目录中的编译器bin文件夹，如D:\\Libraries\\Qt\\5.15.2\\msvc2019_64\\bin\nQTDIR：添加一个环境变量，名字为QTDIR，文件夹为Qt安装目录的某一个版本的文件夹，如D:\\Libraries\\Qt\\5.15.2\n\nxmake创建qt应用xmake create -t qt.widgetapp myapp -P .\n\n","categories":["经验与技巧与踩坑 · 杂项","cpp"],"tags":["Qt","cpp","Source"]},{"title":"Linux下建立RTMP推流服务器","url":"/2023/07/30/note/Experience/rtmp/","content":"在各大直播平台直播电视剧或电影，大概率会因版权问题被封掉，即使并没有其他人看。因此想要搭建一个私人的直播间。\n\n\n安装Docker如Archlinux：\nsudo pacman -S docker\n\n启动sudo systemctl enable --now dockersudo systemctl status docker #查看运行状态\n\n使用现有镜像tiangolo&#x2F;nginx-rtmpsudo docker pull tiangolo/nginx-rtmp# 下载完成之后sudo docker run -d -p 1935:1935 --name nginx-rtmp tiangolo/nginx-rtmp\n\nOBS注意，OBS似乎只能在X11下运行。如果使用Wayland,请切换到X11。\nsudo pacman -S obs\n\n推流地址为rtmp://&lt;ip&gt;/live/&lt;passwd&gt;。\n如果有防火墙，打开1935端口。\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","OBS","RTMP"]},{"title":"搭建Shadowsocks服务器代理","url":"/2024/03/30/note/Experience/shadowsocks/","content":"使用机场不太稳定，买到便宜货网速也很慢，不如买个海外服务器手动搭建代理。\n\n\n前提需要一个海外服务器。\n如果需要用到ChatGPT等，服务器最好在美国西海岸，如旧金山。\n推荐使用Digitalocean，付费方案为4&#x2F;6&#x2F;8$每月，看视频和网页完全足够。\n系统最好安装ubuntu20.04。\n安装部署按照官方文档：\n$ python --versionPython 2.7.18\n\n然后安装shadowsocks：\npip install shadowsocks\n\n然后创建config.json（在任何路径都可以，只要能找到），内容为：\n&#123;        &quot;server&quot;:&quot;your_ip&quot;,        &quot;server-port&quot;:8388,        &quot;local-port&quot;:1080,        &quot;password&quot;:&quot;barfoo!&quot;,        &quot;method&quot;:&quot;aes-256-gcm&quot;&#125;\n\n然后开启服务：\nssserver -c ./config.json\n\n\n这里有可能报错2024-03-30 12:58:52 ERROR    method aes-256-gcm not supported\n\n解决方法可以使用以下方法解决：\nshadowsocks解决method aes-256-gcm not supported方法\n即安装最新版本的shadowsocks同时安装libsodium依赖。\npip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -Usudo apt-get install -y libsodium*\n\n更多使用方法后台运行\nsudo ssserver -c ./config.json --user nobody -d start\n\n停止\nsudo ssserver -d stop\n\n检查日志\nsudo less /var/log/shadowsocks.log\n\n客户端下载shadowsocks客户端（对应平台），如windows版本：\n\n\n填写config对应的项，开启代理即可：\n\n可能的报错AttributeError: &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup\n这是因为openssl 1.1.0版本废除了EVP_CIPHER_CTX_cleanup函数，使用EVP_CIPHER_CTX_reset函数代替。\n解决方案：修改/usr/local/lib/python3.8/dist-packages/shadowsocks/crypto/openssl.py，将其中的所有EVP_CIPHER_CTX_cleanup函数修改为EVP_CIPHER_CTX_reset。\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Shadowsocks","VPN"]},{"title":"笔记本电脑与安卓平板共享键鼠完美方案","url":"/2023/06/07/note/Experience/share_input_on_win_and_android/","content":"\n\n日常办公使用笔记本电脑，但也想把另一个平板电脑（Android）利用起来，最初是想把它当作扩展屏，但有一些安卓软件相当不错（纯纯写作，哔哩哔哩，还有更高清的屏幕等)，于是想同时使用，但是没有键鼠，笔记本电脑的键鼠和平板电脑的触控相互切换，太麻烦，经过一下午的努力终于找到完美的解决方案。\n注：本方案需要花费30人民币购买软件，如不考虑请移步。\n\n\n设备：Windows PC 、Andriod pad、Android mobile phone\n软件：\n\n\n\n平台\n软件\n\n\n\nWindows\nDeskDockServer\n\n\nAndroid pad\nDeskDockPro（720日元 ≈ 30 人民币）\n\n\nAndroid mobile phone\nBluetooth Keyboard &amp; Mouse\n\n\nPC 端 DeskDockServer按照自己的平台（操作系统和cpu架构）下载相应的软件\n\n安装jre\n这里选择java8Java Downloads | Oracle，下载完成后安装即可\n\n下载DeskDock Server，解压后直接可以运行\n\n\n配置如下，切换快捷键看个人习惯，其他也根据自己的需求配置：\n\nAndroid Pad 端google商店搜索DeskDockPro，或点此链接DeskDock PRO下载并安装（需要付费￥30）。\n之所以不用DeskDock免费版是因为它只提供共享鼠标，而不能使用键盘。\n连接软件安装完之后使用USB连接pad与PC即可享用共享鼠标和键盘，也即使用笔记本的鼠标键盘控制平板。\n但到此为止输入法只能使用PC端的，在PC打完字发送到平板，或使用平板的输入法（一定会拉起软键盘），像这样：\n\n安卓的机制是连接外接实体键盘后才会收起软键盘，继而根据各个输入法提供更简洁的视觉效果，但使用笔记本的键盘并不会被识别出实体键盘，如果接上实体键盘一切都不成问题，但都有实体键盘了还要笔记本的键盘干什么，于是摸索中发现手机端有一款软件可以模拟实体键盘和鼠标作为蓝牙外设，它就是Bluetooth Keyboard &amp; Mouse，play商店搜索下载即可，免费版完全够用，因为只是需要它作为一个外设键盘被识别。\n在手机端安装好后蓝牙连接pad，设置输入法为gboard，关闭显示屏幕键盘，即可享用：\n\n需要注意的问题在上图里了。\n","categories":["经验与技巧与踩坑 · 杂项","Android"],"tags":["Mobile phone","Android","Shared mouse"]},{"title":"VSCode - argument of type \"const char *\" is incompatible with parameter of type \"LPCWSTR\" 错误的解决方法","url":"/2023/07/03/note/Experience/unicode-error/","content":"主要原因是字符集的问题，不使用unicode字符集即可。\n在VSCode中，删除c_cpp_properties.json中的宏UNICODE和_UNICODE。\n\n\n&quot;defines&quot;: [\t&quot;_DEBUG&quot;,\t&quot;UNICODE&quot;,\t&quot;_UNICODE&quot;],\n\n之后：\n&quot;defines&quot;: [    &quot;_DEBUG&quot;],\n\n","categories":["经验与技巧与踩坑 · 杂项","cpp"],"tags":["CPP","Win32","VSCode"]},{"title":"使用Waydroid在Linux上运行x86_64的安卓软件","url":"/2023/07/04/note/Experience/waydroid/","content":"Windows有WSA，Linux有Waydroid，两者的性能损失之小都相当可观。\n虽然两者目前都不够成熟，有许多需要改进之处，但还是非常好用的。\n环境\n\n$ uname -aLinux dionysen-latitude7430 6.1.31-2-MANJARO #1 SMP PREEMPT_DYNAMIC Sun Jun  4 12:31:46 UTC 2023 x86_64 GNU/Linux\n\n\n\n安装waydroidyay -S waydroid\n\n下载镜像，一般使用LineageOS，在[此处](https://sourceforge.net/projects/waydroid/)下载两个文件：\n\nsystem.zip和vendor.zip。\n下载完成后将.img文件解压到/usr/share/waydroid-extra/images目录下，文件夹若不存在则创建。\nsudo waydroid initsudo systemctl enable --now waydroid-container\n\n此时应该可以正常使用了。\n常用命令确保 waydroid-container.service 正在运行，然后执行：\nwaydroid session start\n\nWaydroid 会话现在已处于活动状态，这里有一些与 Waydroid 交互的实用命令：\n启动 GUI：\nwaydroid show-full-ui\n\n启动 shell：\nwaydroid shell\n\n安装应用程序：\nwaydroid app install $path_to_apk\n\n运行应用程序：\nwaydroid app launch $package-name #Can be retrieved with `waydroid app list`\n\n\n\n\n注意，安装的安卓应用可能会显示在linux系统的应用中，但最好不要直接点击它来启动应用，而是使用命令行：\n➜  ~ sudo systemctl status waydroid-container● waydroid-container.service - Waydroid Container     Loaded: loaded (/usr/lib/systemd/system/waydroid-container.service; enable&gt;     Active: active (running) since Wed 2023-07-05 01:02:16 CST; 3min 56s ago   Main PID: 574 (python3)      Tasks: 2 (limit: 9204)     Memory: 35.9M        CPU: 229ms     CGroup: /system.slice/waydroid-container.service             └─574 python3 /usr/bin/waydroid -w container start7月 05 01:02:15 dionysen-latitude7430 systemd[1]: Starting Waydroid Container...7月 05 01:02:16 dionysen-latitude7430 systemd[1]: Started Waydroid Container.# 确保服务正在运行waydroid session start# 然后再去点击Waydroid的应用图标\n\n另：由于系统对应的架构是x86_64，因此最好去一些网站下载此架构的应用，如appmirror（需梯子）。\nSetting up a shared folderUser @wachidadinugroho has worked out the details on how to setup a shared folder to be used between Waydroid and your host filesystem. \nSetting up a shared folder will allow the user to copy&#x2F;paste files from the host and they appear inside waydroid&#x2F;android.  sudo mount --bind &lt;source&gt; ~/.local/share/waydroid/data/media/0/&lt;target&gt;\nThen verify that the target folder exists: \n sudo ls ~/.local/share/waydroid/data/media/0/ Examples:\nsudo mount --bind ~/Documents ~/.local/share/waydroid/data/media/0/Documentssudo mount --bind ~/Downloads ~/.local/share/waydroid/data/media/0/Downloadsudo mount --bind ~/Music ~/.local/share/waydroid/data/media/0/Musicsudo mount --bind ~/Pictures ~/.local/share/waydroid/data/media/0/Pictures sudo mount --bind ~/Videos ~/.local/share/waydroid/data/media/0/Movies\n\nYou can also make your own custom mount point to cater to your needs.\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Android","Waydroid","Wayland"]},{"title":"Qt","url":"/2023/05/25/note/Framework/Qt/","content":"\n\nQt 经常被当做一个 GUI 库，用来开发图形界面应用程序，但这并不是 Qt 的全部；Qt 除了可以绘制漂亮的界面（包括控件、布局、交互)，还包含很多其它功能，比如多线程、访问数据库、图像处理、音频视频处理、网络通信、文件操作等。\n\n\n信号与槽连接一个信号和槽函数，它们分别来自不同（也可以是相同）的对象，也即connect是对象之间快速通信的桥梁。\n#include &lt;QtGui/QApplication&gt; #include &lt;QtGui/QPushButton&gt; int main(int argc, char *argv[]) &#123;         QApplication a(argc, argv);         QPushButton *button = new QPushButton(&quot;Quit&quot;);         QObject::connect(button, SIGNAL(clicked()), &amp;a, SLOT(quit()));         button-&gt;show();         return a.exec(); &#125;\n\nQObject::connect(button, SIGNAL(clicked()), &amp;a, SLOT(quit())); //连接button对象的clicked事件函数与程序a的quit函数 \n\n事件可以通过事件来改变组件的默认操作\nQApplication的exec()就是事件循环，用来监听所有事件；当事件发生时，Qt将创建一个事件对象，然后传递给event()。\n事件函数需要在子类中重写。重写事件函数其实就是在告诉系统，当遇到这个事件的时候应该做什么。\npaintEvent()在程序开始的时候会update()一次，后面绘制图形需要再调用update()。\n绘画事件通过绘画事件函数void paintEvent(QPaintEvetn *event)画图，可以通过设置状态来控制画什么。\nupdate()函数用来更新绘画事件函数。\n普通绘画：\npaint.setPen(QPen(QColor(Qt::black), 1)); // 画轮廓paint.setBrush(Qt::black); //填充paint.drawEllipse(100,100,300,300); // 参数为位置x,y，圆所占矩形的长和宽\n\n绘制透明填充：\nQColor color = Qt::white;color.setAlphaF(0.5); // 透明度设置为0.5paint.setPen(QPen(color));paint.setBrush(color);paint.drawEllipse(100,100,300,300);\n\n鼠标事件鼠标悬浮事件可以使用QWidget的参数setMouseTracking完成，但必须在所有上层控件中都设置setMouseTracking(true)才可以实现；比如QMainWindow类的监控必须同时在MainWindow和其父类QWidget中都设置setMouseTracking(true)。\n然后重写mouseMoveEvent函数。使用event-&gt;HoverMove判断事件类型。\n消息对话框可选按键的消息对话框可直接使用静态函数实现有可选按钮的消息对话框：\nQMessageBox mb;    mb.setWindowTitle(tr(&quot;Black is Win!&quot;));    mb.setText(tr(&quot;Black is win!&quot;));    mb.setInformativeText(tr(&quot;Are you want to play again?&quot;));    mb.setStandardButtons(QMessageBox::Yes | QMessageBox::No | QMessageBox::Default);    mb.setDefaultButton(QMessageBox::Yes);    switch (mb.exec()) &#123;    case QMessageBox::Yes:    \tnewGame();    \tbreak;    case QMessageBox::No:    \texit();    \tbreak;    default:    \tbreak;&#125;\n\nor\nQMessageBox::StandardButton defaultBtn = QMessageBox::NoButton;QMessageBox::StandardButton result; // 返回选择的按钮result = QMessageBox::question(    this, &quot;Black is Win!&quot;, &quot;Game over! Are you want to play again?&quot;,QMessageBox::Yes | QMessageBox::No, defaultBtn);if (result == QMessageBox::Yes)     ui-&gt;plainTextEdit-&gt;appendPlainText(&quot;Question消息框: Yes 被选择&quot;);else if (result == QMessageBox::No)     ui-&gt;plainTextEdit-&gt;appendPlainText(&quot;Question消息框: No 被选择&quot;);else     ui-&gt;plainTextEdit-&gt;appendPlainText(&quot;Question消息框: 无选择&quot;);\n\nor\nQMessageBox::information(    this, &quot;Black is Win!&quot;, &quot;Game over! Are you want to play again?&quot;);\n\n控件设置QLabel *l = new QLabel(this);// 创建labelQFont font;font.setFamily(&quot;Times New Roman&quot;);font.setPixelSize(20);l-&gt;setFont(font); // 设置字体 QString s = QString::number(whiteTime);l-&gt;setText(s + &quot;s&quot;); // 设置显示的内容QPalette palette;palette.setColor(QPalette::Window, QColor(0, 0, 0));palette.setColor(QPalette::WindowText, Qt::white);l-&gt;setPalette(palette); // 设置样式l-&gt;show(); // 显示label\n\n使用l-&gt;update()可以更新控件显示的内容。\nQPaletteQPalette::Window(); // 是指背景色QPalette::WindowText();// 指的是前景色等。QPalette::setColor();//函数对某个主题的颜色及状态进行设置。QPalette::setBrush();//函数对显示进行更改，这样就有可能使用图片而不仅仅是单一的颜色来对主题进行填充了。QPalette::setColor(ColorRole r,const Qcolor &amp;c);//对某个主题颜色进行设置，并不区分状态QPalette::setColor(ColorGroup gr,ColorRole r,const QColor &amp;c);//对主题颜色进行设置的同时还区分了状态。xxx-&gt;setAutoFillBackground(true);//可以提取某个控件的调色板Qpalette p=xxx-&gt;palette();p.setColor(QPalette::Window,color);//p.setBrush(QPalette::Window,brush);xxx-&gt;setPalette(p);\n\n定时器QTimer *t = new QTimer(this);t-&gt;start(1000); //设置事件间隔为1000ms,这样每过一秒就会调用timeout()函数connect(t, SIGNAL(timeout()), this, SLOT(time())); // 将timeout()函数作为信号与自定义槽函数time()连接起来，就可以实现一些功能\n\n字体xxx-&gt;setFont(QFont(&quot;宋体&quot;,20,QFont::Bold)); // 使用构造函数可以轻松改变字体的样式，这也同样应用于其他类型QFont font;//设置文字字体font.setFamily(&quot;宋体&quot;);//设置文字大小为50像素font.setPixelSize(50);//设置文字为粗体font.setBold(true); //封装的setWeight函数//设置文字为斜体font.setItalic(true); //封装的setStyle函数//设置文字大小font.setPointSize(20);//设置文字倾斜font.setStyle(QFont::StyleItalic);//设置文字粗细//enum Weight 存在5个值font.setWeight(QFont::Light);//设置文字上划线font.setOverline(true);//设置文字下划线font.setUnderline(true);//设置文字中划线font.setStrikeOut(true);//设置字间距font.setLetterSpacing(QFont::PercentageSpacing,300);//300%,100为默认//设置字间距像素值font.setLetterSpacing(QFont::AbsoluteSpacing,20);//设置字间距为100像素//设置首个字母大写（跟参数有关，也可以设置全部大写AllUppercase）font.setCapitalization(QFont::Capitalize);//通过QFontMetrics获取字体的值QFontMetrics fm(font);qDebug() &lt;&lt; fm.height(); //获取文字高度qDebug() &lt;&lt; fm.maxWidth();//获取文字宽度//通过QFontInfo获取也能获取字体信息QFontInfo fInfo(font);qDebug() &lt;&lt; fInfo.family() &lt;&lt;&quot;  &quot;&lt;&lt;fInfo.style() &lt;&lt; fInfo.pixelSize() &lt;&lt; fInfo.overline();//设可以单独置QPlainTextEdit字体//ui-&gt;plainTextEdit-&gt;setFont(font);//将当前设置的字体设置为默认字体qApp-&gt;setFont(font);\n\nQLabel 显示富文本QString lineHeightStr = &quot;&lt;p style=&#x27;line-height:%1px&#x27;&gt;%2&lt;/p&gt;&quot;;QString fontColorStr = &quot;&lt;font color = #959595&gt;%1&lt;/font&gt;&lt;font color = #000000&gt;%2&lt;/font&gt;&quot;;QString textStr = lineHeightStr.arg(scaleConver(30)).arg(fontColorStr.arg(&quot;您于14天内到达或途经：&quot;,&quot;浙江省杭州市，河南省许昌市，广州省广州市，辽宁省大连市&quot;));ui-&gt;label_city-&gt;setText(textStr);label-&gt;setText(    QObject::tr(&quot;&lt;font color = red&gt;%1&lt;/font&gt;&quot;).arg(&quot;abc&quot;))+    QObject::tr(&quot;&lt;font color = blue&gt;%1&lt;/font&gt;&quot;).arg(&quot;efg&quot;)+    &quot;hij&quot;    );//或者这样：QSize nSize(300,25);m_pStatic = new QLabel((QWidget*)GetUIWnd());m_pStatic-&gt;resize(nSize);QString strText = QString::fromStdWString(_CS(L&quot;&lt;font style = &#x27;font-size:14px; font-weight:bold&#x27;&gt;You Can See it from this: &lt;/font&gt; &lt;font style = &#x27;color:#2C5DFF; font-size:14px; font-weight:bold&#x27;&gt; %1 &lt;/font&gt; &lt;font style = &#x27;font-size:14px; font-weight:bold&#x27;&gt;example.&lt;/font&gt;&quot;)).arg(0);m_pStatic-&gt;setText(strText);\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","Qt","Graphic"]},{"title":"Vue3学习笔记","url":"/2023/07/18/note/Framework/vue3/","content":"工作需要学习了前端框架Vue，这是过程中遇到的问题和解决方法的汇总。\n\n\n组合式API引用canvasconst canvas = ref&lt;HTMLCanvasElement | null&gt;(null);const context = ref&lt;CanvasRenderingContext2D | null&gt;();\n\nComposition API 是 Vue 3 中引入的一组函数式 API，用于替代 Vue 2 中的 Options API。它提供了更灵活、可组合和可重用的方式来组织组件的逻辑代码。\n在 Vue 3 的 Composition API 中，我们可以使用 ref 函数来创建一个响应式的引用，它类似于 Vue 2 中的 data 选项。ref 接受一个初始值作为参数，并返回一个包含该值的响应式引用。\n在上述代码中，const canvas = ref&lt;HTMLCanvasElement | null&gt;(null) 表示创建了一个名为 canvas 的响应式引用，它的类型为 HTMLCanvasElement | null。HTMLCanvasElement 表示 Canvas 元素的类型，| 表示联合类型，允许 canvas 的值为 HTMLCanvasElement 或 null。在初始化时，canvas 的值被设置为 null。\n这样的设置可以让我们在 Vue 3 中使用 Composition API 来追踪和操作 Canvas 元素及其上下文。通过 canvas.value 和 context.value 可以访问引用的实际值，因为 ref 创建的引用是一个包装器。\n通过使用响应式引用，我们可以在应用程序中追踪和修改 canvas 和 context 的值，确保任何对它们的更改都能在 Vue 组件中得到反应，并触发相应的更新。\nCanvas接口HTMLCanvasElement：Provides properties and methods for manipulating the layout and presentation of elements. The HTMLCanvasElement interface also inherits the properties and methods of the HTMLElement interface.\nCanvasRenderingContext2D：The CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context for the drawing surface of a element. It is used for drawing shapes, text, images, and other objects.\n可选链操作符context.value?.stroke()\n\n?.是可选链操作符，它用于检查context.value是否为非空值。如果context.value不为null或undefined，则调用stroke()方法。\ncanvas绘制网格function drawCanvasGrid() &#123;  const gridSize = 50;  if (context.value) &#123;    context.value.fillStyle = &quot;rgba(0, 0, 0, .2)&quot;;    for (let i = 0; i * gridSize &lt; canvas.value?.width! - 40; i++) &#123;      for (var j = 0; j * gridSize &lt; canvas.value?.height! - 40; j++) &#123;        if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;          context.value.beginPath();          context.value.rect(i * gridSize, j * gridSize, 2, 2);          context.value.fill();          context.value.closePath();        &#125;      &#125;    &#125;  &#125;&#125;\n\n\nbeginPath(): 这个方法用于创建一个新的路径或者子路径。在绘制之前，调用beginPath()可以清除之前定义的路径，以确保开始一个新的路径。\nrect(x, y, width, height): 这个方法用于在路径中添加一个矩形子路径。它接受四个参数，分别是矩形左上角的x坐标、y坐标，以及矩形的宽度和高度。调用rect()方法并不会直接绘制矩形，而是将矩形添加到当前的路径中。\nfill(): 这个方法用于填充当前路径的内容，使其呈现实心的效果。填充的颜色由fillStyle属性指定。\nclosePath(): 这个方法用于关闭当前的子路径。它会连接当前路径的起点和终点，形成一个封闭的路径。调用closePath()后，绘制的操作会回到起点，可以开始绘制下一个子路径。\n\n在给定的代码片段中，这几个函数被用于在画布上绘制一个网格。通过循环遍历，每个格子都被绘制成一个大小为2x2的矩形，并使用fill()方法填充矩形的内容。beginPath()和closePath()方法则用于定义每个格子的子路径，以及在绘制完成后关闭路径。\nclearRect(x, y, width, height)\n\n在CanvasRenderingContext2D接口中，clearRect(x, y, width, height)方法用于清除指定矩形区域内的像素。它接受四个参数，分别是矩形左上角的x坐标、y坐标，以及矩形的宽度和高度。调用clearRect()方法会将指定矩形区域内的像素设为透明，从而清除该区域的内容。\nPinia订阅store.$subscribe((_, state) =&gt; &#123;  if (state.shouldClear) &#123;    clearCanvas();  &#125;&#125;);\n\n使用$subscribe方法，实时监听状态的变化，当状态发生变化时，执行函数中的语句。\n","categories":["递归这个世界 · 编程","框架"],"tags":["Vue","Javascript","Typescript"]},{"title":"Hexo 使用 keep 主题及美化","url":"/2023/06/01/note/Hexo/Hexo-keep/","content":"最初是寻找一个干净清爽的hexo主题，逛了许久终于发现这款，虽然第一眼并没有很喜欢，但干净的界面，齐全的功能，我决定自己把它修改成想要的样式。\n\n\nhexo的安装和配置请移步：Hexo 个人博客搭建 | DIONYSEN BLOG\n基础配置官方文档讲得很清楚：安装主题 | Keep 主题使用指南 (xpoet.cn)\n安装hexo，创建自己的项目，并设置主题为keep。\n界面美化代码高亮\nKeep 主题追求的是简约轻快，在最大程度上降低用户对界面美感的选择困难，使其专注写作的内容，作者认为这两种代码高亮主题能满足绝大部分的使用场景。后续版本迭代基本上不会有新的代码高亮主题出现，望周知。\n\n尽管只有两种代码高亮主题，还是可能会出现一些非预期的错误，比如代码块无法高亮显示代码，可以尝试用以下方式解决：\nnpm uninstall hexo-prism-plugin # 卸载prism-plugin\n\n编辑博客根目录下的_config.yml文件：\nhighlight:  enable: true  auto_detect: false  line_number: false  line_threshold: 0  tab_replace:  exclude_languages:    - example  wrap: true  hljs: falseprismjs:  enable: false  preprocess: true  line_number: true  line_threshold: 0  tab_replace: &#x27;&#x27;\n\n即可使用keep主题的代码高亮方案。\n块阴影个人审美觉得主题阴影太深，修改阴影大小和边框颜色，编辑Blog/theme/keep/source/css/common/keep-theme.styl：\n$keep-container-border-radius = 0.1remhover-style(isTransform, scaleX, scaleY) &#123;  // box-shadow 2px 2px 5px var(--shadow-color)  // box-shadow 0px 0.5px 2px var(--shadow-color) 原阴影样式  border 1px solid var(--item-border-color) // 边框样式  if (isTransform) &#123;    transition-t(&quot;transform&quot;, &quot;0&quot;, &quot;0.2&quot;, &quot;linear&quot;)  &#125;  &amp;:hover &#123;    if (hexo-config(&#x27;style.hover.scale&#x27;) &amp;&amp; isTransform) &#123;      transform scaleX(scaleX) scaleY(scaleX)    &#125;    if (hexo-config(&#x27;style.hover.shadow&#x27;)) &#123; // 鼠标悬浮样式      // box-shadow 1px 2px 4px var(--shadow-hover-color)      box-shadow 0px 0.5px 2px var(--shadow-color)    &#125;  &#125;&#125;\n\n\n如果想要更加沉浸式的阴影，可以去掉边框，加上四周阴影：\n\n// 1. 注释掉边框// border 1px solid var(--item-border-color) // 边框样式// 2. 添加四周阴影：box-shadow black 0.1px 0.1px 4px;//将h-shadow,v-shadow设为0px,实现四周阴影\n\n效果如图：\n\n主页描述原主题主页最多有两句话，且样式相同，没有层次感，可以修改Blog/themes/keep/layout/_partial/first-screen.ejs文件：\n&lt;div class=&quot;description hitokoto&quot;&gt;    Sincere and Fearless    &lt;!-- 此处插入第一行字 --&gt;                &lt;% for (const idx in final_description) &#123; %&gt;    \t&lt;div class=&quot;desc-item&quot;&gt;&lt;%= final_description[idx] %&gt;&lt;/div&gt;    &lt;% &#125; %&gt;&lt;/div&gt;\n\n主题目录下的_config.yml\ndescription: It is this intellectual activity …… # 此为第二行字\n\n效果如图：\n\n字体修改个性化的字体需要自定义字体样式，加载云端字体或本地字体，汉字不像英文，一般体积都很大，十几二十兆都很有可能，如果直接加载，会大大拖慢网页加载速度，可以通过压缩的方式减小字体大小。压缩中文字体的原理是删除一些不常用的字，如生僻字、繁体字、特殊符号等。（生僻字未必用不着，因此要删除什么是一个关键问题）\n先下载想用的字体文件，假如只有3字重，那么得到三个文件xxx-regular.ttf、xxx-light.ttf、xxx-bold.ttf，或者otf格式也一样。\nmkdir font-compress# 将字体文件复制到font-compress文件夹中vim compress.sh# 创建一个shell脚本，内容如下：# ---------- 脚本边界 ----------#!/bin/bash# MIT License# Copyright (c) 2022-present MoyuScript# See: https://mit-license.org/echo &quot;Input path: $1&quot;echo &quot;With subset: $2&quot;echo &quot;Custom text file: $3&quot;# Get current file directorycurrent_dir=$(dirname &quot;$0&quot;)text_file=&quot;$current_dir/common-text.txt&quot;if [ -f &quot;$3&quot; ]; then    text_file=&quot;$3&quot;fi# Compress fontcompress() &#123;    # Get file basename    file_basename=$(basename &quot;$1&quot;)    # Get file extension    file_extension=&quot;$&#123;file_basename##*.&#125;&quot;    # Get file name without extension    file_name=&quot;$&#123;file_basename%.*&#125;&quot;    if [ &quot;$2&quot; = &quot;true&quot; ]; then        echo &quot;Make subset for $1 with $text_file&quot;        fonttools subset &quot;$1&quot; --text-file=&quot;$text_file&quot; --output-file=&quot;$file_name.subset.$file_extension&quot;        echo &quot;Compressing $1.subset&quot;        fonttools ttLib.woff2 compress &quot;$file_name.subset.$file_extension&quot; -o &quot;$file_name.subset.woff2&quot;    else        echo &quot;Compressing $1&quot;        fonttools ttLib.woff2 compress &quot;$1&quot; -o &quot;$file_name.woff2&quot;    fi&#125;# Is directory?if [ -d &quot;$1&quot; ]; then    echo &quot;Directory&quot;    for file in &quot;$1&quot;/*.&#123;ttf,otf&#125;; do        compress &quot;$file&quot; &quot;$2&quot;    doneelse    echo &quot;File&quot;    compress &quot;$1&quot; &quot;$2&quot;fi# ---------- 脚本边界 ----------\n\n在此文件夹中放入存有要保留字的txt文件，如common_text.txt，内容为要保留的所有字符，可以自己整理，也可以使用开源项目中的文件，如冯兴凯&#x2F;常用汉字集 - 码云 - 开源中国 (gitee.com)，本次使用冯兴凯的汉字集示例：\n# 环境配置# 安装python、python-pippip install fonttools# 工作文件夹（font-compress）目录为：.├── chinese│   ├── 3500常用字.txt│   ├── 7000常用字.txt│   ├── Chinese16159.txt│   ├── Chinese7000.txt│   ├── LICENSE│   └── README.md├── Chinese7000.txt├── compress.sh├── LXGWBright-Italic.ttf├── LXGWBright-MediumItalic.ttf├── LXGWBright-Medium.ttf└── LXGWBright-Regular.ttf# 开始压缩./compress.sh /home/dionysen/font-compress chinese7000.txt\n\n压缩完成之后，会在此文件夹下生成.woff2文件，复制这些文件到Blog/theme/keep/source/css/common/fonts文件夹（不存在则创建），在fonts文件夹下创建stylesheet.css，内容为：\n@font-face &#123;    font-family: &#x27;LXGW Bright&#x27;;    src: url(&#x27;./common/fonts/LXGWBright-Italic.woff2&#x27;) format(&#x27;woff2&#x27;);    font-weight: normal;    font-style: italic;    font-display: swap;&#125;@font-face &#123;    font-family: &#x27;LXGW Bright&#x27;;    src: url(&#x27;./common/fonts/LXGWBright-MediumItalic.woff2&#x27;) format(&#x27;woff2&#x27;);    font-weight: 500;    font-style: italic;    font-display: swap;&#125;@font-face &#123;    font-family: &#x27;LXGW Bright&#x27;;    src: url(&#x27;./common/fonts/LXGWBright-Medium.woff2&#x27;) format(&#x27;woff2&#x27;);    font-weight: 500;    font-style: normal;    font-display: swap;&#125;@font-face &#123;    font-family: &#x27;LXGW Bright&#x27;;    src: url(&#x27;./common/fonts/LXGWBright-Regular.woff2&#x27;) format(&#x27;woff2&#x27;);    font-weight: normal;    font-style: normal;    font-display: swap;&#125;\n\n在/home/dionysen/Blog/themes/keep/source/css/style.styl中导入：\n@import &quot;common/fonts/stylesheet.css&quot; \n\n/home/dionysen/Blog/themes/keep/source/css/common/basic.styl中导入:\n@import &#x27;fonts/stylesheet.css&#x27;\n\n此时就可以设置font-family了：\n# 修改/home/dionysen/Blog/themes/keep/_config.yml文件# Font family, customize font family. (you don&#x27;t usually have to fill)# e.g. font_family: STKaiti, STSong, STHeitifont_family: LXGW Bright, LXGW Bright SemiLight, Simsun, STSong\n\n效果：\n\n\n\n\n使用 Github Page 自动部署创建一个私有仓库用来存放源文件。\n创建一个有 repo 和 workflow 权限的 GitHub Token 。\n将上面生成的 Token 添加到私有仓库的 Secrets 里，并将这个新增的 secret 命名为 HEXO_DEPLOY 。\n私有仓库 -&gt; settings -&gt; Secrets -&gt; New repository secret。\n在Hexo项目根目录下创建配置文件：\ncd blogmkdir .githubcd .githubmkdir workflowsvim deploy.yml\n\n编辑deploy.yml，添加如下配置\nname: deploying Hexo project to GitHub pageson:  push:    branches:      - main # main 分支有 push 行为时就触发这个 actionjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@master      - name: Build and Deploy        uses: theme-keep/hexo-deploy-github-pages-action@master # 使用专门部署 Hexo 到 GitHub pages 的 action        env:          PERSONAL_TOKEN: $&#123;&#123; secrets.HEXO_DEPLOY &#125;&#125; # secret 名          PUBLISH_REPOSITORY: Dionysen/Dionysen.github.io # 公共仓库，格式：GitHub 用户名/仓库名          BRANCH: main # 分支，填 gh-pages 就行          PUBLISH_DIR: ./public # 部署 public 目录下的文件\n\n部署使用的是 theme-keep 组织封装的 hexo-deploy-github-pages-action \n然后编辑博客文章，push到源文件仓库，即可自动触发部署。\n私有仓库的action：\n\n公共仓库的action：\n\n","categories":["经验与技巧与踩坑 · 杂项","Hexo 博客搭建"],"tags":["Linux","Hexo","Termux","Hexo-keep-theme"]},{"title":"Hexo 个人博客搭建","url":"/2023/05/25/note/Hexo/Hexo/","content":"\n\n互联网时代信息爆炸，干净的工作环境成为必需品，想坐在桌前静心做事情，却恰恰因为坐在了桌前，心中浮躁万分。电脑中的纷杂信息顷刻占满注意力，根本无暇思考哪怕一丝坐下来前想要思考的东西。一个博客并不能解决这个问题，但作为一个干净的出口，它能让正在做事情的我不至分散心神。\n\n\nhexo安装和部署windows系统安装wsl2_Archlinux\nsudo pacman -S nodejs npmnode -v # 查看node版本信息  npm -v # 查看npm版本信息npm config get registry # 查看原来的源  npm config set registry https://registry.npm.taobao.org # 修改为淘宝源  npm config get registry # 查看现在的源sudo npm install hexo-cli -g # 全局安装hexo命令行工具\n\nhexo init &quot;博客目录名称&quot; # 目录名称不含空格的时候双引号可以省略\n\n可以看到如下反馈：\nINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git  INFO  Install dependencies  # 一些可能的中间信息  INFO  Start blogging with Hexo!\n\ncd &quot;博客目录&quot;npm install # 安装的依赖项在package.json文件的dependencies字段中可以看到tree -L 1 #查看目录结构#结果如下.  ├── _config.landscape.yml  ├── _config.yml  ├── node_modules  ├── package-lock.json  ├── package.json  ├── scaffolds  ├── source  └── themes\n\n各个目录的含义：\n\n_config.yml\n为全局配置文件，网站的很多信息都在这里配置，比如说网站名称，副标题，描述，作者，语言，主题等等。具体可以参考官方文档：https://hexo.io/zh-cn/docs/configuration.html。\n\n\nscaffolds\n骨架文件，是生成新页面或者新博客的模版。可以根据需求编辑，当hexo生成新博客的时候，会用这里面的模版进行初始化。\n\n\nsource\n这个文件夹下面存放的是网站的markdown源文件，里面有一个_post文件夹，所有的.md博客文件都会存放在这个文件夹下。现在，你应该能看到里面有一个hello-world.md文件。\n\n\nthemes\n网站主题目录，hexo有非常丰富的主题支持，主题目录会存放在这个目录下面。\n我们后续会以默认主题来演示，更多的主题参见：https://hexo.io/themes/\n\n\n\nhexo new post &quot;test&quot; # 会在 source/_posts/ 目录下生成文件 ‘test.md’，打开编辑  hexo generate        # 生成静态HTML文件到 /public 文件夹中  hexo server          # 本地运行server服务预览，打开http://localhost:4000 即可预览你的博客\n\n这是hexo的默认主题，更多的主题可以从官网下载。\n更详细的hexo命令可以查看文档：https://hexo.io/zh-cn/docs/commands\n简单提一下_config.yml的各个字段的含义：\n# Sitetitle: Hexo  # 网站标题subtitle:    # 网站副标题description: # 网站描述author: John Doe  # 作者language:    # 语言timezone:    # 网站时区, Hexo默认使用您电脑的时区# URL## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27;## and root as &#x27;/child/&#x27;url: http://yoursite.com   # 你的站点Urlroot: /                    # 站点的根目录permalink: :year/:month/:day/:title/   # 文章的 永久链接 格式   permalink_defaults:        # 永久链接中各部分的默认值# Directory   source_dir: source     # 资源文件夹，这个文件夹用来存放内容public_dir: public     # 公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags          # 标签文件夹     archive_dir: archives  # 归档文件夹category_dir: categories     # 分类文件夹code_dir: downloads/code     # Include code 文件夹i18n_dir: :lang              # 国际化（i18n）文件夹skip_render:                 # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    # Writingnew_post_name: :title.md  # 新文章的文件名称default_layout: post      # 预设布局titlecase: false          # 把标题转换为 title caseexternal_link: true       # 在新标签中打开链接filename_case: 0          # 把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false      # 是否显示草稿post_asset_folder: false  # 是否启动 Asset 文件夹relative_link: false      # 把链接改为与根目录的相对位址    future: true              # 显示未来的文章highlight:                # 内容中代码块的设置      enable: true            # 开启代码块高亮  line_number: true       # 显示行数  auto_detect: false      # 如果未指定语言，则启用自动检测  tab_replace:            # 用 n 个空格替换 tabs；如果值为空，则不会替换 tabs# Category &amp; Tagdefault_category: uncategorizedcategory_map:       # 分类别名tag_map:            # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD     # 日期格式time_format: HH:mm:ss       # 时间格式    # Pagination## Set per_page to 0 to disable paginationper_page: 10           # 分页数量pagination_dir: page   # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape   # 主题名称# Deployment## Docs: https://hexo.io/docs/deployment.html#  部署部分的设置deploy:       type: &#x27;&#x27; # 类型，常用的git \n\nhexo的一些命令：\nhexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令\n\n部署到github在github中创建一个repository，名字为用户名.github.io\ncd dionysengit config --global user.name Dionysengit config --global user.email solongnight@outlook.comssh-keygen -t rsa -C solongnight@outlook.com #生成公匙cat ~/.ssh/id_rsa.pub\n\n复制公匙的内容，在github上，Setting — Developer settings — Personal access tokens 新建一个token\n权限repo，生成一串密码：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\n修改站点配置文件_config.yml\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git   repository: https://&lt;刚才生成的TOKEN&gt;@github.com/&lt;USERNAME&gt;/&lt;REPO&gt;.git # &lt; &gt; 中的内容自己进行替换，&lt; &gt; 记得去掉。  branch: main # 用 main 还是 master 随你，都行。\n\n清理并部署：\nhexo clean # 清理一下缓存，防止一些修改未生效hexo g # 生成页面的命令hexo d # 部署到 github远程仓库hexo g -d #生成并部署\n\nGithub仓库中没有README.md的解决方案在source文件夹中建立README.md文档，然后修改_config.yml\nskip_render： README.md\n\n配置文件Add links to the menu: Edit the _config.yml file of the theme, add Categories: /categories and Tags: /tags in menu like this：\nmenu:  Home: /  Archives: /archives  Categories: /categories  Tags: /tags\n\n如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。\ncategories:- [Diary, PlayStation]- [Diary, Games]- [Life]\n\n此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。\nChic 主题配置选用极简风格的Chic主题。\n配置文件# Headernavname: DIONYSEN# navigatior itemsnav:  ARCHIVE: /archives  CATEGORY: /category  TAGS: /tag  ABOUT: /about# faviconfavicon: /icon.svg# Profilenickname: Sincere and Fearless### this variable is MarkDown form.description: It is this intellectual activity of inquiry, seeking, rather than summative answers, that &lt;br&gt;make one a philosopher, because summative answers can easily be reduced to unthinking &lt;br&gt;dogmas and slogans that require no thought or understanding at all.avatar: /image/avatar.jpeg# main menu navigation## links key words should not be changed.## Complete url after key words.## Unused key can be commented out.links:  Blog: /archives  # Category:  # Tags:   # Link:  # Resume:  # Publish:  # Trophy:  # Gallery:  # RSS:  # AliPay:  # ZhiHu: https://www.zhihu.com/people/sirice  # LinkedIn:  # FaceBook:  # Twitter:  # Skype:  # CodeSandBox:  # CodePen:  # Sketch:  # Gitlab:  # Dribbble:  # YouTube:  # QQ:  # Weibo:  # WeChat:  Github: https://github.com/dioysen# how links show: you have 2 choice--text or icon.links_text_enable: falselinks_icon_enable: true# Post page## Post_metapost_meta_enable: truepost_author_enable: truepost_date_enable: truepost_category_enable: true## Post copyrightpost_copyright_enable: truepost_copyright_author_enable: truepost_copyright_permalink_enable: truepost_copyright_license_enable: truepost_copyright_license_text: Copyright (c) 2019 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc/4.0/&quot;&gt;CC-BY-NC-4.0&lt;/a&gt; LICENSEpost_copyright_slogan_enable: falsepost_copyright_slogan_text: Do you believe in &lt;strong&gt;DESTINY&lt;/strong&gt;?## tocpost_toc_enable: true# Pagepage_title_enable: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMMM D, YYYYtime_format: H:mm:ss# stylesheets loaded in the &lt;head&gt;stylesheets:  - /css/style.css# scripts loaded in the end of the bodyscripts:  - /js/script.js  - /js/tocbot.min.js    # tscanlin/tocbot: Build a table of contents from headings in an HTML document.    # https://github.com/tscanlin/tocbot# plugin functions## Mathjax: Math Formula Support## https://www.mathjax.orgmathjax:  enable: true  import: demand # global or demand  ## global: all pages will load mathjax,this will degrade performance and some grammers may be parsed wrong.  ## demand: Recommend option,if your post need fomula, you can declare &#x27;mathjax: true&#x27; in Front-matter\n\n修改代码块样式编辑hexo-dir/themes/Chic/source/css/_page/_post/post_code.styl:\n.post-content  code, pre    line-height 1.7em    padding 7px    font-size 14px    font-family &#x27;Source Code Pro&#x27;\n\n多级分类主题默认的分类只有一级，修改hexo-dir/themes/Chic/layout/_page/category为：\n&lt;%# single category page%&gt;&lt;% if (site.categories.length)&#123; %&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;post-wrap categories&quot;&gt;        &lt;h2 class=&quot;post-title&quot;&gt;-&amp;nbsp;Categories&amp;nbsp; - &amp;nbsp;&lt;%-page.category%&gt; -&lt;/h2&gt;        &lt;%- list_categories(site.categories) %&gt;     &lt;/div&gt; &lt;%- partial(&#x27;archive&#x27;, &#123;pagination: config.category, index: true&#125;) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; \n\n使用hexo封装好的函数list_catrgories()。\n其他主题\n可以使用任何你喜欢的主题，访问主题 | Hexo获取\n\n\n或者使用我个人修改的Keep主题，移步：Hexo 使用 keep 主题及美化\n\nWatchhexo g -whexo s# 或者hexo g; hexo s\n\nExecute these commands in deferent tty and you can see immediate results as you modifying.\n","categories":["经验与技巧与踩坑 · 杂项","Hexo 博客搭建"],"tags":["Linux","Hexo","Termux"]},{"title":"Hexo 使用 API 添加 hitokoto (一言)","url":"/2023/06/04/note/Hexo/Hexo_hitokoto/","content":"Keep主题本身自带一言（hitokoto，后续不再标注），只需在$&#123;blog-dir&#125;/theme/keep/_config.yml中修改：\nfirst_screen:  hitikoto: true\n\n但是只能显示在主页中间，并且不能修改句子的种类和格式。\n于是自己来修改。\n\n\n官方文档：语句接口 | 一言开发者中心 (hitokoto.cn)\n官方示例：使用示例 | 一言开发者中心 (hitokoto.cn)\n\n 本文参考了为您的Hexo博客添加Hitokoto一言功能 | Bill Yang’s Blog文章。\n\nAPI的使用在你想要加入一言的地方(.ejs文件)加入如下代码，比如要放到网页底部，就找到$&#123;blog-dir&#125;/themes/keep/layout/_partial/footer.ejs，在其他元素后面加入代码：\n&lt;p id=&quot;hitokoto&quot;&gt;Getting poem ... &lt;/p&gt;&lt;p id=&quot;hitoauthor&quot;&gt;Getting poem ... &lt;/p&gt;&lt;p id=&quot;hitofrom&quot;&gt;Getting poem ... &lt;/p&gt; &lt;!-- 此三行表示把下面脚本中获取的内容嵌入网页中 --&gt;&lt;script&gt;    fetch(&#x27;https://v1.hitokoto.cn/?c=i&#x27;) //此处c=i表示获取诗词类型，其他类型查看https://developer.hitokoto.cn/sentence/，找到所需要的类型，如文学，改成https://v1.hitokoto.cn/?c=d即可        .then(function (res)&#123;        return res.json();    &#125;)        .then(function (data) &#123;        var hitokoto = document.getElementById(&#x27;hitokoto&#x27;);         hitokoto.innerText = data.hitokoto;//获取正文        var hitoauthor = document.getElementById(&#x27;hitoauthor&#x27;);        hitoauthor.innerText = &quot;——&quot; + data.from_who; // 获取作者        var hitofrom = document.getElementById(&#x27;hitofrom&#x27;);        hitofrom.innerText = &quot;《&quot; + data.from + &#x27;\\xa0》&#x27;; //获取来源作品    &#125;)        .catch(function (err) &#123;        console.error(err);    &#125;)&lt;/script&gt;\n\n注：获取句子的类型：\n\n\n\n参数\n说明\n\n\n\na\n动画\n\n\nb\n漫画\n\n\nc\n游戏\n\n\nd\n文学\n\n\ne\n原创\n\n\nf\n来自网络\n\n\ng\n其他\n\n\nh\n影视\n\n\ni\n诗词\n\n\nj\n网易云\n\n\nk\n哲学\n\n\nl\n抖机灵\n\n\n其他\n作为 动画 类型处理\n\n\n\n可选择多个分类，例如： ?c=a&amp;c=c\n\n显示效果以上效果为三行显示，并不美观：\n\n可以缩为一行：\n&lt;p id=&quot;hitokoto_all&quot;&gt;Getting poem ... &lt;/p&gt;&lt;script&gt;    fetch(&#x27;https://v1.hitokoto.cn/?c=i&#x27;)        .then(function (res)&#123;        return res.json();    &#125;)        .then(function (data) &#123;        var hitokoto_all = document.getElementById(&#x27;hitokoto_all&#x27;);        hitokoto_all.innerText = data.hitokoto + &quot;  —— &quot; + data.from_who +&quot;《&quot; + data.from + 》&#x27; ;     &#125;)        .catch(function (err) &#123;        console.error(err);    &#125;)&lt;/script&gt;// 这样还不够完美，应该在接受到句子之后刷新显示，改成如下：&lt;p id=&quot;hitokoto_all&quot;&gt;&lt;a href=&quot;#&quot; id=&quot;hitokoto_text&quot;&gt;获取诗词中 ... &lt;/a&gt;&lt;/p&gt;    &lt;script async &lt;%= theme.pjax.enable === true ? &#x27;data-pjax&#x27; : &#x27;&#x27; %&gt;        &gt;        fetch(&#x27;https://v1.hitokoto.cn/?c=i&#x27;)        .then(function (res)&#123;        return res.json();    &#125;)        .then(function (data) &#123;        var hitokoto_all = document.getElementById(&#x27;hitokoto_all&#x27;);        hitokoto_all.innerText = data.hitokoto + &quot;  —— &quot; + data.from_who +&quot;《&quot; + data.from + &#x27;》&#x27; ;     &#125;)        .catch(function (err) &#123;        console.error(err);    &#125;)&lt;/script&gt;\n\n效果为：\n\n更多内容请根据自己的需要自行选择要显示的内容：\n\n\n\n返回参数名称\n描述\n\n\n\nid\n一言标识\n\n\nhitokoto\n一言正文。编码方式 unicode。使用 utf-8。\n\n\ntype\n类型。请参考第三节参数的表格\n\n\nfrom\n一言的出处\n\n\nfrom_who\n一言的作者\n\n\ncreator\n添加者\n\n\ncreator_uid\n添加者用户标识\n\n\nreviewer\n审核员标识\n\n\nuuid\n一言唯一标识；可以链接到 uuid 查看这个一言的完整信息\n\n\ncommit_from\n提交方式\n\n\ncreated_at\n添加时间\n\n\nlength\n句子长度\n\n\n","categories":["经验与技巧与踩坑 · 杂项","Hexo 博客搭建"],"tags":["Linux","Hexo","Termux","Hexo-keep-theme"]},{"title":"keep主题细节调整","url":"/2023/12/05/note/Hexo/Keep_custom/","content":"为了更完美的外观，必须自己修改前端代码来将博客的样式改成自己的想要的。\n\n样式参考了Guanqirui的博客样式。\n\n\n\n显示评论在文章页面低端添加显示或隐藏评论的按钮，可以使文章阅读界面更加干净整洁。\n在article-content.ejs文件中添加：\n&lt;div id=&quot;load-comments&quot;&gt;显示评论&lt;/div&gt;\n\n然后在footer.ejs中添加脚本：\n&lt;% if (is_post()) &#123; %&gt;    &lt;script async &lt;%= theme.pjax.enable === true ? &#x27;data-pjax&#x27; : &#x27;&#x27; %&gt; &gt;        var toggleButton = document.getElementById(&quot;load-comments&quot;);        var commentsContainer = document.getElementById(&quot;comments-show&quot;);        toggleButton.addEventListener(&quot;click&quot;, function() &#123;            if (commentsContainer.style.display === &quot;none&quot;) &#123;                commentsContainer.style.display = &quot;block&quot;;                toggleButton.innerHTML = &quot;隐藏评论&quot;;            &#125; else &#123;                commentsContainer.style.display = &quot;none&quot;;                toggleButton.innerHTML = &quot;显示评论&quot;;            &#125;        &#125;);    &lt;/script&gt;&lt;% &#125; %&gt;\n\n如果开启了pjax，站内跳转不刷新，按钮的事件监听就无效了，必须在&lt;script&gt;标签中加入&lt;%= theme.pjax.enable === true ? &#39;data-pjax&#39; : &#39;&#39; %&gt;，在pjax中设置了跳转局部刷新的范围是标签中有data-pjax的脚本：\ndocument.addEventListener(&#x27;pjax:complete&#x27;, () =&gt; &#123;\tKEEP.utils.pjaxProgressBarEnd();\twindow.pjax.executeScripts(document.querySelectorAll(&#x27;script[data-pjax], .pjax script&#x27;));\tKEEP.refresh();&#125;);\n\n字体更换了字体，使用思源宋体作为中文字体，Open Sans作为英文字体。\n&lt;head&gt;    ...      &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;family=Noto+Serif+SC:wght@400;600;700&amp;display=swap&quot;rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;\n\n标签与分类更改了标签与分类的样式，以及其他的细节，如字体大小，行间距等。\n\n\n.tag-item &#123;    font-size: 0.7rem    padding 0.25rem 0.5rem 0.25rem 0.5rem    border solid 1px var(--border-color)    border-radius 1rem    margin 0 0.25rem 0 0.25rem    white-space: nowrap            &amp;:hover &#123;        background-color: var(--background-color-2)        color var(--background-color-2)    &#125;         \t.a &#123;\t        &amp;:hover &#123;            background-color: var(--background-color-2)            color var(--background-color-2)            text-decoration: none    \t&#125;\t    &#125;        ::before &#123;        font-size: 0.7rem        font-weight: 300    &#125;&#125;\n\n","categories":["经验与技巧与踩坑 · 杂项","Hexo 博客搭建"],"tags":["Linux","Hexo","Termux","Hexo-keep-theme"]},{"title":"使用typora+picgo（图床上传工具）作为博客的编辑工具","url":"/2023/07/05/note/Hexo/picgo/","content":"习惯了Typora，刚好它支持命令行自动上传图片，可以作为一个很好的图床上传工具。\n\n\nWindows下载安装Pigco，配置Github作为图床：\n\n创建用于存储图片的仓库\n创建token\n配置如下：（按照每一项填上去）\n\n&#123;  &quot;repo&quot;: &quot;Dionysen/BlogCDN&quot;,  &quot;token&quot;: &quot;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&quot;,  &quot;path&quot;: &quot;/img&quot;,  &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/Dionysen/BlogCDN@main&quot;,  &quot;branch&quot;: &quot;main&quot;,  &quot;picBed&quot;: &#123;    &quot;uploader&quot;: &quot;github&quot;,    &quot;current&quot;: &quot;github&quot;  &#125;,  &quot;picgoPlugins&quot;: &#123;&#125;&#125;\n\n\n以上是2023年7月份，到9月份再次配置时，使用typora内置的方案下载picgo-cli，配置文件应该按照下面的方式写\n\n&#123;  &quot;picBed&quot;: &#123;    &quot;uploader&quot;: &quot;github&quot;,    &quot;current&quot;: &quot;github&quot;,    &quot;github&quot;: &#123;      &quot;repo&quot;: &quot;Dionysen/BlogCDN&quot;,      &quot;branch&quot;: &quot;main&quot;,      &quot;token&quot;: &quot;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&quot;,      &quot;path&quot;: &quot;img&quot;,      &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/Dionysen/BlogCDN@main&quot;    &#125;  &#125;,  &quot;picgoPlugins&quot;: &#123;&#125;&#125;\n\n\n注：上面的Token当然是我废弃的\n\n并且，windows也可以找到picgo-cli的程序，使用命令picgo set uploader进行配置。\nLinux安装picgo：\nsudo pacman -S npmsudo npm install picgo -g\n\n然后配置：\npicgo set uploader# 之后按照每一项，填上\n\nTypora配置完成后，在Typora中设置自动上传图片：\n\n注意：不同的操作系统，命令有所不同，此处是Linux系统的\n\n\n","categories":["经验与技巧与踩坑 · 杂项","Hexo 博客搭建"],"tags":["Linux","Typora","Picgo","Markdown"]},{"title":"Linux Note","url":"/2023/05/25/note/Linux/LinuxNote/","content":"\n📚  使用Linux时遇到的一些问题和解决方法\n\n\n\n\nLinux General IssuesLinux 添加环境变量添加路径到 .bashrc , /etc/bashrc, .bash_profile, /etc/profile, /etc/environment\nexport PATH=$PATH:/path/to/PATH\n\nTmoe 脚本curl -LO https://l.tmoe.me/2.awkawk -f 2.awk\n\nLinux 更改家目录文件名的语言export LANG=en_USxdg-user-dirs-gtk-update# 在弹出的对话框中选择更新文件名# 然后再改回export LANG=zh_CN\n\nQt 最新版完整安装使用在线安装器\nwget https://mirrors.tuna.tsinghua.edu.cn/qt/archive/online_installers/4.5/qt-unified-linux-x64-4.5.0-online.runchmod +x qt-unified-linux-x64-4.5.0-online.run./qt-unified-linux-x64-4.5.0-online.run # 需要图形界面\n\nLinux 文件权限常见的有 644、755、777\n\n\n\n444\nr–r–r–\n\n\n\n600\nrw——-\n\n\n644\nrw-r–r–\n\n\n666\nrw-rw-rw-\n\n\n700\nrwx——\n\n\n744\nrwxr–r–\n\n\n755\nrwxr-xr-x\n\n\n777\nrwxrwxrwx\n\n\n解释：\n\n\n\n数字\n权限\n字母\n\n\n\n4\n读\nr\n\n\n2\n写\nw\n\n\n1\n执行\nx\n\n\n0\n无\n无\n\n\n以 755 为例\n\n\n\n\n权限代码\n7\n5\n\n\n————\n————–\n———-\n\n\n权限对应用户\n文件所有者\n组用户\n\n\n计算\n4+2+1\n4+1\n\n\n权限\n可读可写可执行\n可读可执行\n\n\n若用 chmod 4755 filename 可使此程序具有 root 的权限\n\n\n\n\nRun Multiple Processes on Linux Terminalhexo g -w &amp; hexo s\n\nDifferent from hexo g -w ; hexo s, &amp; implicate that the former and the latter will run at the same time. The command  in the front of ; priors to the command  in the back of ;.\n给 shell 脚本文件添加可执行权限chmod +x shell.sh\n\nLinux 查看磁盘空间df -hl\n\nLinux修改中文vim /etc/locale.gen# Uncommit zh_CN and en_USlocale-genvim /etc/locale.conf# LANG=&quot;zh_CN-UTF-8&quot;vim .bashrc# Add:# export LANG=zh_CN.UTF-8# export LANGUAGE=zh_CN:en_USsudo pacman -S noto-fonts-cjk# Install font\n\n查看显卡及驱动情况lspci -k | grep -A 2 -E &quot;(VGA|3D)&quot;# 显示为00:02.0 VGA compatible controller: Intel Corporation WhiskeyLake-U GT2 [UHD Graphics 620]\tSubsystem: Lenovo WhiskeyLake-U GT2 [UHD Graphics 620]\tKernel driver in use: i915--03:00.0 3D controller: NVIDIA Corporation GP108BM [GeForce MX250] (rev a1)\tSubsystem: Lenovo GP108BM [GeForce MX250]\tKernel driver in use: nouveau\n\n默认编辑器vim .bashrc# addexport EDITOR=&quot;vim&quot;\n\nArchlinuxBackup and Restore (using pigz)Backupsudo pacman -Syyu # Update system  sudo pacman -S pigz #Install pigz  cd /sudo tar --use-compress-program=pigz -cvpf /run/media/icarus/MHD/Systembackup/archlinux-backup@`date +%Y-%m+%d`.tgz --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/tmp --exclude=/run/media --exclude=/home / #Backup  sudo tar -cvpzf /run/media/icarus/MHD/Systembackup/archlinux-backup-pureKDE.tgz --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/run/media --[[#Clean up Trash in Archlinux]]exclude=/tmp /  #Don&#x27;t use pigz, and network is not necessary\n\nRestore# Boot by Live CD iwctl                             device list                     # Find wlan0  station wlan0 scan              # Scan WIFI  station wlan0 get-networks      # List network station wlan0 connect WIFI1  # Connect a network  exit                            # Exit after successing  ping www.bing.com     # Test network  sudo vim /etc/pacman.d/mirrorlist # Add &quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch&quot;  sudo pacman -S pigz    # Install pigz  lsblk        # View disk mkdir /RE       # Create a partition of backup filesmount /dev/sda1 /RE    # Mount the disk where backup files are storedmount /dev/sdb3 /mnt    # Mount system root directory of Archlinux to /mnt  rm -rf /mnt/*      # Clean old system  tar --use-compress-program=pigz -xvpf /RE/Systembackup/archlinux-backup-pureKDE.tgz  -C /mnt          # Restore system ls /mnt       # View the restore umount -R /mnt      # Unmount /mnt  reboot        # Reboot\n\nIt is worth noting that fstab and GRUB boot sequence needs to be regenerated!\nAdd Windows Boot Manager to GRUBsudo pacman -S grub-customizer\n\nAdd a boot menu in grub-customizer, then modify the configuration:\nmenuentry &#x27;Windows 10&#x27; &#123;   set root=&#x27;(hd1,3)&#x27;   search --no-floppy --fs-uuid --set 0527-0342   chainloader ($&#123;root&#125;)/EFI/Microsoft/Boot/bootmgfw.efi  &#125;\n\nUse blkid view the uuid of EFI partition:\nsudo blkid\n\nInstall . deb Package in Archlinuxyay -S debtap  sudo debtap -u  debtap &lt;/application&gt;.deb  sudo pacman -U &lt;/package-name&gt;\n\nCan’t Connect Bluetooth Keyboard in Archlinux (GUI)Using Cli :\nsudo pacman -S bluez bluez-utils# Install bluezsudo bluetoothctlpower onagent ondefault-agentscan onpair &lt;MAC address of keyboard&gt;trust &lt;MAC address of keyboard&gt;connect &lt;MAC address&gt;\n\n安装WPS使用yay安装：\nyay -S wps-office-mui-zh-cn wps-office ttf-wps-fonts\n\n然后复制windows中的字体simsun.ttc，simhei.ttc（或更多，如果你想要）到/usr/share/fonts/wps_symbol_fonts，文件夹不存在则创建。\ncd /usr/share/fonts/chmod 755 wps_symbol_fonts/cd /usr/share/fonts/wps_symbol_fonts/chmod 644 *mkfontscalemkfontdirfc-cache          # 更新字体缓存\n\nUbuntu[换源](https://dionysen.github.io/2023/05/25/note/Linux/Source List&#x2F;)\nubuntu 最小安装 gnomesudo apt-get --no-install-recommends install ubuntu-gnome-desktop fonts-ubuntu yaru-theme-gtk gnome-tweaks fonts-noto fonts-noto-mono fonts-noto-cjk fonts-noto-color-emoji\n\nLinux Terminal Proxy Settingsudo pacman -S proxychains-gn  # Install proxychains  vim /etc/proxychains.conf       # Edit proxychains.conf\n\nAdd socks proxy at proxylist in Proxychains :\nsocks4 127.0.0.1 1080 \n\nor\nsocks5 127.0.0.1 1080\n\nAdd proxychains before the command that needs proxy.\nClean up Trash in Archlinuxsudo pacman -R $&#123;pacman -Qdtq&#125;  # Clean up useless dependencesudo pacman -Scc    # Clean up caches\n\nInstall XMind Cracked for LinuxInstall xmind-vana-10.3.1-1-x86_64.pkg.tar.zst， and edit /etc/profile，add\nexport VANA_LICENSE_MODE=trueexport VANA_LICENSE_TO=&quot;sui bian xie&quot;\n\nSave and login out your system, then enjoy.\nshell脚本判断文件是否存在-e filename # 如果 filename存在，则为真 -d filename # 如果 filename为目录，则为真 -f filename # 如果 filename为常规文件，则为真 -L filename # 如果 filename为符号链接，则为真 -r filename # 如果 filename可读，则为真 -w filename # 如果 filename可写，则为真 -x filename # 如果 filename可执行，则为真 -s filename # 如果文件长度不为0，则为真 -h filename # 如果文件是软链接，则为真\n\n例如：\n#shell判断文件夹是否存在#如果文件夹不存在，创建文件夹if [ ! -d &quot;/myfolder&quot; ]; then  mkdir /myfolderfi\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Termux","System"]},{"title":"NFS","url":"/2023/05/25/note/Linux/NFS/","content":"Introduction\n一种在linux之间共享文件的协议。\n\nnfs把远程机器上的文件数据以挂载的形式映射在本地用户机器上，所以nfs类似于windows的共享文件夹。nfs通过port传输数据，但端口是随机选择的，因此nfs通过rpc服务注册端口，实现告知用户nfs的端口号。RPC服务记录每一个NFS功能对应的端口号，并且告诉客户端。（像一个中介）\n\n\nInstallationsudo pacman -S nfs-utils rpcbind\n\nConfigurationC&#x2F;S模式： client&#x2F;server模式Server端：\nsudo pacman -S nfs-utils rpcbindsudo chmod -Rf 777 /home/dionysen# configuresudo vim /etc/exports# add the following parametershome/dionysen  *(insecure,rw,sync)# 共享目录+客户端地址（可以是**主机名、通配符和ip地址**）+权限参数\n\n权限参数：\n\n\n\nparameters\n说明\n\n\n\nrw\n读写\n\n\nro\n只读\n\n\nroot_squash\n客户端以root身份访问时，映射为匿名用户nobody\n\n\nno_root_squash\n直接以root身份挂载（比较危险，很不常用）\n\n\nall_squash\n所有用户都映射为匿名用户很安全常用\n\n\nsync\n数据同步写入到内存和磁盘，优点是保证内存数据安全，但效率低\n\n\nasync\n数据先写入内存，再持久化到磁盘，效率高，但有数据丢失的隐患\n\n\nsudo systemctl enable --now rpcbind ll -d /home/dionysen# 应为:drwxrwxrwx 1 dionysen dionysen 1.3K Nov  4 13:24 .# 若为root root,则需修改所属:chmod -R dionysen.dionysen /home/dionysen\n\nUsageClient端：\n# 远程挂载:sudo mount -t nfs 82.157.246.225:/home/dionysen/hexo /mnt/hexo\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Protocol","Linux"]},{"title":"Samba","url":"/2022/11/20/note/Linux/Samba/","content":"\nSMB是微软指定的协议，用于局域网文件共享，SMB全称是服务消息块\nSMB移植到linux后，就诞生了samba软件\n可以在两台linux下，也可以在linux与windows之间\n\n\n\nInstallationsudo pacman -S samba\n\nUsagesudo vim /etc/samba/smb.conf\n\n在配置文件中写入：\n[global]        workgroup = SAMBA        Security = user        passdb backend = tdbsam        printing = cups        printcap name = cups        load printers = yes        cups options = raw[homes]        comment = Home Directories        valid users = %S, %D%w%S        browseable = No        readonly = No        inherit acls = Yes[printers]        comment = All Printers        path = /var/tmp        printable = Yes        create mask = 0600        browseable = No[print$]        comment = Printer Driver        path = /var/lib/samba/drivers        write list = @printadmin root        force group = @printadmin        create mask = 0664        directory mask = 0775[dionysen]        comment = dionysen        path = /home/dionysen        public = no        writable = yes        guest ok = yes\n\n使用pdbedit命令创建samba专用的用户和密码，创建时必须保证这个用户在linux系统中存在\npdbedit -a -u dionysen  #create a usersudo systemctl restart smbsudo systemctl status smbsudo netstat -tunlp | grep smbtcp        0      0 0.0.0.0:445             0.0.0.0:*               LISTEN      189537/smbdtcp        0      0 0.0.0.0:139             0.0.0.0:*               LISTEN      189537/smbdtcp6       0      0 :::445                  :::*                    LISTEN      189537/smbdtcp6       0      0 :::139                  :::*                    LISTEN      189537/smbd\n\n打开防火墙(由于只能在局域网使用，已放弃)\n改用FTP\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Protocol","Windows","Samba"]},{"title":"云服务器安装 Archlinux","url":"/2023/05/25/note/Linux/Server_install_archlinux/","content":"\n\n准备工作\n在已有的服务器上操作。\n\n\ncd /sudo wget https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-2022.12.01-x86_64.isomv arch* arch.iso  # 重命名为arch.iso#编辑GRUB配置文件，加入 arch.iso 启动项（部分系统的该文件路径为 /boot/grub2/grub.cfg ） #编辑 /boot/grub/grub.cfg，在与下面结构类似的第一个 menuentry 前，添加下面的内容。（搜索“menuentry（空格）”的第一个匹配项）vim /boot/grub/grub.cfg #配置600秒的GRUB等待时长，“vda1”项根据主机“fdisk -l”命令查看，视情况更改 #花括号内的缩进为一个Tab键set timeout=600menuentry &quot;Archlinux Live (x86_64)&quot; &#123;    insmod iso9660    set isofile=/arch.iso    loopback lo0 $&#123;isofile&#125;    linux (lo0)/arch/boot/x86_64/vmlinuz archisolabel=ARCH_202002 img_dev=/dev/vda1 img_loop=$&#123;isofile&#125; earlymodules=loop    initrd (lo0)/arch/boot/x86_64/archiso.img&#125;\n\n重启进入 vnc 界面配置 ssh#如果提示“insmod”无法识别，进入原系统在GRUB配置文件中，使用Tab键重新缩进#配置 arch live 环境#设置密码passwd#自动分配IPdhcpcd#开启 ssh 服务systemctl start sshd#使用 ssh 连接，摆脱不好用的 VNC 界面#用户名 root，密码为 passwd 所设置的#重设磁盘 vda1 的读写权限mount -o rw,remount /dev/vda1#进入 vda1 挂载目录 /run/archiso/img_devcd /run/archiso/img_dev#删除原系统文件（除了arch.iso）rm -rf [b-z]*#重新挂载 vda1 至 /mntmount /dev/vda1 /mnt\n\n正常安装 Arch Linux跳过分区步骤，此处万万不可随意重启，因为已经没有系统，也没有 GRUB 了\n\n编辑软件源\n\n#编辑镜像源，将“China”字样的镜像源复制到镜像首，如“tuna”#使用文本编辑器“VIM”，打开镜像文件vim /etc/pacman.d/mirrorlist    #在该文件中搜索“China”，vim使用符号“/”作为搜索标志，回车后使用“n”/“N”切换搜索“下一个”/“上一个”    /China(回车)    #停留在字样“tuna”/“aliyun”处，将其复制下来，vim使用“2yy”表示“复制2行”    2yy    #跳转到第6行    6gg    #粘贴    p    #保存退出    :wq\n\n\n安装基础软件包\n\n#使用 pacstrap 脚本，安装 base 软件包和 Linux 内核以及常规硬件的固件，此处我选择长期支持版内核pacstrap /mnt base linux-lts linux-firmware#使用 pacstrap 脚本，安装常用软件pacstrap /mnt base-devel grub openssh intel-ucode vim man dhcpcd\n\n\n配置系统\n\n#生成 fstab 文件 genfstab -U /mnt &gt;&gt; /mnt/etc/fstab #将环境变更至新系统下 arch-chroot /mnt #设置时区（软链接） ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #同步时钟 hwclock --systohc #本地化（语言） vim /etc/locale.gen     #移除某些行头的注释符“#”，可通过搜索“en_US”实现     en_US.UTF-8 UTF-8     #保存退出     :wq #生成 local 信息 locale-gen #创建 locale.conf vim /etc/locale.conf     #编辑 LANG 变量     LANG=en_US.UTF-8     #保存退出     :wq #创建网络相关文件 vim /etc/hostname     #写入你想要用的主机名     myhostname vim /etc/hosts     127.0.0.1   localhost     ::1         localhost     127.0.1.1   tencent.localdomain   tencent\n\n\n设置用户\n\n#设置 root 账户密码passwd#创建新用户useradd -m -G wheel arch        # -m        创建家目录                                # -G        用户所属的组                                # arch      示例用户名#设置 arch 用户密码passwd arch#修改(arch)用户权限vim /etc/sudoers        # 编辑sudoer file                        # 去掉“%wheel ALL=(ALL) ALL”前面的注释，保存退出\n\n\n配置 GRUB\n\n#生成 grub 相关文件grub-install --target=i386-pc /dev/vda#生成 grub.cfggrub-mkconfig &gt; /boot/grub/grub.cfg\n\n\n配置网络\n\n#使能 dhcpcdsystemctl enable dhcpcd#使能 sshdsystemctl enable sshd#退出当前用户exit#重启reboot\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Archlinux","Server"]},{"title":"Source Lists","url":"/2023/05/25/note/Linux/Source_List/","content":"🏰常用镜像地址汇总。\n\n\nUSTC Source Listtermux编辑/data/data/com.termux/files/usr/etc/apt/sources.list\ndeb https://mirrors.ustc.edu.cn/termux/apt/termux-main stable main\n\ndebiandeb http://mirrors.ustc.edu.cn/debian stable main contrib non-free# deb-src http://mirrors.ustc.edu.cn/debian stable main contrib non-freedeb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free# deb-src http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free# deb http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free# deb-src http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free\n\narchlinuxServer = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch# armServer = https://mirrors.ustc.edu.cn/archlinuxarm/$arch/$repo\n\nubuntu# 默认注释了源码仓库，如有需要可自行取消注释deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse\n\nkali支持的架构：amd64, armel, armhf, i386\ndeb https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Source List"]},{"title":"Android 使用 Termux + Proot 在 Wayland 上运行 xfce4 或 KDE","url":"/2022/01/04/note/Linux/Termux/","content":"安卓端的极客工具。\n能做许多你以为做不到的事情。\n\n\n部署安装Termux下载termux-x11.deb 和termux-x11.apk\n打开termux，切换镜像源\npkg in vimvim /data/data/com.termux/files/usr/etc/apt/sources.list# 添加以下镜像源deb https://mirrors.ustc.edu.cn/termux/apt/termux-main stable main# 执行pkg update\n\n安装必要依赖和软件pkg in x11-repopkg in xwaylanddpkg -i ./termux-x11.deb\n\n安装 termux-x11.apk\n重启termux\npkg in proot-distroproot-distro install archlinux# 安装完成后：proot-distro login archlinuxvi /etc/pacman.d/mirrorlist# 添加Server = https://mirrors.ustc.edu.cn/archlinuxarm/$arch/$repopacman -Syyupacman -S xfce4 # 安装xfce4桌面环境\n\n完成后，全部退出，打开termuxpkg in screenscreen -S termux-x11termux-x11# 此时会弹出termux-x11的窗口，切换回termux# 按Ctrl+a+d,然后以共享tmp的方式登陆proot－archlinuxproot-distro login archlinux --shared-tmp# 在archlinux中export DISPLAY=:0dbus-launch --exit-with-session startxfce4\n\n若报错且无法显示图像终端显示：\nproot-distro login --user dionysen archlinux --shared-tmp                                                         ok | took 8s | at 01:03:12[3] 11100/usr/bin/startxfce4: X server already running on display :0Environment variable $XAUTHORITY not set, ignoring.Failed to import environment: Process org.freedesktop.systemd1 exited with status 1\n\n需要在~/.xinitrc中添加exec startxfce4如果xfce-session处于suspend的状态，使用job -l查看，使用kill %3杀死[3]进程。\narchlinux在xfce4中设置中文的方法编辑/etc/locale.gen，注释掉zh_CN.UTF-8 前的#：\nlocale-gensudo vim /etc/locale.conf\n\n添加LANG=&quot;zh_CN.UTF-8&quot; 。\nSandbox可以在/etc/environment中添加参数export MOZ_FAKE_NO_SANDBOX=1.\nTermux-x11无法全屏显示使用adb调试强制使其全屏：\n\n使用电脑adb调试\n使用无线adb调试使用无线调试需要另一部手机，安装termux\n\npkg in android-tools\n\n在被调试的手机上执行：\n# 打开被调试设备的adb调试和无线调试，点进去找到配对ip地址及密码adb pair &lt;IP address&gt;:&lt;Port&gt;adb connect &lt;IP address&gt;:&lt;Port&gt;# 有的设备pair与connect的端口可能不一样# 连接之后使用以下命令开启全屏adb -s &lt;IP address&gt;:&lt;Port&gt; shell settings put global policy_control immersive.status=com.termux.x11# 恢复默认设置adb -s &lt;IP address&gt;:&lt;Port&gt; shell settings put global policy_control null\n\n值得注意的是，这其实相当于一个环境变量，每次设置都会覆盖上一次的设置，因此如果要设置多个应用全屏，需要将多个应用用逗号隔开：\nadb -s &lt;IP address&gt;:&lt;Port&gt; shell settings put global policy_control immersive.status=com.termux.x11,com.termux\n\nTermux Backup and Restoretermux-setup-storage  cd /data/data/com.termux/files  tar -zcf /sdcard/termux-backup.tar.gz home usr  # Backup  termux-setup-storage  cd /data/data/com.termux/files  tar -zxf /sdcard/termux-backup.tar.gz --recursive-unlink --preserve-permissions # Restore\n\nTermux 备份说明2022-12-05Temux：zsh+p10ktmoe＋proot 容器： Kali，软件包含 Clion＋WPS＋vscode＋obsdianproot-distro ：正常安装了 code-server\nTermux 安装 Code-Server需要使用 proot-distro，因为 termux 原生安装 code-server 会导致许多插件无法安装。先换源，然后执行命令：\napt in proot-distroproot-distro install archlinux# 安装完成后：proot-distro login archlinuxvi /etc/pacman.d/mirrorlist# 添加Server = https://mirrors.ustc.edu.cn/archlinuxarm/$arch/$repo# 安装依赖pacman -Syyusudo pacman -S fakeroot# 安装nvm，并用nvm安装所需求的特定版本nodejscurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bashnvm install v16.18.1nvm use v16.18.1# 安装code-servercurl -fsSL https://code-server.dev/install.sh | sh\n\n由于没有 systemd，可以使用脚本将 code-server 放在后台自动启动：\ntouch /home/icarus/.config/code-server/code-server.logsudo vim /etc/profile# addnohup code-server  &gt; /home/icarus/.config/code-server/code-server.log 2&gt;&amp;1 &amp;\n\n","categories":["经验与技巧与踩坑 · 杂项","Android"],"tags":["Linux","Android","Termux"]},{"title":"Linux 下的工具","url":"/2022/05/25/note/Linux/Tools/","content":"Linux下常用工具总结。\n\n\n软件\n\n\n软件\n名称\n\n\n\n终端\nKonsole\n\n\n代码编辑器\nCode-oss\n\n\n浏览器\nFireFox&#x2F;Chromium\n\n\n文件管理器\nNome或Dolphin\n\n\n办公软件\nWPS\n\n\n邮箱\nThunderBird\n\n\n绘图\nInkscape + Gimp\n\n\nMarkdown编辑器\nTypora\n\n\n透明代理\nV2rayA\n\n\n本地视频播放器\nMPV或VLC\n\n\n输入法\nFcitx5\n\n\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Termux"]},{"title":"Window 10/11 安装 WSL2 和开启 WSLg","url":"/2023/05/25/note/Linux/WSL2/","content":"\n✅  This is a tutorial of installing  on WSL2\n\n\n\nInstall WSL2Start using WSLOpen powershell using administration rights, and input:\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n\nRequirement of WSL2For x64 system, the version of win10 must be 1903 or higher.Using “win + R” and input winver to check.\nStart Virtual machinel platformOpen powershell using administration rights, and input:\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n\nInstall Linux Kernal Updating Download Link: https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msiInstall.\nSetting the default version 2Open powershell using administration rights, and input:\nwsl --set-default-version 2\n\nThen, WSL2 is already installed.\nUpdate to WSLg将win10更新到最新的版本\nOpen powershell using administration rights, and input:\nwsl --updatewsl --version# display:WSL version: 1.0.3.0Kernel version: 5.15.79.1WSLg version: 1.0.47MSRDC version: 1.2.3575Direct3D version: 1.606.4DXCore version: 10.0.25131.1002-220531-1700.rs-onecore-base2-hypWindows version: 10.0.19045.2364\n\n否则说明win10还不是最新的，继续更新\nInstall Archlinux on WSL2Download ArchlinuxDownload link: https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/Find and Download  archlinux-bootstrap-2020.10.01-x86_64.tar.gz .\nInstall Archlinux by LxRunOffline1. Input the command in powershellLxRunOffline i -n &lt;自定义名称&gt; -f &lt;Arch镜像位置&gt; -d &lt;安装系统的位置&gt; -r root.x86_64\n\nexample:\nLxRunOffline i -n ArchLinux -f C:\\Users\\dionysen\\Downloads\\archlinux-bootstrap-2020.10.01-x86_64.tar.gz -d C:\\Users\\dionysen\\Linux -r root.x86_64\n\n2. Change WSL2 version in Archlinuxwsl --set-version ArchLinux 2\n\nConfigurationBasic Configurationwsl -d Archlinuxrm /etc/resolv.confexit\n\nThe terminal window will be unavailable, so you should reopen a new terminal window, then:\nwsl --shutdown Archlinuxwsl -d Archlinuxcd /etcvi pacman.conf\n\nAdd following code in the end of pacman.conf:\n[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch\n\nAnd change the mirrorlist:\nvi ./pacman.d/mirrorlist\n\nRemove the comment of a Chinese source.\npacman -Syypacman-key --initpacman-key --populatepacman -S archlinuxcn-keyringpacman -S base base-devel vim git wgetpasswd # input the password of rootuseradd -m -G wheel -s /bin/bash &lt;username&gt;passwd &lt;username&gt;vim /etc/sudoers\n\nUse /wheel find the line wheel ALL=(ALL) ALL and remove the comment.\nid -u &lt;username&gt;exit\n\nExecute the command in powershell to set default user of Archlinux:\nlxrunoffline su -n Archlinux -v &lt;username&gt;\n\nInstall Ubuntu20.02 in WSL2wsl --list --online\t\t# 查看可直接安装的发行版列表# 显示如下：PS C:\\Windows\\system32&gt; wsl -l --onlineThe following is a list of valid distributions that can be installed.Install using &#x27;wsl.exe --install &lt;Distro&gt;&#x27;.NAME               FRIENDLY NAMEUbuntu             UbuntuDebian             Debian GNU/Linuxkali-linux         Kali Linux RollingSLES-12            SUSE Linux Enterprise Server v12SLES-15            SUSE Linux Enterprise Server v15Ubuntu-18.04       Ubuntu 18.04 LTSUbuntu-20.04       Ubuntu 20.04 LTSOracleLinux_8_5    Oracle Linux 8.5OracleLinux_7_9    Oracle Linux 7.9# 安装ubuntu 20.04wsl --install Ubuntu-20.04\n\n然后打开终端，打开ubuntu-20.04，创建用户和密码\n换源+更新\n然后安装anaconda\nInstall Anaconda on Ubuntuwget https://mirrors.bfsu.edu.cn/anaconda/archive/Anaconda3-5.3.0-Linux-x86_64.shchmod +x Anaconda3-5.3.0-Linux-x86_64.sh./Anaconda3-5.3.0-Linux-x86_64.shyesENTER\n\n安装完成之后，检查版本：\nanaconda -Vconda -V\n\n使用anaconda换源：\ncdvim .condarc\n\n编辑.condarc ，添加清华源\n# add to .condarcssl_verify: falsechannels:  - defaultsshow_channel_urls: truedefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n\n更新：\n conda update -n base -c defaults conda # 升级anaconda\n\nconda create -n myconda python=3.7 \t\t# 创建虚拟环境，名称为myconda（可以修改conda info --envs \t\t\t\t\t\t# 查看已安装的虚拟环境conda activate myconda\t\t\t\t\t# 激活环境mycondaconda deactivate\t\t\t\t\t\t# 关闭当前环境\n\nconda list\t\t\t\t# 查看conda的包pip list\t\t\t\t# 查看pip的包# 给pip换源  （也可以直接使用命令更换阿里源：# pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/cdmkdir .pipvim .pip/pip.conf# 添加以下内容#-----------------------------------------[global]index-url = https://mirrors.bfsu.edu.cn/pypi/web/simpleformat = columnstrusted-host = mirrors.bfsu.edu.cn#-----------------------------------------pip install jupyter \t# 安装jupyterjupyter notebook\t\t# 开启jupyter notebook服务\n\n附加配置systemd编辑 /etc/wsl.conf\n[boot]systemd=true\n\nWSL distros 的备份还原\n备份\n\nwsl -l -v# 显示为  NAME            STATE           VERSION* Ubuntu-20.04    Running         2wsl -t Ubuntu-20.04wsl --export Ubuntu-20.04 E:\\SystemBackup\\ubuntu-wsl2-2022.11.29.tar\n\n\n还原\n\nwsl --import &lt;distro-name&gt; &lt;install-path&gt; &lt;backup-file&gt;# e.g.wsl --import Ubuntu c:\\wsl2 d:\\save\\linux\\wsl2.tar\n\nWSL2-Ubuntu 安装 Qt5sudo apt install qt5* qtcreator\n\n创建项目时如果出现“no suitable kits”，点击“option”查看配置，如果“QT version”为“none”，则选择 /usr/lib/qt5/bin/qmake，保存即可。\n","categories":["经验与技巧与踩坑 · 杂项","Windows"],"tags":["Linux","Windows","WSL2"]},{"title":"Xpra on Linux 的安装与使用","url":"/2023/05/25/note/Linux/xpra/","content":"运行在浏览器上的远程桌面。\n\n\n安装archlinux\nsudo pacman -S xpra\n\nubuntu\nsudo apt install ca-certificatessudo wget -O &quot;/usr/share/keyrings/xpra-2022.gpg&quot; https://xpra.org/xpra-2022.gpgsudo wget -O &quot;/usr/share/keyrings/xpra-2018.gpg&quot; https://xpra.org/xpra-2018.gpg# For older distributions:wget -q https://xpra.org/xpra-2022.gpg -O- | sudo apt-key add -wget -q https://xpra.org/xpra-2018.gpg -O- | sudo apt-key add -cd /etc/apt/sources.list.d;wget https://xpra.org/repos/jammy/xpra.list # ubuntu 22.04 doesn&#x27;t workcd /etc/apt/sources.list.d;wget https://xpra.org/repos/focal/xpra.list # ubuntu 20.04apt update;apt install xpra\n\nCentOS\nsudo wget -O /etc/yum.repos.d/xpra.repo https://xpra.org/repos/CentOS/xpra.reposudo yum install -y xpra\n\n使用\n可以直接打开远程主机的程序\n\nxpra start ssh:user@host --exit-with-children --start-child=&lt;command&gt;\n\n\n可以开启服务监听，在远程浏览器上打开\n\nxpra start --bind-tcp=0.0.0.0:4000\n\n使用 systemd 设置 html5 服务开机自启编辑服务配置文件\nsudo vim /etc/systemd/system/xpra@.service\n\n为\n[Unit]Description=xpra-html5-server[Service]Type=simpleUser=%iEnvironmentFile=/etc/conf.d/xpraExecStart=/usr/bin/xpra --no-daemon start $&#123;%i&#125; --bind-tcp=0.0.0.0:4000[Install]WantedBy=multi-user.target\n\nNow create the configuration, adding a line for each username you want to have an xpra display:\nsudo vim /etc/conf.d/xpra# 添加dionysen=:7\n\n允许开机自启：\nsudo systemctl enable --now xpra@dionysen# 检查服务运行情况sudo systemctl status xpra@dionysen\n\n\n可能需要安装一个桌面环境（可以使用 Linux Note | Tome脚本最小安装）\n\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["xpra","x11-forward"]},{"title":"Set the new show menu bar in full screen option per-app","url":"/2025/10/04/note/Macos/window-fullscreen-with-menubar/","content":"刘海屏的MacBook，应用全屏时上面有一条黑色的空间，无法利用，要么显示菜单栏，要么让当前应用占用。\n\n\n显示菜单栏defaults write com.example.SomeApp AppleMenuBarVisibleInFullscreen -bool true\n\nTo revert\ndefaults delete com.example.SomeApp AppleMenuBarVisibleInFullscreen\n\n使用osascript -e &#39;id of app &quot;APPNAME&quot;&#39;来获取 App 的 bundle identifier。\n“XXX.app”已损坏，无法打开。 你应该将它移到废纸篓。sudo xattr -dr com.apple.quarantine /Applications/name.app\n\n","categories":["经验与技巧与踩坑 · 杂项","MacOS"],"tags":["VSCode","MacOS"]},{"title":"Windows相关技巧","url":"/2023/05/25/note/Windows/Windows10/","content":"\nWindows系统的一些技巧。\n\n\n\nwin10 修改系统显示字体下载FontCreator，用其打开需要替换的字体，选择字体-&gt;属性：\n\n\n然后将名字修改成Microsoft Yahei，然后进入PE系统，替换系统中的雅黑字体（msyh.ttc、msyhl.ttc、msyhbd.ttc三个文件）。\n\n\n修改输入法候选字的字体Win+r输入regedit打开注册表编辑器，找到如下：\nHKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\CandidateWindow\\CHS\\1\n\nFontStyle和FontStyleTSF3修改成想要的字体，如：\n\n\nWindows Access WSL2 FilesInput \\\\wsl$ in address bar of explorer.\nWin11 Restore Right-click Menu# To win10reg.exe add &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\\InprocServer32&quot; /f /ve# To win11reg.exe delete &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\\InprocServer32&quot; /va /f\n\n地址栏输入 chrome://flags 可以开启隐藏功能\nRealVNC 注册码Version: 6.11\n7SA9N-9JF3P-E8CW2-BH9JU-PMVQA\n\nGT620老显卡2K分辨率家里老古董，十年前的显卡，2K屏无法调成2K分辨率，先后买了DVI-24+1和DVI-24+5的线，都无法做到。强行在显卡设置里调整，字体发虚。\n最后在贴吧老哥的指点下，找到了设置2560x1440分辨率的办法。\n只需在显卡设置中创建自定义分辨率时将计时标准设置为GTF即可。\n（偶尔会有闪屏现象，但至少能用了）\nWindows终端使用代理\n🟢设置完成之后，如果代理未生效，则最好试试全局代理。\n\n$env:HTTP_PROXY = http://127.0.0.1:7890;\n\n使用google检测是否成功代理：\ncurl www.google.com\n\n便捷指令1.打开Profile文件\nif (!(Test-Path -Path $PROFILE )) &#123; New-Item -Type File -Path $PROFILE -Force &#125;notepad $PROFILE\n\n2.添加命令\n# Set-Proxy commandif ($env:HTTP_PROXY -ne $null)&#123;    Write-Output &quot;Proxy Enabled as $env:HTTP_PROXY&quot;;&#125;Function SetProxy() &#123;    Param(        # 改成自己的代理地址        $Addr = &#x27;http://127.0.0.1:7890&#x27;,        [switch]$ApplyToSystem    )    $env:HTTP_PROXY = $Addr;    $env:HTTPS_PROXY = $Addr;    $env:http_proxy = $Addr;    $env:https_proxy = $Addr;    [Net.WebRequest]::DefaultWebProxy = New-Object Net.WebProxy $Addr;    if ($ApplyToSystem) &#123;        $matchedResult = ValidHttpProxyFormat $Addr;        # Matched result: [URL Without Protocol][Input String]        if (-not ($matchedResult -eq $null)) &#123;            SetSystemProxy $matchedResult.1;        &#125;    &#125;    Write-Output &quot;Successful set proxy as $Addr&quot;;&#125;Function ClearProxy() &#123;    Param(        $Addr = $null,        [switch]$ApplyToSystem    )    $env:HTTP_PROXY = $Addr;    $env:HTTPS_PROXY = $Addr;    $env:http_proxy = $Addr;    $env:https_proxy = $Addr;    [Net.WebRequest]::DefaultWebProxy = New-Object Net.WebProxy;    if ($ApplyToSystem) &#123; SetSystemProxy $null; &#125;    Write-Output &quot;Successful unset all proxy variable&quot;;&#125;Function SetSystemProxy($Addr = $null) &#123;    Write-Output $Addr    $proxyReg = &quot;HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;;    if ($Addr -eq $null) &#123;        Set-ItemProperty -Path $proxyReg -Name ProxyEnable -Value 0;        return;    &#125;    Set-ItemProperty -Path $proxyReg -Name ProxyServer -Value $Addr;    Set-ItemProperty -Path $proxyReg -Name ProxyEnable -Value 1;&#125;Function ValidHttpProxyFormat ($Addr) &#123;    $regex = &quot;(?:https?:\\/\\/)(\\w+(?:.\\w+)*(?::\\d+)?)&quot;;    $result = $Addr -match $regex;    if ($result -eq $false) &#123;        throw [System.ArgumentException]&quot;The input $Addr is not a valid HTTP proxy URI.&quot;;    &#125;    return $Matches;&#125;Set-Alias set-proxy SetProxySet-Alias clear-proxy ClearProxy\n\n3.保存，重新打开PowerShell\n设置当前窗口代理 ：set-proxy\n设置当前窗口代理 + 系统代理：set-proxy -ApplyToSystem\n取消当前窗口代理：clear-proxy\n取消当前窗口代理 + 系统代理：clear-proxy -ApplyToSystem\nset-proxy和SetProxy，clear-proxy和ClearProxy可以互相替换.\nCMD设置代理仅当前控制台，关闭后失效。\nset http_proxy=http://127.0.0.1:19810set https_proxy=http://127.0.0.1:19810\n\nGit设置代理设置Http代理，永久生效\ngit config --global https.proxy https://127.0.0.1:19810git config --global http.proxy http://127.0.0.1:19810\n\n取消代理\ngit config --global --unset http.proxygit config --global --unset https.proxy\n\nPowerShell环境的执行策略错误：\n无法加载文件 C:\\Users\\zhaoys-c\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。所在位置 行:1 字符: 3+ . &#x27;C:\\Users\\zhaoys-c\\Documents\\WindowsPowerShell\\profile.ps1&#x27;+   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    + CategoryInfo          : SecurityError: (:) []，PSSecurityException        + FullyQualifiedErrorId : UnauthorizedAccess\n\n解决：\n\n以管理员身份打开PowerShell。这可以通过在开始菜单搜索栏中输入”PowerShell”，然后右键点击”Windows PowerShell”并选择”以管理员身份运行”来完成。\n\n检查当前的执行策略。输入以下命令并按回车键：\nGet-ExecutionPolicy\n\n如果执行策略是Restricted，你可以更改它为更宽松的策略，比如RemoteSigned或Unrestricted。RemoteSigned策略允许你运行本地脚本，但需要来自可信来源的远程脚本进行签名。Unrestricted策略允许运行所有脚本，但请注意这可能会带来安全风险。\n更改执行策略的命令如下：\nSet-ExecutionPolicy RemoteSigned\n\n或者\nSet-ExecutionPolicy Unrestricted\n\n执行这些命令时，你可能需要提供管理员密码。\n\n确认执行策略已更改。再次使用Get-ExecutionPolicy命令来查看新的执行策略。\n\n保存更改并关闭PowerShell。\n\n重新打开一个新的PowerShell窗口，然后尝试再次加载你的profile.ps1脚本。\n\n\nVisual Studio中文在别处是乱码因为Visual Studio的默认编码是GBK，而如VSCode或Sublime默认编码是UTF-8，因此将其转换成GBK编码，再保存为UTF-8。\nsublime中安装插件ConverrtToUTF-8，即可使用GBK编码打开文件。\n安装oh-my-posh\n官方文档：https://ohmyposh.dev/\n\n现在的oh-my-posh可以直接从Microsoft Store下载exe文件安装了，别去折腾命令行的命令了，速度太慢了。安装完成后，如果是windows系统，推荐Windows Terminal（没有的话在Microsoft Store里安装）下启动powershell。\n配置oh-my-posh过程中比较复杂的点就是Nerd Font和Themes这两点：\n1.Nerd Font去下面的网站下载一个名字里面带NF的字体，windows下直接安装，其他系统参照网站说明。\n\n下载地址：https://www.nerdfonts.com/\n\n2.Themes在Windows Terminal中输入：\nnotepad $PROFILE\n\n在打开的文件中填入以下代码后保存：\noh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\zash.omp.json&quot; | Invoke-Expression \n\n然后输入下面的命令，来让配置生效：\n.$PROFILE\n\n上面过程中zash是主题的一种，将zash换成想要的主题即可。\nGet-PoshThemes\n\n3.AutosuggestionWindows 里的 powershell 也可以做到，非常简单\n\n以管理员身份运行 powershell\n安装 PSReadLine\n\nInstall-Module PSReadLine -RequiredVersion 2.1.0\n\n\n重启 powershell\n初始化\n\nImport-Module PSReadLineSet-PSReadLineOption -PredictionSource History\n\n\nOK，完成，但重启后还需要再次初始化，所以把它加入配置文件里\n\nnotepad $PROFILE\n\n\n加入一行，保存并关闭\n\nSet-PSReadLineOption -PredictionSource History\n\n\n下次启动即可拥有 autosuggestion 能力\n\n进程查找与关闭tasklist | findstr &quot;xmake&quot;taskkill /F /PID 19052\n\n批量关闭所有包含xmake的进程：\n@echo offsetlocal enabledelayedexpansionecho Finding processes containing &quot;xmake&quot;...for /f &quot;tokens=2&quot; %%a in (&#x27;tasklist ^| findstr &quot;xmake&quot;&#x27;) do (    set pid=%%a    if not &quot;!pid!&quot;==&quot;&quot; (        echo Killing process with PID: !pid!        taskkill /F /PID !pid!    ))echo All found processes matching &quot;xmake&quot; have been requested to terminate.endlocal\n\n","categories":["经验与技巧与踩坑 · 杂项","Windows"],"tags":["Windows 10","Windows 11","Font"]},{"title":"基于Win32的OpenGL3.3","url":"/2023/06/29/note/Framework/OpenGL/Win32-OpenGL/","content":"在Win32的基础上，使用OpenGL v3.3，单个cpp文件完成：\n\n\n#include &lt;GL/glew.h&gt;#include &lt;Windows.h&gt;#include &lt;iostream&gt;// 着色器const char* vertexShaderSource   = &quot;#version 330 core\\n&quot;                                   &quot;layout (location = 0) in vec3 aPos;\\n&quot;                                   &quot;void main()\\n&quot;                                   &quot;&#123;\\n&quot;                                   &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot;                                   &quot;&#125;\\0&quot;;const char* fragmentShaderSource = &quot;#version 330 core\\n&quot;                                   &quot;out vec4 FragColor;\\n&quot;                                   &quot;void main()\\n&quot;                                   &quot;&#123;\\n&quot;                                   &quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot;                                   &quot;&#125;\\n\\0&quot;;// 回调函数的声明LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);// 入口函数int WINAPI WinMain(_In_ HINSTANCE hinstance, _In_opt_ HINSTANCE hPrevInstance, _In_ PSTR szCmdLine, _In_ int ICmdShow)&#123;    // 创建窗口类    WNDCLASSEX wndclass&#123;&#125;;    wndclass.cbSize        = sizeof(WNDCLASSEX);    wndclass.lpfnWndProc   = WndProc;    wndclass.hInstance     = GetModuleHandle(NULL);    wndclass.lpszClassName = &quot;Win32 Game Window&quot;;    // 注册窗口类    RegisterClassEx(&amp;wndclass);    // 获取屏幕分辨率    int ScreenWidth  = GetSystemMetrics(SM_CXSCREEN);    int ScreenHeight = GetSystemMetrics(SM_CYSCREEN);    int clientWidth  = 800;    int clientHeight = 600;    RECT windowRect;    // 设置窗口位置和大小    SetRect(&amp;windowRect, (ScreenWidth / 2) - (clientWidth / 2), (ScreenHeight / 2) - (clientHeight / 2), (ScreenWidth / 2) + (clientWidth / 2),            (ScreenHeight / 2) + (clientHeight / 2));    // 创建窗口    const char windowName[] = &quot;OpenGL Window&quot;;    HWND       hwnd         = CreateWindowEx(0, wndclass.lpszClassName, windowName, WS_OVERLAPPEDWINDOW, windowRect.left, windowRect.top,                                             windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, NULL, NULL, hinstance, szCmdLine);    // 获取设备上下文    HDC hdc = GetDC(hwnd);    // 设置像素格式    PIXELFORMATDESCRIPTOR pfd;    memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR));    pfd.nSize      = sizeof(PIXELFORMATDESCRIPTOR);    pfd.nVersion   = 1;    pfd.dwFlags    = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER;    pfd.iPixelType = PFD_TYPE_RGBA;    // 选择像素格式    int pixelFormat = ChoosePixelFormat(hdc, &amp;pfd);    SetPixelFormat(hdc, pixelFormat, &amp;pfd);    // 创建渲染上下文    HGLRC hglrc = wglCreateContext(hdc);    wglMakeCurrent(hdc, hglrc);    // 初始化Glew    if (glewInit() != GLEW_OK)    &#123;        std::cout &lt;&lt; &quot;Could not initialize GLEW \\n&quot;;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;OpenGL Version &quot; &lt;&lt; glewGetString(GLEW_VERSION) &lt;&lt; std::endl;    &#125;    // =======================================================================    // ================================= 创建渲染对象 ==========================    // =======================================================================    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);    glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);    glCompileShader(vertexShader);    // check for shader compile errors    int  success;    char infoLog[512];    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);    if (!success)    &#123;        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);        std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;    &#125;    // fragment shader    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);    glCompileShader(fragmentShader);    // check for shader compile errors    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);    if (!success)    &#123;        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);        std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;    &#125;    // link shaders    unsigned int shaderProgram = glCreateProgram();    glAttachShader(shaderProgram, vertexShader);    glAttachShader(shaderProgram, fragmentShader);    glLinkProgram(shaderProgram);    // check for linking errors    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);    if (!success)    &#123;        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);        std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;    &#125;    glDeleteShader(vertexShader);    glDeleteShader(fragmentShader);    // set up vertex data (and buffer(s)) and configure vertex attributes    // ------------------------------------------------------------------    float vertices[] = &#123;        -0.5f, -0.5f, 0.0f,  // left        0.5f,  -0.5f, 0.0f,  // right        0.0f,  0.5f,  0.0f   // top    &#125;;    GLuint VBO, VAO;    glGenVertexArrays(1, &amp;VAO);    glGenBuffers(1, &amp;VBO);    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).    glBindVertexArray(VAO);    glBindBuffer(GL_ARRAY_BUFFER, VBO);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);    glEnableVertexAttribArray(0);    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterwards    // we can safely unbind    glBindBuffer(GL_ARRAY_BUFFER, 0);    // You can unbind the VAO afterwards so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other    // VAOs requires a call to glBindVertexArray anyways so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.    glBindVertexArray(0);    // =======================================================================    // 显示窗口    ShowWindow(hwnd, SW_SHOW);    UpdateWindow(hwnd);    // 获取时间    DWORD lastTick = GetTickCount64();    MSG   msg;    // 渲染循环    while (true)    &#123;        if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))        &#123;            if (msg.message == WM_QUIT)            &#123;                break;            &#125;            TranslateMessage(&amp;msg);            DispatchMessage(&amp;msg);        &#125;        // 计算时间差        DWORD thisTick = GetTickCount64();        float dt       = float(thisTick - lastTick) * 0.001f;        lastTick       = thisTick;        // 获取窗口大小        RECT clientRect;        GetClientRect(hwnd, &amp;clientRect);        clientWidth  = clientRect.right - clientRect.left;        clientHeight = clientRect.bottom - clientRect.top;        // 设置视口        glViewport(0, 0, clientWidth, clientHeight);        glEnable(GL_DEPTH_TEST);        glEnable(GL_CULL_FACE);        glPointSize(5.0f);        // 清除颜色缓冲区        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);        // 使用着色器程序渲染        glUseProgram(shaderProgram);        glBindVertexArray(            VAO);  // seeing as we only have a single VAO there&#x27;s no need to bind it every time, but we&#x27;ll do so to keep things a bit more organized        glDrawArrays(GL_TRIANGLES, 0, 3);        // 交换缓冲区        SwapBuffers(hdc);        // 垂直同步        // if (vsynch != 0)        // &#123;        // \tglFinish();        // &#125;    &#125;    return (int)msg.wParam;&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)&#123;    switch (iMsg)    &#123;    case WM_CLOSE:        DestroyWindow(hwnd);        break;    case WM_DESTROY:        HDC   hdc   = GetDC(hwnd);        HGLRC hglrc = wglGetCurrentContext();        glBindVertexArray(0);        wglMakeCurrent(NULL, NULL);        wglDeleteContext(hglrc);        ReleaseDC(hwnd, hdc);        PostQuitMessage(0);        break;    &#125;    return DefWindowProc(hwnd, iMsg, wParam, lParam);&#125;\n\n使用着色器类：\n#include &quot;glad.h&quot;#include &quot;shader.h&quot;#include &lt;Windows.h&gt;#include &lt;iostream&gt;#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);#if _DEBUG#pragma comment(linker, &quot;/subsystem:console&quot;)int main(int argc, const char **argv)&#123;  return WinMain(GetModuleHandle(NULL), NULL, GetCommandLineA(), SW_SHOWDEFAULT);&#125;#else#pragma comment(linker, &quot;/subsystem:windows&quot;)#endif#pragma comment(lib, &quot;opengl32.lib&quot;)void initOpenGL()&#123;  Shader ourShader(&quot;C:\\\\Users\\\\zhaoys-c\\\\source\\\\repos\\\\Dionysen\\\\LearnOpenGL\\\\OpenGL\\\\\\\\OpenGL\\\\shaders\\\\shader.vs&quot;, &quot;C:\\\\Users\\\\zhaoys-c\\\\source\\\\repos\\\\Dionysen\\\\LearnOpenGL\\\\OpenGL\\\\\\\\OpenGL\\\\shaders\\\\shader.fs&quot;);  // Shader ourShader(&quot;../shaders/shader.vs&quot;,&quot;../shaders/shader.fs&quot;);  // set up vertex data (and buffer(s)) and configure vertex attributes  float vertices[] =      &#123;          // positions          // colors           // texture coords (note that we changed them to 2.0f!)          0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,   // top right          0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f,  // bottom right          -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom left          -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f   // top left      &#125;;  unsigned int indices[] =      &#123;          0, 1, 3, // first triangle          1, 2, 3  // second triangle      &#125;;  unsigned int VBO, VAO, EBO;  glGenVertexArrays(1, &amp;VAO);  glGenBuffers(1, &amp;VBO);  glGenBuffers(1, &amp;EBO);  glBindVertexArray(VAO);  glBindBuffer(GL_ARRAY_BUFFER, VBO);  glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void *)0);  glEnableVertexAttribArray(0);  glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void *)(3 * sizeof(float)));  glEnableVertexAttribArray(1);  glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void *)(6 * sizeof(float)));  glEnableVertexAttribArray(2);  unsigned int texture1, texture2;  glGenTextures(1, &amp;texture1);  glBindTexture(GL_TEXTURE_2D, texture1);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);  int width, height, nrChannels;  stbi_set_flip_vertically_on_load(true);  unsigned char *data = stbi_load(&quot;C:\\\\Users\\\\zhaoys-c\\\\source\\\\repos\\\\Dionysen\\\\LearnOpenGL\\\\OpenGL\\\\OpenGL\\\\Resources\\\\wall.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);  if (data)  &#123;    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);    glGenerateMipmap(GL_TEXTURE_2D);  &#125;  else  &#123;    std::cout &lt;&lt; &quot;Failed to load texture1&quot; &lt;&lt; std::endl;  &#125;  stbi_image_free(data);  glGenTextures(1, &amp;texture2);  glBindTexture(GL_TEXTURE_2D, texture2);  // set the texture wrapping parameters  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); // set texture wrapping to GL_REPEAT (default wrapping method)  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);  // set texture filtering parameters  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);  // load image, create texture and generate mipmaps  data = stbi_load(&quot;C:\\\\Users\\\\zhaoys-c\\\\source\\\\repos\\\\Dionysen\\\\LearnOpenGL\\\\OpenGL\\\\OpenGL\\\\Resources\\\\awesomeface.png&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);  if (data)  &#123;    // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);    glGenerateMipmap(GL_TEXTURE_2D);  &#125;  else  &#123;    std::cout &lt;&lt; &quot;Failed to load texture2&quot; &lt;&lt; std::endl;  &#125;  stbi_image_free(data);  ourShader.use();  glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0);  ourShader.setInt(&quot;texture2&quot;, 1);  // setting shader  ourShader.setFloat(&quot;visible&quot;, 0.1f);  ourShader.use();  // bind texture  glActiveTexture(GL_TEXTURE0);  glBindTexture(GL_TEXTURE_2D, texture1);  glActiveTexture(GL_TEXTURE1);  glBindTexture(GL_TEXTURE_2D, texture2);  // bind vao  glBindVertexArray(VAO);&#125;void render()&#123;  glClearColor(0.2f, 0.3f, 0.3f, 1.0f);  glClear(GL_COLOR_BUFFER_BIT);  glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);&#125;int WINAPI WinMain(_In_ HINSTANCE hinstance, _In_opt_ HINSTANCE hPrevInstance, _In_ PSTR szCmdLine, _In_ int ICmdShow)&#123;  WNDCLASSEX wndclass&#123;&#125;;  wndclass.cbSize = sizeof(WNDCLASSEX);  wndclass.style = 0;  wndclass.style = CS_HREDRAW | CS_VREDRAW; // ACTIVATES RELOAD ON REDRAW  wndclass.lpfnWndProc = WndProc;  wndclass.cbClsExtra = 0;  wndclass.cbWndExtra = 0;  wndclass.hInstance = hinstance;  wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);  wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);  wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);  wndclass.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);  wndclass.lpszMenuName = 0;  wndclass.lpszClassName = &quot;OpenGL Window&quot;;  RegisterClassEx(&amp;wndclass);  HWND hwnd = CreateWindowEx(      0,      wndclass.lpszClassName,      &quot;OpenGL Window&quot;,      WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_THICKFRAME,      CW_USEDEFAULT,      CW_USEDEFAULT, // 窗口左上角坐标为缺省值      CW_USEDEFAULT,      CW_USEDEFAULT, // 窗口的高度和宽度为缺省值      NULL,      NULL,      hinstance,      szCmdLine);  HDC hdc = GetDC(hwnd);  PIXELFORMATDESCRIPTOR pfd;  memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR));  pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);  pfd.nVersion = 1;  pfd.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER;  pfd.iPixelType = PFD_TYPE_RGBA;  pfd.cColorBits = 24;  pfd.cDepthBits = 32;  pfd.cStencilBits = 8;  int pixelFormat = ChoosePixelFormat(hdc, &amp;pfd);  SetPixelFormat(hdc, pixelFormat, &amp;pfd);  HGLRC hrc = wglCreateContext(hdc);  if (hrc)  &#123;    wglMakeCurrent(hdc, hrc);  &#125;  else  &#123;    std::cout &lt;&lt; &quot;ERROR::HRC::CREATE_FAILED\\n&quot;;  &#125;  if (!gladLoadGL())  &#123;    std::cout &lt;&lt; &quot;Could not initialize GLAD \\n&quot;;  &#125;  else  &#123;    std::cout &lt;&lt; &quot;OpenGL Version &quot; &lt;&lt; GLVersion.major &lt;&lt; std::endl;  &#125;  // Init OpenGL  initOpenGL();  // Shows window  ShowWindow(hwnd, SW_SHOW);  UpdateWindow(hwnd);  MSG msg;  while (true)  &#123;    if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))    &#123;      if (msg.message == WM_QUIT)      &#123;        break;      &#125;      TranslateMessage(&amp;msg);      DispatchMessage(&amp;msg);      render();      SwapBuffers(hdc);    &#125;  &#125;  return (int)msg.wParam;&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)&#123;  switch (iMsg)  &#123;  case WM_SIZE:    glViewport(0, 0, LOWORD(lParam), HIWORD(lParam));    // render();    break;  case WM_CLOSE:    DestroyWindow(hwnd);    break;  case WM_DESTROY:    HDC hdc = GetDC(hwnd);    HGLRC hglrc = wglGetCurrentContext();    glBindVertexArray(0);    wglMakeCurrent(NULL, NULL);    wglDeleteContext(hglrc);    ReleaseDC(hwnd, hdc);    PostQuitMessage(0);    break;  &#125;  return DefWindowProc(hwnd, iMsg, wParam, lParam);&#125;\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","OpenGL","Win32","Graphic","Computer"]},{"title":"基于Win32的OpenGL1.0","url":"/2023/06/29/note/Framework/OpenGL/Win32andOpenGL/","content":"使用win32原生API实现OpenGL，可以取代glut等第三方库。\n引自此博客。\n\n\n// 使用win32原生API实现OpenGL#include&lt;Windows.h&gt;#include&lt;gl/GL.h&gt;#pragma comment(lib, &quot;opengl32.lib&quot;)BOOL win32_regist_class(const char* class_name) // 注册win32窗口类&#123;\tWNDCLASSEXA cs =\t&#123;\t\tsizeof(WNDCLASSEXA),\t\tCS_HREDRAW | CS_VREDRAW,\t[](HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)-&gt;LRESULT\t\t&#123;\t\t\tswitch (msg) &#123;\t\t\tcase WM_NCCREATE:\t\t\t&#123;\t\t\t\tSetWindowLongPtrA(hwnd, GWLP_USERDATA, (LONG_PTR)((LPCREATESTRUCTA)lparam)-&gt;lpCreateParams);\t\t\t\tbreak;\t\t\t&#125;;\t\t\tcase WM_PAINT:\t\t\t&#123;\t\t\t\tPAINTSTRUCT ps;\t\t\t\tBeginPaint(hwnd, &amp;ps);\t\t\t\tEndPaint(hwnd, &amp;ps);\t\t\t\tbreak;\t\t\t&#125;\t\t\tcase WM_ERASEBKGND:\t\t\t&#123;\t\t\t\treturn TRUE;\t\t\t&#125;\t\t\tcase WM_DESTROY:\t\t\t&#123;\t\t\t\tPostQuitMessage(0);\t\t\t\tbreak;\t\t\t&#125;\t\t\tdefault:\t\t\t\tbreak;\t\t&#125;\t\t\treturn DefWindowProcA(hwnd, msg, wparam, lparam);\t\t&#125;,\t\t0,\t\t0,\t\t(HINSTANCE)GetModuleHandleA(nullptr),\t\tnullptr,\t\tLoadCursorA(nullptr,IDC_ARROW),\t\t(HBRUSH)COLOR_WINDOW,\t\tnullptr,\t\tclass_name,\t\tnullptr\t&#125;;\treturn RegisterClassExA(&amp;cs);&#125;// 创建win32窗口HWND win32_create(const char* class_name, const char* window_name, int x, int y, int width, int height)&#123;\treturn CreateWindowExA(0, class_name, window_name, WS_OVERLAPPEDWINDOW | WS_VISIBLE, x, y, width, height, nullptr, nullptr, GetModuleHandle(nullptr), nullptr);&#125;//获取可用于OpenGL绘制的DCHDC win32_get_gl_dc(HWND hwnd)&#123;\tPIXELFORMATDESCRIPTOR pfd = &#123;&#125;;\tpfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);\tpfd.nVersion = 1;\tpfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;\tauto hdc = GetDC(hwnd);\tauto pixelFormat = ChoosePixelFormat(hdc, &amp;pfd);\tif (!pixelFormat)\t&#123;\t\tReleaseDC(hwnd, hdc);\t\treturn nullptr;\t&#125;\tif (!SetPixelFormat(hdc, pixelFormat, &amp;pfd))\t&#123;\t\tReleaseDC(hwnd, hdc);\t\treturn nullptr;\t&#125;\treturn hdc;&#125;// 处理win32的消息BOOL win32_peek_message(HWND hwnd)&#123;\tMSG msg;\tif (PeekMessage(&amp;msg, hwnd, 0, 0, PM_REMOVE))\t&#123;\t\tif (msg.message == WM_QUIT)\t\t\treturn FALSE;\t\tTranslateMessage(&amp;msg);\t\tDispatchMessageA(&amp;msg);\t&#125;\treturn TRUE;&#125;// 创建OpenGL的APIHGLRC gl_create(HDC hdc)&#123;\tauto hglrc = wglCreateContext(hdc);\tif (!hglrc)\t\treturn nullptr;\tif (!wglMakeCurrent(hdc, hglrc))\t&#123;\t\treturn nullptr;\t&#125;\t// 这里只获取了glCreateShader作为例子\tauto glCreateShader = (GLuint(__stdcall*)(GLenum type))wglGetProcAddress(&quot;glCreateShader&quot;);\treturn hglrc;&#125;// 渲染void render(HWND hwnd, HDC hdc, HGLRC hglrc)&#123;\tRECT rc;\tGetClientRect(hwnd, &amp;rc);\twglMakeCurrent(hdc, hglrc);\tglViewport(0, 0, rc.right, rc.bottom);\tglClearColor(0.4f, 0.5f, 0.4f, 0);\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\tglBegin(GL_TRIANGLE_STRIP);\tglColor3f(1, 0, 0); glVertex2f(0.0f, 0.0f);\tglColor3f(0, 1, 0); glVertex2f(0.5f, 0.5f);\tglColor3f(0, 0, 1); glVertex2f(0.0f, 0.5f);\tglEnd();&#125;int main()&#123;\twin32_regist_class(&quot;test&quot;);\tauto hwnd = win32_create(&quot;test&quot;, &quot;test&quot;, 100, 100, 500, 400);\tauto hdc = win32_get_gl_dc(hwnd);\tauto hglrc = gl_create(hdc);\twhile (true)\t&#123;\t\tif (win32_peek_message(nullptr) == FALSE)\t\t\tbreak;\t\trender(hwnd, hdc, hglrc);\t\tSwapBuffers(wglGetCurrentDC());\t&#125;\treturn 0;&#125;\n\n基于Win32的OpenGL开发win32程序的框架是winMain+WndProc，前者创建窗口同时实现窗口循环，后者实现消息处理。\n如何在win32下使用OpenGL，窗口创建的过程中，哪一步加入OpenGL的扩展呢？\n窗口创建时，由WM_CREATE、WM_SIZE、WM_PAINT三个消息依次产生，在WM_CREATE中增加窗口对OpenGL支持的代码，同时对OpenGL渲染环境做初始化，然后在WM_SIZE中实现OpenGL视图的变换，这样OpenGL绘图的前置工作就已经做完了，在WM_PAINT中就可以进行渲染了。\n\n❗按照此博客的方法和代码跑不通\n\n另一个思路是，在窗口创建完成时创建OpenGL的渲染环境，在消息循环中渲染（此时的消息循环等同于OpenGL的窗口循环），然后在消息处理函数中处理WM_SIZE来适应窗口大小：（引自基于Win32的OpenGL开发初探）\n#include &lt;windows.h&gt;#include&lt;GL/glut.h&gt;void drawScene(HDC* hdc);void EnableOpenGL(HWND hWnd, HDC* hdc, HGLRC* hrc);void DisableOpenGL(HWND hWnd, HDC hdc, HGLRC hrc);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); //窗口函数声明int CALLBACK WinMain(HINSTANCE hInstance, //WinMain函数说明\tHINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) &#123;\tchar lpszClassName[] = &quot;Windows&quot;; //窗口类名\tchar lpszTitle[] = &quot;Win32 Window&quot;; //窗口标题名\tWNDCLASS wndclass;\twndclass.style = CS_HREDRAW | CS_VREDRAW; //窗口类型为缺省类型\twndclass.lpfnWndProc = WndProc; //窗口处理函数为WndProc\twndclass.cbClsExtra = 0; //窗口类无扩展\twndclass.cbWndExtra = 0; //窗口实例无扩展\twndclass.hInstance = hInstance; //当前实例句柄\twndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); //使用缺省图标\twndclass.hCursor = LoadCursor(NULL, IDC_ARROW); //窗口采用箭头光标\twndclass.hbrBackground = NULL; //窗口背景为白色\twndclass.lpszMenuName = NULL; //窗口中无菜单\twndclass.lpszClassName = lpszClassName; //窗口类名为&#x27;窗口实例&#x27;\tif (!RegisterClass(&amp;wndclass)) //注册窗口，若失败，则发出声音\t&#123;\t\tMessageBeep(0);\t\treturn FALSE;\t&#125;\t//创建窗口操作\tHWND hwnd = CreateWindow(\t\tlpszClassName, \t\tlpszTitle, //窗口实例的标题名\t\tWS_OVERLAPPEDWINDOW, //窗口的风格\t\tCW_USEDEFAULT,\t\tCW_USEDEFAULT, //窗口左上角坐标为缺省值\t\tCW_USEDEFAULT,\t\tCW_USEDEFAULT, //窗口的高度和宽度为缺省值\t\tNULL, //此窗口无父窗口\t\tNULL, //此窗口无主菜单\t\thInstance, //应用程序当前句柄\t\tNULL); //不使用该值\tShowWindow(hwnd, SW_SHOW); //显示窗口\tUpdateWindow(hwnd); //绘制用户区    \tHGLRC hRC; //绘制环境\tHDC hDC; //设备环境\tEnableOpenGL(hwnd, &amp;hDC, &amp;hRC);    \tMSG msg = &#123; 0 &#125;; //消息结构\twhile (GetMessage(&amp;msg, NULL, 0, 0)) //消息循环\t&#123;\t\tTranslateMessage(&amp;msg);\t\tDispatchMessage(&amp;msg);\t\tdrawScene(&amp;hDC);\t&#125;\tDisableOpenGL(hwnd, hDC, hRC);\treturn 0; //程序终止时，将信息返回操作系统&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) &#123;\tRECT rcClient;\tswitch (message) \t&#123;\t\tcase WM_CREATE: \t\t&#123;\t\t\treturn 0;\t\t&#125;\t\tbreak;\t\tcase WM_DESTROY:\t\t&#123;\t\t\tPostQuitMessage(0); //调用该函数发出WM_QUIT消息\t\t&#125;\t\tbreak;\t\tcase WM_SIZE:\t\t&#123;\t\t\tGetClientRect(hwnd, &amp;rcClient);\t\t\tint w = rcClient.right - rcClient.left;  // 获得客户区宽度\t\t\tint h = rcClient.bottom - rcClient.top;  // 获得客户区高度\t\t\tglViewport(0, 0, w, h);\t\t&#125;\t\tbreak;\t\tcase WM_TIMER:\t\t&#123;\t\t\tInvalidateRect(hwnd, NULL, FALSE);\t\t&#125;\t\tbreak;\t\tdefault: //缺省消息处理函数\t\t\treturn DefWindowProc(hwnd, message, wParam, lParam);\t&#125;\treturn DefWindowProc(hwnd, message, wParam, lParam);&#125;void drawScene(HDC* hdc) &#123;\tglClearColor(0.3f, 0.3f, 0.3f, 0.0f);\tglClear(GL_COLOR_BUFFER_BIT);\tglColor4f(1.0f, 0.0f, 0.0f, 0.0f);\tglBegin(GL_QUADS);\tglVertex3f(-0.6f, -0.6f, 0.0f);\tglVertex3f(0.6f, -0.6f, 0.0f);\tglVertex3f(0.6f, 0.6f, 0.0f);\tglVertex3f(-0.6f, 0.6f, 0.0f);\tglEnd();\tSwapBuffers(*hdc);\tSleep(1);&#125;void EnableOpenGL(HWND hwnd, HDC* hdc, HGLRC* hrc) &#123;\t*hdc = GetDC(hwnd);\tPIXELFORMATDESCRIPTOR pfd = &#123;\t\tsizeof(PIXELFORMATDESCRIPTOR),    // size of this pfd  \t\t1,                                // version number  \t\tPFD_DRAW_TO_WINDOW |              // support window  \t\tPFD_SUPPORT_OPENGL |              // support OpenGL  \t\tPFD_DOUBLEBUFFER,                 // double buffered  \t\tPFD_TYPE_RGBA,                    // RGBA type  \t\t24,                               // 24-bit color depth  \t\t0, 0, 0, 0, 0, 0,                 // color bits ignored  \t\t0,                                // no alpha buffer  \t\t0,                                // shift bit ignored  \t\t0,                                // no accumulation buffer\t\t0, 0, 0, 0,                       // accum bits ignored  \t\t32,                               // 32-bit z-buffer      \t\t0,                                // no stencil buffer  \t\t0,                                // no auxiliary buffer  \t\tPFD_MAIN_PLANE,                   // main layer  \t\t0,                                // reserved  \t\t0, 0, 0                           // layer masks ignored  \t&#125;;\tint iPixelFormat = ChoosePixelFormat(*hdc, &amp;pfd);\tSetPixelFormat(*hdc, iPixelFormat, &amp;pfd);\t// create and enable the render context (RC)\t*hrc = wglCreateContext(*hdc);\twglMakeCurrent(*hdc, *hrc);&#125;void DisableOpenGL(HWND hwnd, HDC hdc, HGLRC hrc) &#123;\twglMakeCurrent(nullptr, nullptr);\twglDeleteContext(hrc);\tReleaseDC(hwnd, hdc);&#125;\n\n运行结果如下：\n\n\n\n\n使用Win32调用GL#include &lt;Windows.h&gt;#include &lt;gl/GL.h&gt;#include &lt;iostream&gt;const unsigned int windowsWidth = 800;const unsigned int windowsHeight = 600;bool fullScreen = true;LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);int APIENTRY wWinMain(\t\t_In_     HINSTANCE hInstance,\t\t_In_opt_ HINSTANCE hPrevInstance,\t\t_In_     LPWSTR    lpCmdLine,\t\t_In_     int       nCmdShow)\t&#123;\tchar info_log[512]&#123;&#125;;\tchar lpszClassName[] = &quot;Windows&quot;; \tchar lpszTitle[] = &quot;Win32 Window&quot;; \tWNDCLASS wndclass&#123;&#125;;\twndclass.style = CS_HREDRAW | CS_VREDRAW; \twndclass.lpfnWndProc = WndProc; \twndclass.cbClsExtra = 0;\twndclass.cbWndExtra = 0; \twndclass.hInstance = hInstance; \twndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); \twndclass.hCursor = LoadCursor(NULL, IDC_ARROW); \twndclass.hbrBackground = NULL; \twndclass.lpszMenuName = NULL;\twndclass.lpszClassName = lpszClassName; \tif (!RegisterClass(&amp;wndclass)) \t&#123;\t\tMessageBeep(0);\t\treturn FALSE;\t&#125;\t\tHWND hwnd = CreateWindow(\t\tlpszClassName,\t\tlpszTitle, \t\tWS_OVERLAPPEDWINDOW, \t\tCW_USEDEFAULT,\t\tCW_USEDEFAULT, \t\twindowsWidth,\t\twindowsHeight, \t\tNULL, \t\tNULL, \t\thInstance, \t\tNULL); \t// create context\tHDC hDC = GetDC(hwnd);\tHGLRC hRC&#123;&#125;;\tif (hDC)\t&#123;\t\tint pixelFormat;\t\tPIXELFORMATDESCRIPTOR pixelFormatDesc;\t\t/* initialize bits to 0 */\t\tmemset(&amp;pixelFormatDesc, 0, sizeof(PIXELFORMATDESCRIPTOR));\t\tpixelFormatDesc.nSize = sizeof(PIXELFORMATDESCRIPTOR);\t\tpixelFormatDesc.nVersion = 1;\t\tpixelFormatDesc.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;\t\tpixelFormatDesc.iPixelType = PFD_TYPE_RGBA;\t\tpixelFormatDesc.cColorBits = 32;\t\tpixelFormatDesc.cAlphaBits = 8;\t\tpixelFormatDesc.cDepthBits = 24;\t\tpixelFormat = ChoosePixelFormat(hDC, &amp;pixelFormatDesc);\t\tif (pixelFormat)\t\t&#123;\t\t\tif (SetPixelFormat(hDC, pixelFormat, &amp;pixelFormatDesc))\t\t\t\thRC = wglCreateContext(hDC);\t\t&#125;\t&#125;\telse \t&#123;\t\tstd::cout &lt;&lt; &quot;ERROR::HDC::CREATE_FAILED\\n&quot; &lt;&lt; info_log &lt;&lt; std::endl;\t&#125;\tif (hRC) &#123;  // 待看\t\twglMakeCurrent(hDC, hRC);\t&#125;\telse\t&#123;\t\tstd::cout &lt;&lt; &quot;ERROR::HRC::CREATE_FAILED\\n&quot; &lt;&lt; info_log &lt;&lt; std::endl;\t&#125;\tShowWindow(hwnd, SW_SHOW);\tUpdateWindow(hwnd);\t//if (!gladLoadGL())\t//&#123;\t//\tstd::cout &lt;&lt; &quot;Could not initialize GLAD \\n&quot;;\t//&#125;\t//else &#123;\t//\tstd::cout &lt;&lt; &quot;OpenGL Version &quot; &lt;&lt; GLVersion.major &lt;&lt; std::endl;\t//&#125;\tMSG msg = &#123; 0 &#125;;\twhile (GetMessage(&amp;msg, NULL, 0, 0)) \t&#123;\t\tTranslateMessage(&amp;msg);\t\tDispatchMessage(&amp;msg);\t&#125;\twglMakeCurrent(hDC, NULL);\twglDeleteContext(hRC);\tif(hDC!=NULL)\t\tReleaseDC(hwnd, hDC);\treturn 0;&#125;static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) &#123;\tLRESULT result = 0;\tswitch (msg)\t&#123;\tcase WM_PAINT:\t\tPAINTSTRUCT ps;\t\t//render();\t\tglClear(GL_COLOR_BUFFER_BIT);\t\tglBegin(GL_TRIANGLES);\t\tglColor3f(1.0f, 0.0f, 0.0f);\t\tglVertex2i(0, 1);\t\tglColor3f(0.0f, 1.0f, 0.0f);\t\tglVertex2i(-1, -1);\t\tglColor3f(0.0f, 0.0f, 1.0f);\t\tglVertex2i(1, -1);\t\tglEnd();\t\tglFlush();\t\tBeginPaint(hwnd, &amp;ps);\t\tEndPaint(hwnd, &amp;ps);\t\tbreak;\tcase WM_SIZE:\t\tglViewport(0, 0, LOWORD(lParam), HIWORD(lParam));\t\tbreak;\tcase WM_KEYDOWN:\t\t/* ESC: Escape */\t\tif (wParam == 27)\t\t\tPostMessage(hwnd, WM_CLOSE, 0, 0);\t\t/* F11: Fullscreen */\t\telse if (wParam == 122)\t\t&#123;\t\t\tDWORD style = GetWindowLong(hwnd, GWL_STYLE);\t\t\tstatic int windowX, windowY, windowWidth, windowHeight = &#123; 0 &#125;;\t\t\tif (fullScreen) &#123;\t\t\t\tRECT rect;\t\t\t\tMONITORINFO mi = &#123; sizeof(mi) &#125;;\t\t\t\tGetWindowRect(hwnd, &amp;rect);\t\t\t\twindowX = rect.left;\t\t\t\twindowY = rect.top;\t\t\t\twindowWidth = rect.right - rect.left;\t\t\t\twindowHeight = rect.bottom - rect.top;\t\t\t\tGetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY), &amp;mi);\t\t\t\tSetWindowLong(hwnd, GWL_STYLE, style &amp; ~WS_OVERLAPPEDWINDOW);\t\t\t\tSetWindowPos(hwnd, HWND_TOP, mi.rcMonitor.left, mi.rcMonitor.top,\t\t\t\t\tmi.rcMonitor.right - mi.rcMonitor.left,\t\t\t\t\tmi.rcMonitor.bottom - mi.rcMonitor.top,\t\t\t\t\tSWP_NOOWNERZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW);\t\t\t&#125;\t\t\telse \t\t\t&#123;\t\t\t\tMONITORINFO mi = &#123; sizeof(mi) &#125;;\t\t\t\tUINT flags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW;\t\t\t\tGetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY), &amp;mi);\t\t\t\tSetWindowLong(hwnd, GWL_STYLE, style | WS_OVERLAPPEDWINDOW);\t\t\t\tSetWindowPos(hwnd, HWND_NOTOPMOST, windowX, windowY, windowWidth, windowHeight, flags);\t\t\t&#125;\t\t\tfullScreen = !fullScreen;\t\t&#125;\t\tbreak;\tcase WM_CLOSE:\t\tDestroyWindow(hwnd);\t\tPostQuitMessage(0);\t\tbreak;\tdefault:\t\tresult = DefWindowProc(hwnd, msg, wParam, lParam);\t&#125;\treturn result;&#125;\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","OpenGL","Win32","Graphic","Computer"]},{"title":"在ArchLinux上编译Ogre","url":"/2023/07/14/note/Framework/OpenGL/ogre_compile/","content":"Ogre（Object-oriented Graphics Rendering Engine）是一个开源的实时图形渲染引擎，用于创建和渲染三维图形应用程序。它是基于C++编写的，并提供了丰富的功能和工具，使开发者能够构建高性能的图形应用程序。\n\n\n\n\n特点和功能：\n\n\n跨平台支持：Ogre是一个跨平台的引擎，支持在多个操作系统（如Windows、Linux、macOS等）上进行开发和部署。\n高性能渲染：Ogre通过使用现代图形硬件和优化算法，提供了高效的图形渲染。它支持多种渲染路径（如Direct3D和OpenGL），并针对不同平台和硬件提供了灵活的渲染配置。\n强大的渲染功能：Ogre提供了广泛的渲染功能，包括高级材质系统、灯光和阴影、粒子系统、骨骼动画、精确的几何剪裁等。这些功能使开发者能够创建出逼真和令人惊叹的图形效果。\n可扩展性和模块化：Ogre的设计注重可扩展性和模块化。它提供了丰富的插件系统，可以方便地添加和定制功能。开发者可以选择性地集成和使用不同的模块，以满足其特定的需求。\n资源管理和场景图：Ogre提供了资源管理器，用于加载和管理图形资源（如模型、纹理、材质等）。它还包括一个场景图系统，用于组织和渲染场景中的对象。\n多种编程语言支持：尽管Ogre是使用C++编写的，但它提供了多种语言的绑定和接口，包括Python、C#、Java等。这样可以方便开发者使用自己熟悉的编程语言来开发和扩展Ogre应用程序。\n\nOgre作为一个成熟且广泛应用的图形渲染引擎，被用于游戏开发、虚拟现实、模拟器、科学可视化等领域。它拥有一个活跃的社区，并提供了丰富的文档、示例和教程，以帮助开发者入门和使用Ogre引擎。\n在ArchLinux上编译Ogre安装依赖By default ogre will build the recommended dependencies automatically when you run cmake configure the first time. Ogre will install the dependencies into the subfolder Dependencies in the build dir by default. You can configure it by setting OGRE_DEPENDENCIES_DIR in cmake.\n\n文档的意思是Ogre会在配置cmake的时候自动安装依赖\n\n拉取源码git clone https://github.com/OGRECave/ogre.git\n\n配置cmakecd ogremkdir buildcd buildcmake ..\n\n编译cmake --build . --config Release\n\n安装到系统中想要使用它，最好将头文件和库文件放置到干净的地方。\ncmake --build . --config Release --target install\n\n你可能需要root权限才能完成这个操作。\n测试使用官方示例：\n// This file is part of the OGRE project.// It is subject to the license terms in the LICENSE file found in the top-level// directory of this distribution and at https://www.ogre3d.org/licensing.// SPDX-License-Identifier: MIT#include &quot;Ogre.h&quot;#include &quot;OgreApplicationContext.h&quot;//! [key_handler]class KeyHandler : public OgreBites::InputListener &#123;    bool keyPressed(const OgreBites::KeyboardEvent &amp;evt) override &#123;        if (evt.keysym.sym == OgreBites::SDLK_ESCAPE) &#123;            Ogre::Root::getSingleton().queueEndRendering();        &#125;        return true;    &#125;&#125;;//! [key_handler]int main(int argc, char *argv[]) &#123;    //! [constructor]    OgreBites::ApplicationContext ctx(&quot;OgreTutorialApp&quot;);    ctx.initApp();    //! [constructor]    //! [setup]    // get a pointer to the already created root    Ogre::Root *root = ctx.getRoot();    // root-&gt;createRenderWindow(&quot;w&quot;,800,600,false,0);    Ogre::SceneManager *scnMgr = root-&gt;createSceneManager();    // register our scene with the RTSS    Ogre::RTShader::ShaderGenerator *shadergen =        Ogre::RTShader::ShaderGenerator::getSingletonPtr();    shadergen-&gt;addSceneManager(scnMgr);    // without light we would just get a black screen    Ogre::Light *light = scnMgr-&gt;createLight(&quot;MainLight&quot;);    Ogre::SceneNode *lightNode =        scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();    lightNode-&gt;setPosition(0, 15, 25);    lightNode-&gt;attachObject(light);    // also need to tell where we are    Ogre::SceneNode *camNode =        scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();    camNode-&gt;setPosition(50, 50, 50);    camNode-&gt;lookAt(Ogre::Vector3(0, 0, -1), Ogre::Node::TS_PARENT);    // create the camera    Ogre::Camera *cam = scnMgr-&gt;createCamera(&quot;myCam&quot;);    cam-&gt;setNearClipDistance(5); // secific to this sample    cam-&gt;setAutoAspectRatio(true);    camNode-&gt;attachObject(cam);    // and tell it to render into the main window    ctx.getRenderWindow()-&gt;addViewport(cam);    // finally something to render    Ogre::Entity *ent = scnMgr-&gt;createEntity(&quot;ogrehead.mesh&quot;);    Ogre::SceneNode *node = scnMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode();    node-&gt;attachObject(ent);    //! [setup]    //! [main]    // register for input events    KeyHandler keyHandler;    ctx.addInputListener(&amp;keyHandler);    ctx.getRoot()-&gt;startRendering();    ctx.closeApp();    //! [main]    return 0;&#125;\n\nCMakeLists.txt文件如下：\ncmake_minimum_required (VERSION 3.10)project(OgreTutorialsSample)# required for Ogre 1.11+set(CMAKE_CXX_STANDARD 11)## [discover_ogre]# The COMPONENTS part checks that OGRE was built the way we need it# The CONFIG flag makes sure we get OGRE instead of OGRE-nextfind_package(OGRE REQUIRED COMPONENTS Bites CONFIG)set(CMAKE_EXPORT_COMPILE_COMMANDS ON)set(CMAKE_BUILD_TYPE debug)# add the source files as usualadd_executable(0_Bootstrap Bootstrap.cpp)# this also sets the includes and pulls third party dependenciestarget_link_libraries(0_Bootstrap OgreBites)\n\n文件结构：\n.├── Bootstrap.cpp├── build└── CMakeLists.txt\n\n运行命令:\ncd buildcmake ..; make; ./0_Bootstrap\n\n结果：\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","OpenGL","Graphic","Computer"]},{"title":"OpenGL-2 基础","url":"/2023/07/01/note/Framework/OpenGL/opengl-basic/","content":"\n着色器需要用特定的语言编写，GLSL是一种类C的语言，专门用来写着色器程序。\n\n程序结构： \n\n声明版本\n输入和输出变量\nuniform和main函数\n\n\n\n着色器一个典型的着色器：\n#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main()&#123;  // 处理输入并进行一些图形操作  ...  // 输出处理过的结果到输出变量  out_variable_name = weird_stuff_we_processed;&#125;\n\n对于顶点着色器，输入变量即顶点属性。\n能声明的顶点属性是有上限的，一般由硬件来决定。\n你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限：\nint nrAttributes;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);std::cout &lt;&lt; &quot;Maximum nr of vertex attributes supported: &quot; &lt;&lt; nrAttributes &lt;&lt; std::endl;\n\n\n通常情况下它至少会返回16个，大部分情况下是够用了。\n\n变量GLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。GLSL也有两种容器类型，分别是向量(Vector)和矩阵(Matrix)。\n向量GLSL中的向量是一个可以包含有2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n代表分量的数量）：\n\n\n\n类型\n含义\n\n\n\nvecn\n包含n个float分量的默认向量（因为float是默认的数据类型）\n\n\nbvecn\n包含n个bool分量的向量\n\n\nivecn\n包含n个int分量的向量\n\n\nuvecn\n包含n个unsigned int分量的向量\n\n\ndvecn\n包含n个double分量的向量\n\n\n多数情况使用vecn，这样已经够用了。\n一个向量的分量可以通过vec.x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用.x、.y、.z和.w来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用rgba，或是对纹理坐标使用stpq访问相同的分量。\n向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：\nvec2 someVec;vec4 differentVec = someVec.xyxx;vec3 anotherVec = differentVec.zyw;vec4 otherVec = someVec.xxxx + anotherVec.yxzy;\n\n输入与输出GLSL定义了in和out关键字专门来实现输入和输出。\nlayout (location = 0)定义一个标识，这样才能链接到顶点数据。\n\n你也可以忽略layout (location = 0)标识符，通过在OpenGL代码中使用glGetAttribLocation查询属性位置值(Location)，但着色器中设置它们会更容易理解而且节省你（和OpenGL）的工作量。\n\n片段着色器，它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。\n如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。\n如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。\n顶点着色器\n#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0out vec4 vertexColor; // 为片段着色器指定一个颜色输出void main()&#123;    gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色&#125;\n\n片段着色器\n#version 330 coreout vec4 FragColor;in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）void main()&#123;    FragColor = vertexColor;&#125;\n\n顶点着色器中声明了一个vertexColor变量作为vec4输出，并在片段着色器中声明了一个类似的vertexColor。由于它们名字相同且类型相同，片段着色器中的vertexColor就和顶点着色器中的vertexColor链接了。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。\n结果如下：\n\n\nUniformUniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。\nuniform是全局的(Global)。\n\nuniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。\n\n无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。\n\n\n#version 330 coreout vec4 FragColor;uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量void main()&#123;    FragColor = ourColor;&#125;\n\n定义了一个uniform的vec4，即ourColor，并且把片段着色器的输出颜色设置为uniform的值，之后无需再通过顶点着色器修改它，而可以直接在程序中修改：\nfloat timeValue = glfwGetTime(); // 获取运行的秒数float greenValue = (sin(timeValue) / 2.0f) + 0.5f;  // 使用sin函数让颜色从0-1之间变化，结果储存在greenValue中int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;); // 通过函数glGetUniformLocation查询uniform ourColor的位置值，找不到返回-1glUseProgram(shaderProgram);glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); // 设置uniform的值\n\n注意：查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你必须先使用程序（调用glUseProgram())，因为它是在当前激活的着色器程序中设置uniform的。\n\n❗如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！\n\n修改后的全部源码为：\n#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height); //回调函数的声明void processInput(GLFWwindow* window); // 处理对窗口的输入const char *vertexShaderSource = &quot;#version 330 core\\n&quot;    &quot;layout (location = 0) in vec3 aPos;\\n&quot;    &quot;void main()\\n&quot;    &quot;&#123;\\n&quot;        &quot;gl_Position = vec4(aPos, 1.0);\\n&quot;    &quot;&#125;\\n\\0&quot;;// 创建片段着色器程序的源码，使用c风格的常量字符串存储const char* fragmentShaderSource =    &quot;#version 330 core\\n&quot;    &quot;out vec4 FragColor;\\n&quot;    &quot;uniform vec4 ourColor;\\n&quot;    &quot;void main() &#123;\\n&quot;        //&quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot; // 此处设置片段颜色为黄色        &quot;FragColor = ourColor;\\n&quot;    &quot;&#125;\\n\\0&quot;;int main(void) &#123;    // -------------- 1. glfw的初始化 ----------------    if (!glfwInit()) &#123;        return -1;    &#125;    // --------------- 2. 使用glfw创建窗口 ---------------    GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);    if (window == NULL) &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    &#125;    glfwMakeContextCurrent(window); // 此函数使指定窗口的 OpenGL 或 OpenGL ES 上下文成为调用线程的当前上下文    glfwSetFramebufferSizeCallback(        window,        framebuffer_size_callback); // 回调函数，保证每次窗口大小调整时，重新绘制    // --------------- 3. glad：加载OpenGL所有的函数指针 ---------------    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;        return -1;    &#125;    // --------------- 4. 创建和编译着色器 ---------------    unsigned int vertexShader; // 创建顶点着色器索引    vertexShader = glCreateShader(GL_VERTEX_SHADER); // 创建顶点着色器    glShaderSource(        vertexShader, 1, &amp;vertexShaderSource,        NULL); // 为顶点着色器添加源码，第二个参数是添加的源码中字符串的数量，第三个先设置为NULL    glCompileShader(vertexShader); // 编译顶点着色器    int success;        // 创建编译状态指示变量    char info_log[512]; // 创建用以存储log的数组    glGetShaderiv(vertexShader, GL_COMPILE_STATUS,        &amp;success); // 获取状态和log，输出到变量和数组中    if (!success) &#123;          // 如果编译失败，打印错误信息和log        glGetShaderInfoLog(vertexShader, 512, NULL, info_log);        std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot;            &lt;&lt; info_log &lt;&lt; std::endl;    &#125;    unsigned int fragmentShader;    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);    glCompileShader(fragmentShader);    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS,        &amp;success); // 获取状态和log，输出到变量和数组中    if (!success) &#123;          // 如果编译失败，打印错误信息和log        glGetShaderInfoLog(fragmentShader, 512, NULL, info_log);        std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n&quot;            &lt;&lt; info_log &lt;&lt; std::endl;    &#125;    // --------------- 5. 链接着色器 ---------------    unsigned int shaderProgram;    shaderProgram = glCreateProgram();    // 把着色器添加到着色器程序中    glAttachShader(shaderProgram, vertexShader);    glAttachShader(shaderProgram, fragmentShader);    glLinkProgram(shaderProgram); // 链接着色器程序    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); // 异常检测    if (!success) &#123;        glGetProgramInfoLog(shaderProgram, 512, NULL, info_log);        std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINK_FAILED\\n&quot;            &lt;&lt; info_log &lt;&lt; std::endl;    &#125;    glUseProgram(        shaderProgram); // 调用此函数后，渲染和着色器调用都会使用此前所写的着色器了    glDeleteShader(vertexShader);    glDeleteShader(fragmentShader); // 链接完成之后就可以删除着色器了    // --------------- 6. 创建顶点数据缓冲区 ---------------    float vertices[] =    &#123;         -0.5f, -0.5f, 0.0f,  // left        0.5f, -0.5f, 0.0f,  // right        0.0f, 0.5f, 0.0f     &#125;; // top    unsigned int VBO, VAO;    glGenVertexArrays(1, &amp;VAO);    glGenBuffers(1, &amp;VBO);              // 创建缓冲区    glBindVertexArray(VAO);    glBindBuffer(GL_ARRAY_BUFFER, VBO); // 绑定缓冲区    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // -------- 告诉GPU如何读取顶点数据 ----------    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float),        (void*)0);    glEnableVertexAttribArray(0); // 启用顶点属性    glBindVertexArray(VAO);    // --------------- 7. 窗口绘制循环 ---------------    while (!glfwWindowShouldClose(window)) &#123;        // input        // -----        processInput(window);        // render        // -----        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);            glUseProgram(shaderProgram);        // 更新uniform颜色        float timeValue = glfwGetTime();        float greenValue = static_cast&lt;float&gt;(sin(timeValue) / 2.0 + 0.5);        int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);        glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);        glDrawArrays(GL_TRIANGLES, 0, 3);        //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);        glfwSwapBuffers(window);        glfwPollEvents();    &#125;    // glfw: terminate, clearing all previously allocated GLFW resources.    glDeleteVertexArrays(1, &amp;VAO);    glDeleteBuffers(1, &amp;VBO);    glDeleteProgram(shaderProgram);    glfwTerminate();    return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this// frame and react accordingly// -----------------------void processInput(GLFWwindow* window) &#123;    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)        glfwSetWindowShouldClose(window, true);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback// function executes// ----------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height) &#123;    // make sure the viewport matches the new window dimensions; note that width    // and height will be significantly larger than specified on retina    // displays.    glViewport(0, 0, width, height);&#125;\n\n运行结果为一个三角形，颜色在绿色和黑色之间周期性变换：\n\n\n\n\n更多属性把颜色数据添加为3个float值至vertices数组，把三角形的三个角分别指定为红色、绿色和蓝色：\nfloat vertices[] = &#123;    // 位置              // 颜色     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部&#125;;\n\n由于现在有更多的数据要发送到顶点着色器，有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是用layout标识符来把aColor属性的位置值设置为1：\n#version 330 corelayout (location = 0) in vec3 aPos;   // 位置变量的属性位置值为 0 layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1out vec3 ourColor; // 向片段着色器输出一个颜色void main()&#123;    gl_Position = vec4(aPos, 1.0);    ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色&#125;\n\n不再使用uniform来传递片段的颜色了，现在使用ourColor输出变量，必须再修改一下片段着色器：\n#version 330 coreout vec4 FragColor;  in vec3 ourColor;void main()&#123;    FragColor = vec4(ourColor, 1.0);&#125;\n\n更新一下顶点格式：\nunsigned int VBO, VAO;glGenVertexArrays(1, &amp;VAO);glGenBuffers(1, &amp;VBO);              // 创建缓冲区glBindVertexArray(VAO);glBindBuffer(GL_ARRAY_BUFFER, VBO); // 绑定缓冲区glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// -------- 告诉GPU如何读取顶点数据 ----------glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); // 启用顶点属性glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float))); // 最后一个是偏移量，因为前面的是位置，后面的是颜色glEnableVertexAttribArray(1);glUseProgram(shaderProgram);\n\n绘制：\nwhile (!glfwWindowShouldClose(window)) &#123;    // input    // -----    processInput(window);    // render    // -----    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);    glClear(GL_COLOR_BUFFER_BIT);    glBindVertexArray(VAO);    glDrawArrays(GL_TRIANGLES, 0, 3);    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);    glfwSwapBuffers(window);    glfwPollEvents();&#125;\n\n结果为：\n\n只给定了三个位置和三个颜色，却出现了一个类似于调色一样的东西，这是因为光栅化阶段会进行插值，生成比给定的顶点多得多的顶点，比如可能由上万个。\n着色器类主要是读取着色器程序的源码，编译，创建着色器程序，链接，有一个使用着色器的函数。\n#ifndef SHADER_H#define SHADER_H#include &lt;glad/glad.h&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;class Shader&#123;public:    unsigned int ID;    // constructor generates the shader on the fly    // ------------------------------------------------------------------------    Shader(const char* vertexPath, const char* fragmentPath)    &#123;        // 1. retrieve the vertex/fragment source code from filePath        std::string vertexCode;        std::string fragmentCode;        std::ifstream vShaderFile;        std::ifstream fShaderFile;        // ensure ifstream objects can throw exceptions:        vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);        fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);        try         &#123;            // open files            vShaderFile.open(vertexPath);            fShaderFile.open(fragmentPath);            std::stringstream vShaderStream, fShaderStream;            // read file&#x27;s buffer contents into streams            vShaderStream &lt;&lt; vShaderFile.rdbuf();            fShaderStream &lt;&lt; fShaderFile.rdbuf();            // close file handlers            vShaderFile.close();            fShaderFile.close();            // convert stream into string            vertexCode   = vShaderStream.str();            fragmentCode = fShaderStream.str();        &#125;        catch (std::ifstream::failure&amp; e)        &#123;            std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        &#125;        const char* vShaderCode = vertexCode.c_str();        const char * fShaderCode = fragmentCode.c_str();        // 2. compile shaders        unsigned int vertex, fragment;        // vertex shader        vertex = glCreateShader(GL_VERTEX_SHADER);        glShaderSource(vertex, 1, &amp;vShaderCode, NULL);        glCompileShader(vertex);        checkCompileErrors(vertex, &quot;VERTEX&quot;);        // fragment Shader        fragment = glCreateShader(GL_FRAGMENT_SHADER);        glShaderSource(fragment, 1, &amp;fShaderCode, NULL);        glCompileShader(fragment);        checkCompileErrors(fragment, &quot;FRAGMENT&quot;);        // shader Program        ID = glCreateProgram();        glAttachShader(ID, vertex);        glAttachShader(ID, fragment);        glLinkProgram(ID);        checkCompileErrors(ID, &quot;PROGRAM&quot;);        // delete the shaders as they&#x27;re linked into our program now and no longer necessary        glDeleteShader(vertex);        glDeleteShader(fragment);    &#125;    // activate the shader    // ------------------------------------------------------------------------    void use()     &#123;         glUseProgram(ID);     &#125;    // utility uniform functions    // ------------------------------------------------------------------------    void setBool(const std::string &amp;name, bool value) const    &#123;                 glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);     &#125;    // ------------------------------------------------------------------------    void setInt(const std::string &amp;name, int value) const    &#123;         glUniform1i(glGetUniformLocation(ID, name.c_str()), value);     &#125;    // ------------------------------------------------------------------------    void setFloat(const std::string &amp;name, float value) const    &#123;         glUniform1f(glGetUniformLocation(ID, name.c_str()), value);     &#125;private:    // utility function for checking shader compilation/linking errors.    // ------------------------------------------------------------------------    void checkCompileErrors(unsigned int shader, std::string type)    &#123;        int success;        char infoLog[1024];        if (type != &quot;PROGRAM&quot;)        &#123;            glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success);            if (!success)            &#123;                glGetShaderInfoLog(shader, 1024, NULL, infoLog);                std::cout &lt;&lt; &quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot; &lt;&lt; type &lt;&lt; &quot;\\n&quot; &lt;&lt; infoLog &lt;&lt; &quot;\\n -- --------------------------------------------------- -- &quot; &lt;&lt; std::endl;            &#125;        &#125;        else        &#123;            glGetProgramiv(shader, GL_LINK_STATUS, &amp;success);            if (!success)            &#123;                glGetProgramInfoLog(shader, 1024, NULL, infoLog);                std::cout &lt;&lt; &quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot; &lt;&lt; type &lt;&lt; &quot;\\n&quot; &lt;&lt; infoLog &lt;&lt; &quot;\\n -- --------------------------------------------------- -- &quot; &lt;&lt; std::endl;            &#125;        &#125;    &#125;&#125;;#endif\n\n使用着色器时，要用绝对路径。\n纹理纹理坐标的范围通常是从(0, 0)到(1, 1)，超出部分可以设置环绕方式：\n\n\n\n环绕方式\n描述\n\n\n\nGL_REPEAT\n对纹理的默认行为。重复纹理图像。\n\n\nGL_MIRRORED_REPEAT\n和GL_REPEAT一样，但每次重复图片是镜像放置的。\n\n\nGL_CLAMP_TO_EDGE\n纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。\n\n\nGL_CLAMP_TO_BORDER\n超出的坐标为用户指定的边缘颜色。\n\n\n\n纹理的生成过程加载stb_image库\n#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot;\n\n添加一个纹理\nunsigned int textureID;glGenTextures(1, &amp;textureID);int width, height, nrComponents;unsigned char* data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0);if (data)&#123;    GLenum format = &#123;&#125;;    if (nrComponents == 1)        format = GL_RED;    else if (nrComponents == 3)        format = GL_RGB;    else if (nrComponents == 4)        format = GL_RGBA;    glBindTexture(GL_TEXTURE_2D, textureID);    glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);    glGenerateMipmap(GL_TEXTURE_2D);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    stbi_image_free(data);&#125;else&#123;    std::cout &lt;&lt; &quot;Texture failed to load at path: &quot; &lt;&lt; path &lt;&lt; std::endl;    stbi_image_free(data);&#125;\n\n此时纹理对象储存在一个可以通过textureID找到的地方。在顶点着色器中传入纹理桌标，再传给片段着色器：\n#version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;uniform sampler2D ourTexture;void main()&#123;    FragColor = texture(ourTexture, TexCoord);&#125;\n\n片段着色器是通过采样器访问纹理对象的。\n采样器(Sampler) ：它以纹理类型作为后缀，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。我们可以简单声明一个uniform sampler2D把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。\n用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。\nglBindTexture(GL_TEXTURE_2D, texture);\n\n绘制图形前，绑定纹理，就会自动地把纹理赋值给片段着色器的采样器。\n\n在一些驱动中，必须要对每个采样器uniform都附加上纹理单元才可以。\n\n纹理单元一个片段着色器可以有多个纹理，一个纹理的位置通常称为一个纹理单元。默认的纹理单元是0，是默认激活的，因此只有一个时不需要手动分配位置和激活。\nglActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元glBindTexture(GL_TEXTURE_2D, texture);\n\n激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。\n\nOpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。\n\n如果一个片段着色器绑定多个纹理单元，应该这样做：\nunsigned int texture1;glGenTextures(1, &amp;texture1);... // 创建纹理1unsigned int texture2;glGenTextures(1, &amp;texture2);... // 创建纹理2\n\n在片段着色器中创建两个采样器\nuniform sampler2D sampler_texture1;uniform sampler2D sampler_texture2;\n\n告诉OpenGL采样器对应的纹理单元\nourShader.use(); // 不要忘记在设置uniform变量之前激活着色器程序！ourShader.setInt(&quot;sampler_texture1&quot;, 0); // 使用着色器类设置ourShader.setInt(&quot;sampler_texture2&quot;, 1);// 也可以手动设置glUniform1i(glGetUniformLocation(ourShader.ID, &quot;sampler_texture1&quot;), 0);glUniform1i(glGetUniformLocation(ourShader.ID, &quot;sampler_texture2&quot;), 1);\n\n然后再渲染循环中分别激活并绑定纹理到对应的纹理单元\nglActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);\n\n最后片段着色器可以使用纹理了\nFragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);\n\n所以总体的连接在于，创建的纹理可以通过ID绑定到对应的纹理单元上，设置采样器分配纹理单元，最后通过texture函数采样纹理，赋值给片段。\n变换理论上，变换共有三种：旋转，位移，缩放。\n\n矩阵求逆是一项对于着色器开销很大的运算，因为它必须在场景中的每一个顶点上进行，所以应该尽可能地避免在着色器中进行求逆运算。以学习为目的的话这样做还好，但是对于一个高效的应用来说，你最好先在CPU上计算出法线矩阵，再通过uniform把它传递给着色器（就像模型矩阵一样）。 \n\n#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;// ---------------glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);glm::mat4 trans = glm::mat4(1.0f); // 矩阵的初始化是必要的trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));vec = trans * vec;std::cout &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; std::endl;// 以上代码是创建一个向量，然后用一个变换矩阵乘以此向量，达到变换向量的目的，输出结果为210\n\n实现3D// create transformationsglm::mat4 model = glm::mat4(1.0f);glm::mat4 view = glm::mat4(1.0f);glm::mat4 projection = glm::mat4(1.0f);model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f));// 注意，我们将矩阵向我们要进行移动场景的反方向移动。view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);ourShader.setMat4(&quot;model&quot;, model);ourShader.setMat4(&quot;view&quot;, view);ourShader.setMat4(&quot;projection&quot;, projection);\n\n注意，矩阵的运算是从右向左的，因此顶点着色器中相乘时应为：\ngl_Position = projection * view * model * vec4(aPos, 1.0);\n\n摄像机类代码实现：\n#ifndef CAMERA_H#define CAMERA_H#include &lt;glad/glad.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;vector&gt;// 定义一些可能用到的常量enum Camera_Movement &#123; FORWARD, BACKWARD, LEFT, RIGHT, UP, DOWN, FASTER_FORWARD, FASTER_BACKWARD, FASTER_LEFT, FASTER_RIGHT &#125;;// 摄像机默认值const float YAW = -90.0f; // 偏航角度const float PITCH = 0.0f; // 上仰角度const float SPEED = 5.0f; // 摄像机移动速度，虽然实际是整个空间的物体同时在移动const float SENSITIVITY = 0.1f; // 鼠标灵敏度，用以计算镜头转向const float ZOOM = 45.0f;       // 视野，观察空间的大小// An abstract camera class that processes input and calculates the// corresponding Euler Angles, Vectors and Matrices for use in OpenGLclass Camera &#123;  public:    // 摄像机属性    glm::vec3 Position; // 摄像机位置向量    glm::vec3 Front;    // 方向向量，摄像机指向的目标的方向    glm::vec3 Up; // 上向量，也即y轴正方向，叉乘方向向量可得右向量    glm::vec3 Right;   // 右向量，摄像机空间x轴的正方向    glm::vec3 WorldUp; // 上向量    // 有了三个互相垂直的轴，外加一个平移向量，即可创建一个矩阵，可以用这个矩阵乘以任何向量来将其变换到那个空间    // euler Angles    float Yaw;    float Pitch;    // camera options    float MovementSpeed;    float MouseSensitivity;    float Zoom;    // 使用一个向量创建摄像机：    // 主要参数为：位置，默认为原点;上向量，默认为010；方向向量为00-1,    // 其他均可以为默认    Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f),           glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW,           float pitch = PITCH)        : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED),          MouseSensitivity(SENSITIVITY), Zoom(ZOOM) &#123;        Position = position;        WorldUp = up;        Yaw = yaw;        Pitch = pitch;        updateCameraVectors();    &#125;    // 使用标量创建摄像机    // 主要参数为：位置，默认为原点;上向量，默认为010；方向向量为00-1,    // 其他均可以为默认    Camera(float posX, float posY, float posZ, float upX, float upY, float upZ,           float yaw, float pitch)        : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED),          MouseSensitivity(SENSITIVITY), Zoom(ZOOM) &#123;        Position = glm::vec3(posX, posY, posZ);        WorldUp = glm::vec3(upX, upY, upZ);        Yaw = yaw;        Pitch = pitch;        updateCameraVectors();    &#125;    // returns the view matrix calculated using Euler Angles and the LookAt    // Matrix    glm::mat4 GetViewMatrix() // 生成观察矩阵    &#123;        // return glm::lookAt(Position, Position + Front, Up);        // //        // lookat函数只需要一个位置，一个目标，和一个上向量，它会自己创建一个观察矩阵，此观察矩阵点乘空间中的物体，即可将物体变换到此观察空间中        // ------------ 以下为自己的lookat：        // 1. Position = known        // 2. Calculate cameraDirection        glm::vec3 zaxis = glm::normalize(-Front);        // 3. Get positive right axis vector        glm::vec3 xaxis =            glm::normalize(glm::cross(glm::normalize(WorldUp), zaxis));        // 4. Calculate camera up vector        glm::vec3 yaxis = glm::cross(zaxis, xaxis);        // Create translation and rotation matrix        // In glm we access elements as mat[col][row] due to column-major layout        glm::mat4 translation = glm::mat4(1.0f); // Identity matrix by default        translation[3][0] = -Position.x;         // Third column, first row        translation[3][1] = -Position.y;        translation[3][2] = -Position.z;        glm::mat4 rotation = glm::mat4(1.0f);        rotation[0][0] = xaxis.x; // First column, first row        rotation[1][0] = xaxis.y;        rotation[2][0] = xaxis.z;        rotation[0][1] = yaxis.x; // First column, second row        rotation[1][1] = yaxis.y;        rotation[2][1] = yaxis.z;        rotation[0][2] = zaxis.x; // First column, third row        rotation[1][2] = zaxis.y;        rotation[2][2] = zaxis.z;        return rotation * translation;    &#125;    // processes input received from any keyboard-like input system. Accepts    // input parameter in the form of camera defined ENUM (to abstract it from    // windowing systems)    void ProcessKeyboard(Camera_Movement direction, float deltaTime) &#123;        float velocity = MovementSpeed * deltaTime; // 设定速度        // 根据方向调整方向向量        if (direction == FORWARD)            Position += Front * velocity;        if (direction == BACKWARD)            Position -= Front * velocity;        if (direction == LEFT)            Position -= Right * velocity;        if (direction == RIGHT)            Position += Right * velocity;        if (direction == UP)            Position.y += velocity;        if (direction == DOWN)            Position.y -= velocity;        // Position.y = 0.0f; // 确保不会偏离xz平面        // Setting faster        if (direction == FASTER_FORWARD)            Position += Front * (velocity * 10);        if (direction == FASTER_BACKWARD)            Position -= Front * (velocity * 10);        if (direction == FASTER_LEFT)            Position -= Right * (velocity * 10);        if (direction == FASTER_RIGHT)            Position += Right * (velocity * 10);    &#125;    // processes input received from a mouse input system. Expects the offset    // value in both the x and y direction.    void ProcessMouseMovement(float xoffset, float yoffset,                              GLboolean constrainPitch = true) &#123;        xoffset *= MouseSensitivity; // x方向的鼠标偏离        yoffset *= MouseSensitivity; // y方向的鼠标偏离        Yaw += xoffset;   // 偏航        Pitch += yoffset; // 仰角        if (constrainPitch) // 确保仰角足够大时屏幕不会被翻转        &#123;            if (Pitch &gt; 89.0f)                Pitch = 89.0f;            if (Pitch &lt; -89.0f)                Pitch = -89.0f;        &#125;        // update Front, Right and Up Vectors using the updated Euler angles        updateCameraVectors();    &#125;    // processes input received from a mouse scroll-wheel event. Only requires    // input on the vertical wheel-axis    void ProcessMouseScroll(float yoffset) // 处理缩放    &#123;        Zoom -= (float)yoffset;        if (Zoom &lt; 1.0f)            Zoom = 1.0f;        if (Zoom &gt; 45.0f)            Zoom = 45.0f;    &#125;  private:    // 从更新后的相机的欧拉角计算方向向量    void updateCameraVectors() &#123;        // calculate the new Front vector        glm::vec3 front;        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));        front.y = sin(glm::radians(Pitch));        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));        Front = glm::normalize(front);        // 同时重新计算了右向量和上向量        Right = glm::normalize(glm::cross(Front, WorldUp));        // 将向量归一化，因为你向上或向下看的次数越多，它们的长度就越接近0，这会导致移动速度变慢。        Up = glm::normalize(glm::cross(Right, Front));    &#125;&#125;;#endif\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","OpenGL","Graphic","Computer"]},{"title":"OpenGL-1 初识","url":"/2023/06/12/note/Framework/OpenGL/opengl-intro/","content":"OpenGL本身是一种规范，只是规定了一些应有的函数和参数，没有任何实现(实现由第三方库完成，如glfw、glew）.\n\n\n\n本文之所以放在[编程]-&gt;[框架]的分类，是因为本文主要内容是用OpenGL规范实现的库的使用，而非OpenGL规范本身\n\n图形渲染管线是实时渲染的核心组件。渲染管线的功能是通过给定虚拟相机、3D场景物体以及光源等场景要素来产生或者渲染一副2D的图像。渲染管线是实时渲染的重要工具，主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色。\n渲染管线的一般流程分别是：顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器以及混合测试。\n\n\nOpenGL中，所有事物都是在3D空间中的，而屏幕是2D，因此必须把三维的坐标转换成二维坐标。\n图形渲染管线图形渲染管线(Graphics Pipeline)： 一个原始数据，经过一定变化和处理，最终显示在屏幕上。\n主要有两个步骤：\n\n把3D坐标转换为2D坐标\n把2D坐标转变为实际的有颜色的像素\n\n\n2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕&#x2F;窗口分辨率的限制。\n\n可被划分为几个阶段，连接而成，都具有特定的函数，很容易执行（正因为容易执行，才可以在GPU上运行成千上万个各自阶段的小程序，这些小程序为着色器）.\n着色器运行在GPU上，节省了CPU的（宝贵的）时间.\n\nOpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的\n\n具体阶段：\n\n\n输入数组，也即**顶点数据（Vertex Data)，它是用顶点属性(Vertex Attribute)**表示的，如坐标、颜色等\n使用图元(Primitive)可以告诉OpenGL把顶点渲染成什么样，如一系列点、一系列三角形或线，可用的**提示(Hint)**如GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP\n图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，目的是把3D坐标数据转换成另一种3D坐标**，同时允许我们对顶点属性进行一些基本处理\n图元装配是将顶点着色器输出的所有顶点作为输入，并所有的点装配成指定图元的形状（如果是GL_POINTS，那么就是一个顶点），如三角形\n图元装配阶段的输出会传递给**几何着色器(Geometry Shader)**。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状；例子中，它生成了另一个三角形\n几何着色器的输出会被传入**光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)**。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率\n\n\nOpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据\n片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色\n\n\n在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行**混合(Blend)**；所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同\n\n第一个三角形此处给出源码和详细注释，结构清晰：\n#include &quot;glad/glad.h&quot;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height); //回调函数的声明void processInput(GLFWwindow* window); // 处理对窗口的输入// --------------- 以字符串的形式定义着色器程序的源码，第4步需要用到 ---------------const char    * vertexShaderSource = // 创建顶点着色器程序的源码，使用c风格的常量字符串存储    &quot;#version 330 core\\n&quot;    &quot;layout (location = 0) in vec3 aPos;\\n&quot;    &quot;void main()\\n&quot;    &quot;&#123;\\n&quot;    &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot;    &quot;&#125;\\0&quot;;// 创建片段着色器程序的源码，使用c风格的常量字符串存储const char* fragmentShaderSource =    &quot;#version 330 core\\n&quot;    &quot;out vec4 FragColor;\\n&quot;    &quot;void main() &#123;\\n&quot;    &quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot; // 此处设置片段颜色为黄色    &quot;&#125;\\0&quot;;int main(void) &#123;    // -------------- 1. glfw的初始化 ----------------     if (!glfwInit()) &#123;        return -1;    &#125;    // --------------- 2. 使用glfw创建窗口 ---------------    GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);    if (window == NULL) &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    &#125;    glfwMakeContextCurrent(window); // 此函数使指定窗口的 OpenGL 或 OpenGL ES 上下文成为调用线程的当前上下文    glfwSetFramebufferSizeCallback(        window,        framebuffer_size_callback); // 回调函数，保证每次窗口大小调整时，重新绘制    // --------------- 3. glad：加载OpenGL所有的函数指针 ---------------    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;        return -1;    &#125;    // --------------- 4. 创建和编译着色器 ---------------    unsigned int vertexShader; // 创建顶点着色器索引    vertexShader = glCreateShader(GL_VERTEX_SHADER); // 创建顶点着色器    glShaderSource(        vertexShader, 1, &amp;vertexShaderSource,        NULL); // 为顶点着色器添加源码，第二个参数是添加的源码中字符串的数量，第三个先设置为NULL    glCompileShader(vertexShader); // 编译顶点着色器    int success;        // 创建编译状态指示变量    char info_log[512]; // 创建用以存储log的数组    glGetShaderiv(vertexShader, GL_COMPILE_STATUS,                  &amp;success); // 获取状态和log，输出到变量和数组中    if (!success) &#123;          // 如果编译失败，打印错误信息和log        glGetShaderInfoLog(vertexShader, 512, NULL, info_log);        std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot;            &lt;&lt; info_log &lt;&lt; std::endl;    &#125;    unsigned int fragmentShader;    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);    glCompileShader(fragmentShader);    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS,                  &amp;success); // 获取状态和log，输出到变量和数组中    if (!success) &#123;          // 如果编译失败，打印错误信息和log        glGetShaderInfoLog(fragmentShader, 512, NULL, info_log);        std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n&quot;            &lt;&lt; info_log &lt;&lt; std::endl;    &#125;    // --------------- 5. 链接着色器 ---------------    unsigned int shaderProgram;    shaderProgram = glCreateProgram();    // 把着色器添加到着色器程序中    glAttachShader(shaderProgram, vertexShader);    glAttachShader(shaderProgram, fragmentShader);    glLinkProgram(shaderProgram); // 链接着色器程序    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); // 异常检测    if (!success) &#123;        glGetProgramInfoLog(shaderProgram, 512, NULL, info_log);        std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINK_FAILED\\n&quot;            &lt;&lt; info_log &lt;&lt; std::endl;    &#125;    glUseProgram(        shaderProgram); // 调用此函数后，渲染和着色器调用都会使用此前所写的着色器了    glDeleteShader(vertexShader);    glDeleteShader(fragmentShader); // 链接完成之后就可以删除着色器了    // --------------- 6. 创建顶点数据缓冲区 ---------------    float vertices[] =    &#123;    // 第一个三角形        0.5f, 0.5f, 0.0f,   // 右上角        0.5f, -0.5f, 0.0f,  // 右下角        -0.5f, -0.5f, 0.0f, // 左下角        -0.5f, 0.5f, 0.0f &#125;; // 左上角    unsigned int indices[] = &#123;        // 注意索引从0开始!         // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，        // 这样可以由下标代表顶点组合成矩形        0, 1, 3, // 第一个三角形        1, 2, 3  // 第二个三角形    &#125;;    //&#123; -0.5f, -0.5f, 0.0f,  // left    //    0.5f, -0.5f, 0.0f,  // right    //    0.0f, 0.5f, 0.0f &#125;; // top    unsigned int EBO;    glGenBuffers(1, &amp;EBO);    unsigned int        VBO; // 缓冲区类似socket编程中的文件描述符，buffer作为唯一的标识来表示生成的一个缓冲区，GPU可以通过这个标识来读取缓冲区的数据，进而绘制出图形；它是一个整数    // VBO是顶点缓冲对象    glGenBuffers(1, &amp;VBO);              // 创建缓冲区    glBindBuffer(GL_ARRAY_BUFFER, VBO); // 绑定缓冲区    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // -------- 创建顶点数组对象 ----------    unsigned int VAO;    glGenVertexArrays(1, &amp;VAO);    glBindVertexArray(VAO);    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);    // 此时可以直接给缓冲区一个数据，或者不给数据，后面再给数据然后更新缓冲区    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);    // -------- 告诉GPU如何读取顶点数据 ----------    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float),                          (void*)0);    glEnableVertexAttribArray(0); // 启用顶点属性    glBindBuffer(GL_ARRAY_BUFFER, 0);    glBindVertexArray(0);  \t// --------------- 7. 窗口绘制循环 ---------------    while (!glfwWindowShouldClose(window)) &#123;        // input        // -----        processInput(window);        // render        // -----        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);        glUseProgram(shaderProgram);        //glBindVertexArray(VAO); // seeing as we only have a single VAO there&#x27;s        //// no need to bind it every time, but we&#x27;ll do        //// so to keep things a bit more organized        //glDrawArrays(GL_TRIANGLES, 0, 3);        glBindVertexArray(VAO);        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);        glBindVertexArray(0);        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);        glfwSwapBuffers(window);        glfwPollEvents();    &#125;    // glfw: terminate, clearing all previously allocated GLFW resources.    // ------------------------------------------------------------------    glfwTerminate();    return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this// frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow* window) &#123;    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)        glfwSetWindowShouldClose(window, true);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback// function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height) &#123;    // make sure the viewport matches the new window dimensions; note that width    // and height will be significantly larger than specified on retina    // displays.    glViewport(0, 0, width, height);&#125;\n\n概念与作用第一个三角形涉及到一些概念和特性，最引人注目的是三个对象，即：\n\n顶点数组对象：Vertex Array Object，VAO\n顶点缓冲对象：Vertex Buffer Object，VBO\n元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO\n\n标准化设备坐标标准化设备坐标(Normalized Device Coordinates)：OpenGL会将坐标转化为单位坐标，即所有轴上的大小范围为(-1, 1)\n顶点缓冲对象顶点缓冲对象(Vertex Buffer Objects, VBO)：管理顶点的内存，在显存中储存大量顶点\n\n这样可以一次性发送大量数据到显卡，而不用每次绘制都到cpu的内存中读取数据\n\n\n创建\n\nunsigned int VBO; //创建ID，类似套接字，可以通过此ID访问此对象（唯一绑定）glGenBuffers(1, &amp;VBO);//生成glBindBuffer(GL_ARRAY_BUFFER, VBO);//绑定，将生成的VBO与GL_ARRAY_BUFFER绑定，从此任何对GL_ARRAY_BUFFER的调用都会操作当前绑定的VBO// 如下面的操作：glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);//此函数将vertices的数据拷贝到缓冲GL_ARRAY_BUFFER中，因为之前绑定了VBO，所以实际上拷贝到了VBO上\n\nglBufferData函数的最后一个参数是指定显卡管理数据的方式：\n\nGL_STATIC_DRAW ：数据不会或几乎不会改变，修改一次，使用多次\nGL_DYNAMIC_DRAW：数据会被改变很多，修改多次，使用多次\nGL_STREAM_DRAW ：数据每次绘制时都会改变，每次都会修改和使用\n\n\n使用\n\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float),(void *)0);// 链接顶点属性，即告诉OpenGL如何解释顶点对象中的数据glEnableVertexAttribArray(0); // 启用顶点属性// 然后即可在窗口事件循环中绘制：glClearColor(0.2f, 0.3f, 0.3f, 1.0f);glClear(GL_COLOR_BUFFER_BIT);glUseProgram(shaderProgram);glBindVertexArray(VBO);glDrawArrays(GL_TRIANGLES, 0, 3);\n\nglVertexAttribPointer函数参数：\n\n第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。\n第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。\n第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。\n下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。\n第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。\n最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。\n\n元素缓冲对象元素缓冲对象(Element Buffer Object，EBO)：当有重复的顶点需要绘制时，不需要定义出相同的顶点，而是使用索引来引用重复的顶点\n这样只需要定义出不重复的所有顶点，需要哪个顶点时使用索引找到并使用它即可，这是EBO的工作方式\n\n创建顶点数组和索引\n\n// 绘制两个三角形组合成矩形，本来需要六个顶点，但是有两组重复的顶点float vertices[] = &#123;    // 第一个三角形    0.5f, 0.5f, 0.0f,   // 右上角    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, 0.5f, 0.0f,  // 左上角    // 第二个三角形    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, -0.5f, 0.0f, // 左下角    -0.5f, 0.5f, 0.0f   // 左上角&#125;;// 下面只定义四个顶点，使用索引就可以构造出两个三角形float vertices[] = &#123;    0.5f, 0.5f, 0.0f,   // 右上角    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, -0.5f, 0.0f, // 左下角    -0.5f, 0.5f, 0.0f   // 左上角&#125;;unsigned int indices[] = &#123;    // 注意索引从0开始!     // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，    // 这样可以由下标代表顶点组合成矩形    0, 1, 3, // 第一个三角形    1, 2, 3  // 第二个三角形&#125;;\n\n\n创建EBO（与VBO类似）\n\nunsigned int VBO; glGenBuffers(1, &amp;VBO);glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);unsigned int EBO;glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); // 注意绑定的缓冲类型为GL_ELEMENT_ARRAY_BUFFERglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\n\n使用\n\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float),(void *)0);// 链接顶点属性，即告诉OpenGL如何解释顶点对象中的数据glEnableVertexAttribArray(0); // 启用顶点属性//绘制时使用glDrawElements替换glDrawArraysglBindVertexArray(VBO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n\n\n必须结合VBO才能使用EBO，因为EBO只储存了索引，而没有顶点数据\n\n顶点数组对象顶点数组对象(Vertex Array Object, VAO)：主要用于管理 VBO 或 EBO ，减少glBindBuffer、glEnableVertexAttribArray、 glVertexAttribPointer 这些调用操作，高效地实现在顶点数组配置之间切换。\nVAO的简单使用：\n// 创建VAOunsigned VAO;glGenVertexArrays(1, &amp;VAO);glBindVertexArray(VAO);//创建VBOunsigned int VBO;glGenBuffers(1, &amp;VBO);glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);//创建EBOunsigned int EBO;glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices,             GL_STATIC_DRAW);//设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float),                      (void *)0);glEnableVertexAttribArray(0); // 启用顶点属性//解绑glBindBuffer(GL_ARRAY_BUFFER, 0); // 解绑bufferglBindVertexArray(0);             // 解绑VAO\n\n其他实践表明，无法使用同一个VAO绑定不同的VBO，画出两个不同的图形，一般是多个VAO分别对应多个VBO。一个EBO可以画出多个图形，但只是从预先设置好的数组中读取顶点数据，只不过可以重复使用顶点。\n词汇表\nOpenGL： 一个定义了函数布局和输出的图形API的正式规范。\nGLAD： 一个扩展加载库，用来为我们加载并设定所有OpenGL函数指针，从而让我们能够使用所有（现代）OpenGL函数。\n**视口(Viewport)**： 我们需要渲染的窗口。\n**图形管线(Graphics Pipeline)**： 一个顶点在呈现为像素之前经过的全部过程。\n**着色器(Shader)**： 一个运行在显卡上的小型程序。很多阶段的图形管道都可以使用自定义的着色器来代替原有的功能。\n**标准化设备坐标(Normalized Device Coordinates, NDC)**： 顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在NDC下-1.0到1.0的顶点将不会被丢弃并且可见。\n**顶点缓冲对象(Vertex Buffer Object)**： 一个调用显存并存储所有顶点数据供显卡使用的缓冲对象。\n**顶点数组对象(Vertex Array Object)**： 存储缓冲区和顶点属性状态。\n**元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)**： 一个存储元素索引供索引化绘制使用的缓冲对象。\nUniform： 一个特殊类型的GLSL变量。它是全局的（在一个着色器程序中每一个着色器都能够访问uniform变量），并且只需要被设定一次。\n**纹理(Texture)**： 一种包裹着物体的特殊类型图像，给物体精细的视觉效果。\n**纹理环绕(Texture Wrapping)**： 定义了一种当纹理顶点超出范围(0, 1)时指定OpenGL如何采样纹理的模式。\n**纹理过滤(Texture Filtering)**： 定义了一种当有多种纹素选择时指定OpenGL如何采样纹理的模式。这通常在纹理被放大情况下发生。\n**多级渐远纹理(Mipmaps)**： 被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小。\nstb_image.h： 图像加载库。\n**纹理单元(Texture Units)**： 通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染。\n**向量(Vector)**： 一个定义了在空间中方向和&#x2F;或位置的数学实体。\n**矩阵(Matrix)**： 一个矩形阵列的数学表达式。\nGLM： 一个为OpenGL打造的数学库。\n**局部空间(Local Space)**： 一个物体的初始空间。所有的坐标都是相对于物体的原点的。\n**世界空间(World Space)**： 所有的坐标都相对于全局原点。\n**观察空间(View Space)**： 所有的坐标都是从摄像机的视角观察的。\n**裁剪空间(Clip Space)**： 所有的坐标都是从摄像机视角观察的，但是该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出。OpenGL负责处理剩下的事情（裁剪&#x2F;透视除法）。\n**屏幕空间(Screen Space)**： 所有的坐标都由屏幕视角来观察。坐标的范围是从0到屏幕的宽&#x2F;高。\nLookAt矩阵： 一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移。\n**欧拉角(Euler Angles)**： 被定义为偏航角(Yaw)，俯仰角(Pitch)，和滚转角(Roll)从而允许我们通过这三个值构造任何3D方向。\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","Graphic","Computer"]},{"title":"MacOS创建OpenGL程序","url":"/2023/11/17/note/Framework/OpenGL/opengl-macos/","content":"在macOS上构建OpenGL程序需要安装一些依赖，而mac的包管理器毕竟远不如Linux。\n\n❗macOS对OpenGL的支持。\n\n\n\nClangdmac上安装编译器后并不会自带clangd，需要安装llvm包，但是Homebrew安装需要自行编译，速度太慢，直接下载clangd，将bin和lib复制到对应的地方即可。\nglfw与glew使用Homebrew安装似乎总有问题，因此选择使用Macport。\nsudo port install glfwsudo port install glew\n\n安装的头文件路径为/opt/loacl/include，库文件路径为/opt/loacl/lib，编译时要主动添加，clang不会自动识别。\n如使用xmake构建时，应在xmake.lua文件中添加：\n-- librariesadd_linkdirs(&quot;/opt/local/lib&quot;)add_includedirs(&quot;/opt/local/include&quot;)add_links(&quot;glfw&quot;)if is_plat(&quot;macosx&quot;) then\tadd_frameworks(&quot;OpenGL&quot;)end\n\n如果项目中需要添加ImGUI，则C++版本至少C11，可在xmake.lua文件中添加：\nset_languages(&quot;cxx17&quot;)\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","OpenGL","Graphic","Computer"]},{"title":"OpenGL-5 WebGL与WASM","url":"/2023/08/10/note/Framework/OpenGL/opengl-wasm/","content":"工作需要，使用wasm技术将OpenGL程序编译成可在网页显示的程序。\n\n\n先上代码：\n#include &lt;functional&gt;#include &lt;SDL.h&gt;#include &lt;emscripten.h&gt;#define GL_GLEXT_PROTOTYPES 1#include &lt;SDL_opengles2.h&gt;// Shader sourcesconst GLchar *vertexSource = &quot;attribute vec4 position;                     \\n&quot;                             &quot;void main()                                  \\n&quot;                             &quot;&#123;                                            \\n&quot;                             &quot;  gl_Position = vec4(position.xyz, 1.0);     \\n&quot;                             &quot;&#125;                                            \\n&quot;;const GLchar *fragmentSource =    &quot;precision mediump float;\\n&quot;    &quot;void main()                                  \\n&quot;    &quot;&#123;                                            \\n&quot;    &quot;  gl_FragColor[0] = gl_FragCoord.x/640.0;    \\n&quot;    &quot;  gl_FragColor[1] = gl_FragCoord.y/480.0;    \\n&quot;    &quot;  gl_FragColor[2] = 0.5;                     \\n&quot;    &quot;&#125;                                            \\n&quot;;// an example of something we will control from the javascript sidebool background_is_black = true;// the function called by the javascript codeextern &quot;C&quot; void EMSCRIPTEN_KEEPALIVE toggle_background_color() &#123;    background_is_black = !background_is_black;&#125;std::function&lt;void()&gt; loop;void main_loop() &#123; loop(); &#125;int main() &#123;    // Create window and renderer (context)    SDL_Window *window;    SDL_Renderer *renderer;    SDL_CreateWindowAndRenderer(640, 480, 0, &amp;window, &amp;renderer);    // Set attributes    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);    // vertex data    float vertices[] = &#123;0.0f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f&#125;;    // Create a Vertex Buffer Object and copy the vertex data to it    unsigned int vbo, vao;    glGenBuffers(1, &amp;vbo);    glGenVertexArraysOES(1, &amp;vao);    glBindBuffer(GL_ARRAY_BUFFER, vbo);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // Create and compile the vertex shader    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);    glShaderSource(vertexShader, 1, &amp;vertexSource, nullptr);    glCompileShader(vertexShader);    // Create and compile the fragment shader    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fragmentSource, nullptr);    glCompileShader(fragmentShader);    // Link the vertex and fragment shader into a shader program    unsigned int shaderProgram = glCreateProgram();    glAttachShader(shaderProgram, vertexShader);    glAttachShader(shaderProgram, fragmentShader);    glLinkProgram(shaderProgram);    glUseProgram(shaderProgram);    // Specify the layout of the vertex data    unsigned int posAttrib = glGetAttribLocation(shaderProgram, &quot;position&quot;);    glBindVertexArrayOES(vao);    glVertexAttribPointer(posAttrib, 2, GL_FLOAT, GL_FALSE, 0, 0);    glEnableVertexAttribArray(posAttrib);    loop = [&amp;] &#123;        // move a vertex        const uint32_t milliseconds_since_start = SDL_GetTicks();        const uint32_t milliseconds_per_loop = 3000;        vertices[0] = (milliseconds_since_start % milliseconds_per_loop) /                          float(milliseconds_per_loop) -                      0.5f;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices,                     GL_STATIC_DRAW);        // Clear the screen        if (background_is_black)            glClearColor(0.0f, 0.0f, 0.0f, 1.0f);        else            glClearColor(0.9f, 0.9f, 0.9f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);        // Draw a triangle from the 3 vertices        glDrawArrays(GL_TRIANGLES, 0, 3);        SDL_GL_SwapWindow(window);    &#125;;    emscripten_set_main_loop(main_loop, 0, true);    return EXIT_SUCCESS;&#125;\n\n编译运行：\nemcc main.cpp -std=c++11 -s WASM=1 -s USE_SDL=2 -O3 -o index.jspython -m http.server 8080\n\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","OpenGL","Graphic","Computer"]},{"title":"OpenGL-3 进阶","url":"/2023/07/24/note/Framework/OpenGL/opengl_advance/","content":"在OpenGL中，深度测试（Depth Testing）是一种用于处理场景中多个物体的绘制顺序的技术。它用于解决物体的可见性问题，确保只有最前面的物体像素被绘制，从而实现真实的3D场景效果。\n深度测试的基本思想是根据物体在场景中的距离，维护一个深度缓冲区（Depth Buffer），它是一个和颜色缓冲区大小相同的缓冲区。在深度缓冲区中，每个像素都存储着一个深度值（通常是浮点数或整数），表示物体到观察点（摄像机）的距离。这个距离通常是从摄像机视点到物体的距离。\n深度测试默认是禁用的，所以如果要启用深度测试的话，我们需要用GL_DEPTH_TEST选项来启用它：\nglEnable(GL_DEPTH_TEST);\n\n\n\n深度测试屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。\n深度冲突深度冲突（Depth Conflict）在OpenGL中指的是由于有多个物体在相同的屏幕位置上，并且它们的深度值相同或非常接近，导致深度测试无法准确地决定哪个物体应该在前面绘制，从而产生了视觉上的错误。\n深度冲突通常在以下情况下出现：\n\n在一个或多个物体的表面上有很多小的细节或凹凸，导致深度值在这些区域上非常接近，难以区分哪个物体在前面。\n在一个场景中有多个物体重叠在一起，并且它们的表面在同一深度上，导致深度测试无法准确判断哪个物体应该在前面绘制。\n\n为了解决深度冲突，有以下几种方法：\n\n使用更高精度的深度缓冲：可以使用更高精度的深度缓冲，比如使用32位浮点数来存储深度值，这样能够减少深度冲突的可能性。\n调整近平面和远平面：如果你的场景非常大或非常小，可能会导致深度缓冲的精度问题。通过调整近平面和远平面的值，可以增加深度缓冲的有效范围，从而减少深度冲突的可能性。\n使用透明度排序：如果你的场景中有透明物体，可以考虑对它们进行按照透明度排序，并按照远到近的顺序绘制它们。这样可以确保透明物体正确地显示在其他物体的后面。\n使用多边形偏移（Polygon Offset）：多边形偏移是一种通过微调深度值的方法来解决深度冲突的技术。它可以在绘制深度冲突的物体时，稍微改变它们的深度值，使它们稍微偏移一些，从而防止深度冲突。\n使用深度测试函数：OpenGL提供了几种深度测试函数，比如GL_LESS、GL_LEQUAL、GL_GREATER等等。你可以根据场景的需求选择合适的深度测试函数，以调整深度测试的行为。\n\n深度冲突是一个相对常见的问题，特别是在复杂的场景中。解决深度冲突通常需要结合多种方法，具体取决于场景的复杂程度和需求。选择合适的解决方法有助于提高渲染效果和场景的真实感。\n模板测试\n本质上就是：1.首先清空模板缓冲；2.写入模板缓冲；3.根据写入的模板缓冲在模板测试时丢弃和显示一些片段。\n\n通过使用模板缓冲，可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。\nglStencilFunc(GL_ALWAYS, 1, 0xFF);  // 所有的片段都应该更新模板缓冲，并且将每个像素的模板值设置为1glStencilMask(0xFF);  // 启用模板缓冲写入// ... 绘制箱子glStencilFunc(GL_NOTEQUAL, 1, 0xFF); // 每个像素的模板值不等于1时通过模板测试glStencilMask(0x00);  // 禁止模板缓冲的写入glDisable(GL_DEPTH_TEST);  // 禁用深度测试，以防止地板覆盖边框（也即放大的箱子）// ... 绘制更大的箱子glStencilMask(0xFF);glStencilFunc(GL_ALWAYS, 0, 0xFF);glEnable(GL_DEPTH_TEST); // 重新启用深度测试，防止影响其他绘制\n\n\n混合OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。\n其他问题stb_image库踩坑加载stb_image库时，宏声明应在头文件之前，否则会找不到函数：\n#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot;\n\n摄像机位置添加空格上升镜头位置，ctrl降低镜头位置：\nvoid ProcessKeyboard(Camera_Movement direction, float deltaTime)&#123;    float velocity = MovementSpeed * deltaTime;  // 设定速度    // 根据方向调整方向向量    if (direction == FORWARD)        Position += Front * velocity;    if (direction == BACKWARD)        Position -= Front * velocity;    if (direction == LEFT)        Position -= Right * velocity;    if (direction == RIGHT)        Position += Right * velocity;    if (direction == UP)        Position.y += velocity;    if (direction == DOWN)        Position.y -=   velocity;    // Position.y = 0.0f; // 确保不会偏离xz平面&#125;\n\n模型加载库\n\n和材质和网格(Mesh)一样，所有的场景&#x2F;模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。\n场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。\n一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。\n一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见[你好，三角形](https://learnopengl-cn.github.io/01 Getting started&#x2F;04 Hello Triangle&#x2F;)）。\n最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。\n\n\n所谓网格，就是渲染物体的最小单位\n\n通过使用Assimp，我们可以加载不同的模型到程序中，但是载入后它们都被储存为Assimp的数据结构。我们最终仍要将这些数据转换为OpenGL能够理解的格式，这样才能渲染这个物体。\nGLFW处理多个键同时输入设置摄像机更快速的移动shift+w/s/a/d：\n// Fasterif (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)    camera.ProcessKeyboard(FASTER_FORWARD, deltaTime);if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)    camera.ProcessKeyboard(FASTER_BACKWARD, deltaTime);if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)    camera.ProcessKeyboard(FASTER_LEFT, deltaTime);if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)    camera.ProcessKeyboard(FASTER_RIGHT, deltaTime);\n\n着色器类中的异常捕捉// ensure ifstream objects can throw exceptions:vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);try &#123;    // open files    vShaderFile.open(vertexPath);    fShaderFile.open(fragmentPath);    std::stringstream vShaderStream, fShaderStream;    // read file&#x27;s buffer contents into streams    vShaderStream &lt;&lt; vShaderFile.rdbuf();    fShaderStream &lt;&lt; fShaderFile.rdbuf();    // close file handlers    vShaderFile.close();    fShaderFile.close();    // convert stream into string    vertexCode = vShaderStream.str();    fragmentCode = fShaderStream.str();&#125; catch (std::ifstream::failure &amp;e) &#123;    std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;              &lt;&lt; e.what() &lt;&lt; std::endl;&#125;\n\n深入理解顶点着色器和片段着色器在OpenGL核心模式的渲染中，这两个着色器是不能跳过的着色器，必须手动编写。\n抗锯齿超采样抗锯齿(Super Sample Anti-aliasing, SSAA)：它会使用比正常分辨率更高的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率。这些额外的分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的性能开销。所以这项技术只拥有了短暂的辉煌。\n多重采样抗锯齿(Multisample Anti-aliasing, MSAA)：它借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿。渲染图元时，不只使用像素中心点作为采样点，而是将一个像素分成多个子采样点（这也是为什么叫做多重采样的原因）。每个像素片段着色器只运行一次，其所使用的顶点数据会插值到每个像素中心，结果储存在每个被覆盖的子采样点中，每个像素内部会将采样点的颜色平均化。\n在OpenGL中使用MSAA，可以通过Hint的方式，在创建窗口前调用：\nglfwWindowHint(GLFW_SAMPLES, 4);glEnable(GL_MULTISAMPLE); // 保险起见，启用一下多重采样（多数情况时默认启用的）\n\n现在再调用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会使用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。\nImGui为了方便的查看场景，将鼠标禁用，使用光标回调函数来控制摄像机镜头的方向，所以使用imgui时不能使用鼠标拖动控件，如下：\n\n因此要设置一个快捷键来唤出光标，捕捉并禁用光标的代码是在创建窗口后：\nglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\n而实现快捷时有一个问题，实现摄像机在场景中移动是在渲染循环中使用processInput(window)函数，获取键盘输入来控制，这样可以实现一次按下连续控制，这也正是问题所在，如果直接在此函数中设置快捷键，按下一次会在每次渲染循环中都调用一次，表现为光标一直闪烁（因为一直在重复 获取光标、隐藏光标、获取光标…）。\n解决方法是定义键盘回调函数，将切换光标的代码放到回调函数中，这样按一次键盘释放之前不会重复调用。\nbool show_mouse = false; // global variable// Key callback functionvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) &#123;    if (glfwGetKey(window, GLFW_KEY_LEFT_ALT) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS)    &#123;        if (show_mouse)        &#123;            show_mouse = false;        &#125;        else        &#123;            show_mouse = true;        &#125;        // 捕捉鼠标，并隐藏光标         if (!show_mouse)            glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);        else            glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);    &#125;&#125;// Don&#x27;t forget registering it after creating the window// in main functionglfwSetKeyCallback(window, key_callback);\n\n初始化在渲染循环之外：\n// Init Dear Imguiconst char* glsl_version = &quot;#version 330&quot;;IMGUI_CHECKVERSION();ImGui::CreateContext();ImGuiIO&amp; io = ImGui::GetIO(); (void)io;ImGui::StyleColorsDark();ImGui_ImplGlfw_InitForOpenGL(window, true);ImGui_ImplOpenGL3_Init(glsl_version);\n\n使用在渲染循环内：\nImGui_ImplOpenGL3_NewFrame();ImGui_ImplGlfw_NewFrame();ImGui::NewFrame();&#123;     // setup    ImGui::Begin(&quot;Cube and Lighting&quot;);   \t// ...    ImGui::Text(&quot;Application average %.3f ms/frame (%.1f FPS)&quot;, 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate); // Frame rate    ImGui::End();&#125;ImGui::Render();ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n同一行放置多个控件ImGui::SameLine();\n\n可实现此语句前后的两个控件不换行。\n控件例子ImGui::Begin(&quot;Cube and Lighting&quot;);                          // Create a window called &quot;Cube and Lighting&quot; and append into it.ImGui::Text(&quot;Here can be adjust some params of the sence.&quot;);  // Display some text (you can use a format strings too)ImGui::Checkbox(&quot;Demo Window&quot;, &amp;show_demo_window);      // Edit bools storing our window open/close stateImGui::SliderFloat(&quot;ambientStrength&quot;, &amp;ambientStrength, 0.0f, 1.0f);   // Edit 1 float using a slider from 0.0f to 1.0fImGui::SliderFloat(&quot;specularStrength&quot;, &amp;specularStrength, 0.0f, 1.0f);ImGui::ColorEdit3(&quot;Cube color&quot;, (float*)&amp;objectColor); // Edit 3 floats representing a colorImGui::Text(&quot;Cube color = %f, %f, %f&quot;, objectColor.x, objectColor.y, objectColor.z); if (ImGui::Button(&quot;Button&quot;))     counter++;// Buttons return true when clicked (most widgets return true when edited/activated)ImGui::Text(&quot;Application average %.3f ms/frame (%.1f FPS)&quot;, 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);ImGui::End();\n\n小行星光照方向变化实例化渲染时，模型矩阵aInstanceMatrix会从直接传入顶点着色器，而不是uniform赋值，因此直接在GPU中计算法向量Normal = mat3(transpose(inverse(aInstanceMatrix))) * aNormal;，这样光照的计算就不会因为模型变换而改变方向。\n#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;layout (location = 3) in mat4 aInstanceMatrix;out vec2 TexCoords;out vec3 FragPos;out vec3 Normal;uniform mat4 projection;uniform mat4 view;void main()&#123;    TexCoords = aTexCoords;    gl_Position = projection * view * aInstanceMatrix * vec4(aPos, 1.0f);     Normal = mat3(transpose(inverse(aInstanceMatrix))) * aNormal;    FragPos = vec3(aInstanceMatrix * vec4(aPos, 1.0));&#125;\n\nCubemap加载天空盒需要加载六个纹理。\nunsigned int loadCubemap(vector&lt;std::string&gt; faces)&#123;    unsigned int textureID;    glGenTextures(1, &amp;textureID);    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);    int width, height, nrChannels;    for (unsigned int i = 0; i &lt; faces.size(); i++)    &#123;        unsigned char* data = stbi_load(faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, 0);        if (data)        &#123;            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);            stbi_image_free(data);        &#125;        else        &#123;            std::cout &lt;&lt; &quot;Cubemap texture failed to load at path: &quot; &lt;&lt; faces[i] &lt;&lt; std::endl;            stbi_image_free(data);        &#125;    &#125;    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);    return textureID;&#125;\n\n即所谓天空盒子，可以在场景四周贴上纹理，看起来就像是在一些场景中。\n\n必须要注意的是，纹理图片必须是jpg格式的，大小必须为1024的倍数，比例必须是正方形。\n\n// Sky box vertex data// ------------float skyboxVertices[] = &#123;    // positions              -1.0f,  1.0f, -1.0f,    -1.0f, -1.0f, -1.0f,     1.0f, -1.0f, -1.0f,     1.0f, -1.0f, -1.0f,     1.0f,  1.0f, -1.0f,    -1.0f,  1.0f, -1.0f,    -1.0f, -1.0f,  1.0f,    -1.0f, -1.0f, -1.0f,    -1.0f,  1.0f, -1.0f,    -1.0f,  1.0f, -1.0f,    -1.0f,  1.0f,  1.0f,    -1.0f, -1.0f,  1.0f,     1.0f, -1.0f, -1.0f,     1.0f, -1.0f,  1.0f,     1.0f,  1.0f,  1.0f,     1.0f,  1.0f,  1.0f,     1.0f,  1.0f, -1.0f,     1.0f, -1.0f, -1.0f,    -1.0f, -1.0f,  1.0f,    -1.0f,  1.0f,  1.0f,     1.0f,  1.0f,  1.0f,     1.0f,  1.0f,  1.0f,     1.0f, -1.0f,  1.0f,    -1.0f, -1.0f,  1.0f,    -1.0f,  1.0f, -1.0f,     1.0f,  1.0f, -1.0f,     1.0f,  1.0f,  1.0f,     1.0f,  1.0f,  1.0f,    -1.0f,  1.0f,  1.0f,    -1.0f,  1.0f, -1.0f,    -1.0f, -1.0f, -1.0f,    -1.0f, -1.0f,  1.0f,     1.0f, -1.0f, -1.0f,     1.0f, -1.0f, -1.0f,    -1.0f, -1.0f,  1.0f,     1.0f, -1.0f,  1.0f&#125;;// skybox VAOunsigned int skyboxVAO, skyboxVBO;glGenVertexArrays(1, &amp;skyboxVAO);glGenBuffers(1, &amp;skyboxVBO);glBindVertexArray(skyboxVAO);glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &amp;skyboxVertices, GL_STATIC_DRAW);glEnableVertexAttribArray(0);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);vector&lt;std::string&gt; faces&#123;    &quot;../assets/space/right.jpg&quot;,    &quot;../assets/space/left.jpg&quot;,    &quot;../assets/space/top.jpg&quot;,    &quot;../assets/space/bottom.jpg&quot;,    &quot;../assets/space/front.jpg&quot;,    &quot;../assets/space/back.jpg&quot;,&#125;;unsigned int cubemapTexture = loadCubemap(faces);skyboxShader.use();skyboxShader.setInt(&quot;skybox&quot;, 0);\n\n顶点着色器：\n#version 330 corelayout (location = 0) in vec3 aPos;out vec3 TexCoords;uniform mat4 projection;uniform mat4 view;void main()&#123;    TexCoords = aPos;    vec4 pos = projection * view * vec4(aPos, 1.0);    gl_Position = pos.xyww;&#125;\n\n片段着色器：\n#version 330 coreout vec4 FragColor;in vec3 TexCoords;uniform samplerCube skybox;void main()&#123;        FragColor = texture(skybox, TexCoords);&#125;\n\n然后渲染：\n // draw skybox as lastglDepthFunc(GL_LEQUAL);  // change depth function so depth test passes when values are equal to depth buffer&#x27;s contentskyboxShader.use();view = glm::mat4(glm::mat3(camera.GetViewMatrix())); // remove translation from the view matrixskyboxShader.setMat4(&quot;view&quot;, view);skyboxShader.setMat4(&quot;projection&quot;, projection);// skybox cubeglBindVertexArray(skyboxVAO);glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);glDepthFunc(GL_LESS); // set depth function back to default\n\n贴图下载网站有许多网站提供免费和付费的Cubemap贴图下载。你可以在这些网站上找到各种类型和风格的Cubemap贴图，以满足你的需求。以下是一些常见的资源网站：\n\nHDRI Haven (https://hdrihaven.com/): 这是一个提供高动态范围图像（HDRI）和Cubemap贴图的免费资源网站。你可以在这里找到多种环境和天空盒子贴图。\nTextures.com (https://www.textures.com/): 这个网站提供各种类型的纹理资源，包括Cubemap贴图。它有免费和付费选项。\nUnity Asset Store (https://assetstore.unity.com/): 如果你使用Unity引擎，Unity Asset Store提供了丰富的Cubemap贴图资源，其中一些是免费的，而另一些需要购买。\nUnreal Engine Marketplace (https://www.unrealengine.com/marketplace/): 如果你使用Unreal Engine，这个市场提供了许多Cubemap贴图资源，其中一些也是免费的。\nGoogle搜索：你可以在Google上搜索”Cubemap textures”、”Skybox textures”或者其他相关关键词，找到更多的免费和付费资源。\n\n请注意，在使用免费或付费资源时，务必遵循相关许可协议和版权规定。有些资源可能需要你在商业项目中使用时付费或注明来源。另外，选择适合你项目需求的高质量贴图是非常重要的，这将有助于提升你项目的视觉效果和真实感。\nstb_image库踩坑加载stb_image库时，宏声明应在头文件之前，否则会找不到函数：\n#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot;\n\n摄像机位置添加空格上升镜头位置，ctrl降低镜头位置：\nvoid ProcessKeyboard(Camera_Movement direction, float deltaTime)&#123;    float velocity = MovementSpeed * deltaTime;  // 设定速度    // 根据方向调整方向向量    if (direction == FORWARD)        Position += Front * velocity;    if (direction == BACKWARD)        Position -= Front * velocity;    if (direction == LEFT)        Position -= Right * velocity;    if (direction == RIGHT)        Position += Right * velocity;    if (direction == UP)        Position.y += velocity;    if (direction == DOWN)        Position.y -=   velocity;    // Position.y = 0.0f; // 确保不会偏离xz平面&#125;\n\n模型加载库\n\n和材质和网格(Mesh)一样，所有的场景&#x2F;模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。\n场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。\n一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。\n一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见[你好，三角形](https://learnopengl-cn.github.io/01 Getting started&#x2F;04 Hello Triangle&#x2F;)）。\n最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。\n\n\n所谓网格，就是渲染物体的最小单位\n\n通过使用Assimp，我们可以加载不同的模型到程序中，但是载入后它们都被储存为Assimp的数据结构。我们最终仍要将这些数据转换为OpenGL能够理解的格式，这样才能渲染这个物体。\nGLFW处理多个键同时输入设置摄像机更快速的移动shift+w/s/a/d：\n// Fasterif (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)    camera.ProcessKeyboard(FASTER_FORWARD, deltaTime);if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)    camera.ProcessKeyboard(FASTER_BACKWARD, deltaTime);if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)    camera.ProcessKeyboard(FASTER_LEFT, deltaTime);if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)    camera.ProcessKeyboard(FASTER_RIGHT, deltaTime);\n\n着色器类中的异常捕捉// ensure ifstream objects can throw exceptions:vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);try &#123;    // open files    vShaderFile.open(vertexPath);    fShaderFile.open(fragmentPath);    std::stringstream vShaderStream, fShaderStream;    // read file&#x27;s buffer contents into streams    vShaderStream &lt;&lt; vShaderFile.rdbuf();    fShaderStream &lt;&lt; fShaderFile.rdbuf();    // close file handlers    vShaderFile.close();    fShaderFile.close();    // convert stream into string    vertexCode = vShaderStream.str();    fragmentCode = fShaderStream.str();&#125; catch (std::ifstream::failure &amp;e) &#123;    std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;              &lt;&lt; e.what() &lt;&lt; std::endl;&#125;\n\n深入理解顶点着色器和片段着色器在OpenGL核心模式的渲染中，这两个着色器是不能跳过的着色器，必须手动编写。\n抗锯齿超采样抗锯齿(Super Sample Anti-aliasing, SSAA)：它会使用比正常分辨率更高的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率。这些额外的分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的性能开销。所以这项技术只拥有了短暂的辉煌。\n多重采样抗锯齿(Multisample Anti-aliasing, MSAA)：它借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿。渲染图元时，不只使用像素中心点作为采样点，而是将一个像素分成多个子采样点（这也是为什么叫做多重采样的原因）。每个像素片段着色器只运行一次，其所使用的顶点数据会插值到每个像素中心，结果储存在每个被覆盖的子采样点中，每个像素内部会将采样点的颜色平均化。\n在OpenGL中使用MSAA，可以通过Hint的方式，在创建窗口前调用：\nglfwWindowHint(GLFW_SAMPLES, 4);glEnable(GL_MULTISAMPLE); // 保险起见，启用一下多重采样（多数情况时默认启用的）\n\n现在再调用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会使用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。\nImGui为了方便的查看场景，将鼠标禁用，使用光标回调函数来控制摄像机镜头的方向，所以使用imgui时不能使用鼠标拖动控件，如下：\n\n因此要设置一个快捷键来唤出光标，捕捉并禁用光标的代码是在创建窗口后：\nglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\n而实现快捷时有一个问题，实现摄像机在场景中移动是在渲染循环中使用processInput(window)函数，获取键盘输入来控制，这样可以实现一次按下连续控制，这也正是问题所在，如果直接在此函数中设置快捷键，按下一次会在每次渲染循环中都调用一次，表现为光标一直闪烁（因为一直在重复 获取光标、隐藏光标、获取光标…）。\n解决方法是定义键盘回调函数，将切换光标的代码放到回调函数中，这样按一次键盘释放之前不会重复调用。\nbool show_mouse = false; // global variable// Key callback functionvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) &#123;    if (glfwGetKey(window, GLFW_KEY_LEFT_ALT) == GLFW_PRESS &amp;&amp; glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS)    &#123;        if (show_mouse)        &#123;            show_mouse = false;        &#125;        else        &#123;            show_mouse = true;        &#125;        // 捕捉鼠标，并隐藏光标         if (!show_mouse)            glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);        else            glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);    &#125;&#125;// Don&#x27;t forget registering it after creating the window// in main functionglfwSetKeyCallback(window, key_callback);\n\n初始化在渲染循环之外：\n// Init Dear Imguiconst char* glsl_version = &quot;#version 330&quot;;IMGUI_CHECKVERSION();ImGui::CreateContext();ImGuiIO&amp; io = ImGui::GetIO(); (void)io;ImGui::StyleColorsDark();ImGui_ImplGlfw_InitForOpenGL(window, true);ImGui_ImplOpenGL3_Init(glsl_version);\n\n使用在渲染循环内：\nImGui_ImplOpenGL3_NewFrame();ImGui_ImplGlfw_NewFrame();ImGui::NewFrame();&#123;     // setup    ImGui::Begin(&quot;Cube and Lighting&quot;);   \t// ...    ImGui::Text(&quot;Application average %.3f ms/frame (%.1f FPS)&quot;, 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate); // Frame rate    ImGui::End();&#125;ImGui::Render();ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n同一行放置多个控件ImGui::SameLine();\n\n可实现此语句前后的两个控件不换行。\n控件例子ImGui::Begin(&quot;Cube and Lighting&quot;);                          // Create a window called &quot;Cube and Lighting&quot; and append into it.ImGui::Text(&quot;Here can be adjust some params of the sence.&quot;);  // Display some text (you can use a format strings too)ImGui::Checkbox(&quot;Demo Window&quot;, &amp;show_demo_window);      // Edit bools storing our window open/close stateImGui::SliderFloat(&quot;ambientStrength&quot;, &amp;ambientStrength, 0.0f, 1.0f);   // Edit 1 float using a slider from 0.0f to 1.0fImGui::SliderFloat(&quot;specularStrength&quot;, &amp;specularStrength, 0.0f, 1.0f);ImGui::ColorEdit3(&quot;Cube color&quot;, (float*)&amp;objectColor); // Edit 3 floats representing a colorImGui::Text(&quot;Cube color = %f, %f, %f&quot;, objectColor.x, objectColor.y, objectColor.z); if (ImGui::Button(&quot;Button&quot;))     counter++;// Buttons return true when clicked (most widgets return true when edited/activated)ImGui::Text(&quot;Application average %.3f ms/frame (%.1f FPS)&quot;, 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);ImGui::End();\n\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","Graphic","Computer"]},{"title":"OpenGL-4 阴影","url":"/2023/08/23/note/Framework/OpenGL/opengl_shadow/","content":"阴影映射(Shadow Mapping)：以光的位置为视角进行渲染，能看到的东西都将被点亮，看不见的一定是在阴影之中。\n\n\n阴影映射深度测试教程中，在深度缓冲里的一个值是摄像机视角下，对应于一个片段的一个0到1之间的深度值。从光源的透视图来渲染场景，并把深度值的结果储存到纹理中，储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。\n第一步我们需要生成一张深度贴图(Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，我们将再次需要帧缓冲。\n创建Shadow Mapping首先为渲染的深度贴图创建一个帧缓冲对象：\nGLuint depthMapFBO;glGenFramebuffers(1, &amp;depthMapFBO);\n\n然后，创建一个2D纹理，提供给帧缓冲的深度缓冲使用：\nconst GLuint SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024;GLuint depthMap;glGenTextures(1, &amp;depthMap);glBindTexture(GL_TEXTURE_2D, depthMap);glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT,              SHADOW_WIDTH, SHADOW_HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n生成深度贴图不太复杂。因为我们只关心深度值，我们要把纹理格式指定为GL_DEPTH_COMPONENT。我们还要把纹理的高宽设置为1024，这是深度贴图的分辨率。\n把我们把生成的深度纹理作为帧缓冲的深度缓冲：\nglBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, 0);glDrawBuffer(GL_NONE);glReadBuffer(GL_NONE);glBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。然而，不包含颜色缓冲的帧缓冲对象是不完整的，所以我们需要显式告诉OpenGL我们不适用任何颜色数据进行渲染。我们通过将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE来做这件事。\n合理配置将深度值渲染到纹理的帧缓冲后，我们就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：\n// 1. 首选渲染深度贴图glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);glClear(GL_DEPTH_BUFFER_BIT);ConfigureShaderAndMatrices();RenderScene();glBindFramebuffer(GL_FRAMEBUFFER, 0);// 2. 像往常一样渲染场景，但这次使用深度贴图glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);ConfigureShaderAndMatrices();glBindTexture(GL_TEXTURE_2D, depthMap);RenderScene();\n\n这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用glViewport。因为阴影贴图经常和我们原来渲染的场景（通常是窗口分辨率）有着不同的分辨率，我们需要改变视口（viewport）的参数以适应阴影贴图的尺寸。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。\n","categories":["递归这个世界 · 编程","框架"],"tags":["CPP","Graphic","Computer"]},{"title":"nginx 安装 SSL 证书","url":"/2023/05/25/note/Linux/Server/SSL/","content":"给服务器安装SLL证书以支持HTTPS。\n\n\n下载证书请在 SSL 证书管理控制台中下载您需要安装的证书\n\ncloud. tencent. com_bundle. crt 证书文件\ncloud. tencent. com_bundle. pem 证书文件（可忽略该文件）\ncloud. tencent. com. key 私钥文件\ncloud. tencent. com. csr CSR 文件\n\nnginx 配置查看 nginx 是否安装：\nnginx -vsudo apt install nginx\n\n查看 nginx 的配置文件：\nsudo nginx -t# 显示为nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful\n\n编辑配置文件：\nsudo vim /etc/nginx/nginx.conf\n\n在 http 中添加：\nserver &#123;     #SSL 默认访问端口号为 443     listen 443 ssl;     #请填写绑定证书的域名     server_name www.dionysen.top;     #请填写证书文件的相对路径或绝对路径     ssl_certificate /home/dionysen/.config/www.dionysen.top_nginx/www.dionysen.top_bundle.crt;     #请填写私钥文件的相对路径或绝对路径     ssl_certificate_key /home/dionysen/.config/www.dionysen.top_nginx/www.dionysen.top.key;     ssl_session_timeout 5m;     #请按照以下协议配置     ssl_protocols TLSv1.2 TLSv1.3;     #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;     ssl_prefer_server_ciphers on;     location / &#123;         #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。         #例如，您的网站主页在 Nginx 服务器的 /etc/www 目录下，则请修改 root 后面的 html 为 /etc/www。         root html;         index  index.html index.htm;     &#125; &#125;server &#123; listen 80; #请填写绑定证书的域名 server_name www.dionysen.top; #把http的域名请求转成https return 301 https://$host$request_uri;&#125;\n\n测试和重新载入测试配置文件有效性：\nsudo nginx -t\n\n重新载入：\nsudo nginx -s reload\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["SSL","Nginx"]},{"title":"Code-Server 配置 CPP 开发环境","url":"/2023/05/25/note/Linux/Server/code_server/","content":"\n\n\nDeploy once，Code anywhere！\n\n几乎任何浏览器都可以直接得到与VScode相近的编码体验。\n\n\n安装按照官方文档安装：Install - code-server Docs (coder.com)\n配置开启 https下载 SSL 证书，解压到一个地方在 .config/code-server/config.yaml 中加入：\ncert: /path/to/*.crtcert-key: /path/to/*.key\n\n使用systemd重启服务即可\n修改字体\n目前最新版 code-server 不能用，实测 v4.7.1 可以\n\n目前只能通过加入web-font的方式修改：\ngit clone https://github.com/tuanpham-dev/code-server-font-patch.gitcd code-server-font-patch# Run this command (change path-to-code-server to your code-server path, leave it empty if you install code-server from installer or code-server is in /usr/lib/code-server):sudo ./patch.sh [path-to-code-server]\n\nYou may need to set font family in code-server settings:\n&quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;, Consolas, &#x27;Courier New&#x27;, monospace&quot;,&quot;terminal.integrated.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;, Consolas, &#x27;Courier New&#x27;, monospace&quot;,\n\nInstall Packages\n\n\nPackage\nFunction\n\n\n\nclang\nCompile\n\n\nclangd\nLanguage support\n\n\nclang-format\nFormat the code\n\n\nlldb\nDebug\n\n\ncmake\nQuick configure project\n\n\nInstall PluginsSearch the plugins, CodeLLDB and clangd.\nConfig the CMake and ClangdUsing plugin cmake toolOpen a WSL2 distro and get into a folder, input code . and press enter.Vscode will be started. There is empty in the folder.Press ctrl+shift+p and input cmake: quick start, select the CMake: Quick Start.Choice the clang variant.Input the name of you project.A hello world program will be auto-created.Now, you can build and run your project.\nUsing little tool pm个人开发的极不成熟的小工具，用以快速管理小型c++工程。\n请查看Project Manager。\nConfig debugAdd a launch.json in the workfolder, and add configuration lldb.Modify the program.\n&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;type&quot;: &quot;lldb&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Debug&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/&lt;/*Your project name/&gt;&quot;,            &quot;args&quot;: [],            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;        &#125;    ]&#125;\n\nMultiFoldersAdd the include_directories(./Sources) to CMakeLists.txt .\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)include_directories(Includes)include_directories(Sources)......\n\nor cd $&#123;PROJ_DIR&#125;/build then run command cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 in terminal.\nClang-format编辑 .clang-format 文件\nIndentWidth: 4# Mind the blank place is a tab\n\nSetting.json (personal backup)这是我个人的设置备份，请不要直接复制使用，最好查明每一项作用再使用。\n&#123;    &quot;files.autoSave&quot;: &quot;onFocusChange&quot;,    &quot;editor.links&quot;: false,    &quot;editor.guides.indentation&quot;: false,    &quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;&quot;,    &quot;editor.fontWeight&quot;: 400,    &quot;terminal.integrated.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;&quot;,    &quot;editor.fontSize&quot;: 13,    &quot;terminal.integrated.fontSize&quot;: 13,    &quot;editor.lineHeight&quot;: 1.5,    // &quot;vscode-neovim.neovimInitVimPaths.linux&quot;: &quot;~/.config/nvim/init.lua&quot;,    &quot;editor.inlayHints.enabled&quot;: &quot;off&quot;,    &quot;git.enabled&quot;: false,    &quot;markdown-preview-enhanced.codeBlockTheme&quot;: &quot;github.css&quot;,    &quot;markdown.preview.breaks&quot;: true,    &quot;markdown.extension.tableFormatter.enabled&quot;: true,    &quot;editor.formatOnSave&quot;: true,    &quot;editor.codeActionsOnSave&quot;: &#123;        &quot;source.fixAll.markdownlint&quot;: true    &#125;,    &quot;cmake.autoSelectActiveFolder&quot;: false,    &quot;cmake.configureOnEdit&quot;: false,    &quot;editor.lineNumbers&quot;: &quot;on&quot;,    &quot;workbench.editor.showTabs&quot;: true,    &quot;editor.minimap.autohide&quot;: true,    &quot;editor.minimap.enabled&quot;: false,    &quot;terminal.integrated.copyOnSelection&quot;: true,    &quot;terminal.integrated.cursorBlinking&quot;: true,    &quot;cmake.ignoreCMakeListsMissing&quot;: true,    &quot;vim.vimrc.path&quot;: &quot;$HOME/backup/.vimrc&quot;,    &quot;vim.vimrc.enable&quot;: true,    &quot;extensions.webWorker&quot;: false,    &quot;vim.useCtrlKeys&quot;: false,    &quot;vim.enableNeovim&quot;: true,    &quot;vim.neovimConfigPath&quot;: &quot;~/backup/init.vim&quot;,&#125;\n\nTermux\n&#123;    &quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;&quot;,    &quot;terminal.integrated.fontFamily&quot;: &quot;Fira Code&quot;,    &quot;markdown.preview.breaks&quot;: true,    &quot;editor.minimap.autohide&quot;: true,    &quot;markdown.styles&quot;: [        &quot;/data/data/com.termux/files/home/storage/documents/note/notes/.vscode/markdown-styles/ia_typora_night.css&quot;    ],    &quot;editor.wordWrap&quot;: &quot;on&quot;,&#125;\n\nIssuesFont size in console of Script run (vscode plugin)Add to stylesheet：\n.script-view .line &#123;      font-size: 17px;  &#125;\n\nCMake tools 在插件商店找不到Ctrl＋p 输入命令：\next install ms-vscode.cmake-tools\n\nCodelldb配置插件安装遇到问题，如下载失败，请看VS code 安装插件 lldb 调试 CPP 程序。\nInstall codelldb and create a launch.json :\n&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;type&quot;: &quot;lldb&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Debug&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/myvector/build/myvector&quot;,            &quot;args&quot;: [],            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/myvector&quot;,        &#125;    ]&#125;\n\n\nIf breakpoint doesn’t work, use cmake build a debug target.\n\nUse shell:\ncmake .. -DCMAKE_BUILD_TYPE=Debugcmake --build . --config Debug\n\nOr add to CMakeLists.txt :\nset(CMAKE_BUILD_TYPE Debug)\n\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["CPP","Linux","CMake","Clangd"]},{"title":"Neovim 配置","url":"/2023/05/25/note/Linux/Tools/Neovim/","content":"\n\nIntroduction一个vim的社区版本，使用lua语言配置脚本，简单快捷。\n有强大的社区插件支持，可以打造成一个只有自己想要的功能的IDE。\n\n\nInstallationsudo pacman -S neovim\n\nConfigurationinit.luaNeovim allows load init.vim or init.lua in your path ~/.config/nvim.\nLua is a simple and easy using script language, which is very suitable to configure the nvim.\nQuick startThe file directory of neovim configuration:\n$ cd .config/nvim$ tree ..├── init.lua├── lua│   ├── colorscheme.lua│   ├── keymaps.lua│   ├── lsp│   │   └── cmp.lua│   ├── plugin-config│   │   ├── autopairs.lua│   │   ├── bufferline.lua│   │   ├── comment.lua│   │   ├── dashboard.lua│   │   ├── formatter.lua│   │   ├── lualine.lua│   │   ├── mason.lua│   │   ├── nvim-tree.lua│   │   ├── nvim-treesitter.lua│   │   ├── project.lua│   │   └── telescope.lua│   └── plugins.lua└── plugin    └── packer_compiled.lua4 directories, 17 files\n\n基础配置init.luarequire(&quot;plugins&quot;)require(&quot;colorscheme&quot;)require(&quot;keymaps&quot;)require(&quot;plugin-config.nvim-tree&quot;)require(&quot;plugin-config.bufferline&quot;)require(&quot;plugin-config.lualine&quot;)require(&quot;plugin-config.telescope&quot;)require(&quot;plugin-config.dashboard&quot;)require(&quot;plugin-config.project&quot;)require(&quot;plugin-config.nvim-treesitter&quot;)require(&quot;plugin-config.comment&quot;)require(&quot;plugin-config.autopairs&quot;)require(&quot;plugin-config.mason&quot;)require(&quot;plugin-config.formatter&quot;)require(&quot;lsp.cmp&quot;)require(&quot;lspconfig&quot;).pyright.setup(&#123;&#125;)require(&quot;lspconfig&quot;).clangd.setup(&#123;&#125;)-- Set cursor sharpvim.cmd(&quot;set guicursor =i:blinkon150&quot;)vim.g.material_style = &quot;darker&quot;-- utf8vim.g.encoding = &quot;UTF-8&quot;vim.o.fileencoding = &quot;utf-8&quot;-- jkhl 移动时光标周围保留8行vim.o.scrolloff = 8vim.o.sidescrolloff = 8-- 使用相对行号vim.wo.number = truevim.wo.relativenumber = true-- 高亮所在行vim.wo.cursorline = true-- 显示左侧图标指示列vim.wo.signcolumn = &quot;yes&quot;-- 右侧参考线，超过表示代码太长了，考虑换行-- vim.wo.colorcolumn = &quot;80&quot;-- 缩进2个空格等于一个Tabvim.o.tabstop = 4vim.bo.tabstop = 4vim.o.softtabstop = 4vim.o.shiftround = true-- &gt;&gt; &lt;&lt; 时移动长度vim.o.shiftwidth = 4vim.bo.shiftwidth = 4-- 空格替代tabvim.o.expandtab = truevim.bo.expandtab = true-- 新行对齐当前行vim.o.autoindent = truevim.bo.autoindent = truevim.o.smartindent = true-- 搜索大小写不敏感，除非包含大写vim.o.ignorecase = truevim.o.smartcase = true-- 搜索不要高亮vim.o.hlsearch = false-- 边输入边搜索vim.o.incsearch = true-- 命令行高为2，提供足够的显示空间vim.o.cmdheight = 0-- 当文件被外部程序修改时，自动加载vim.o.autoread = truevim.bo.autoread = true-- 禁止折行vim.wo.wrap = false-- 光标在行首尾时&lt;Left&gt;&lt;Right&gt;可以跳到下一行vim.o.whichwrap = &quot;&lt;,&gt;,[,]&quot;-- 允许隐藏被修改过的buffervim.o.hidden = true-- 鼠标支持vim.o.mouse = &quot;a&quot;-- 禁止创建备份文件vim.o.backup = falsevim.o.writebackup = falsevim.o.swapfile = false-- smaller updatetimevim.o.updatetime = 300-- 设置 timeoutlen 为等待键盘快捷键连击时间500毫秒，可根据需要设置vim.o.timeoutlen = 500-- split window 从下边和右边出现vim.o.splitbelow = truevim.o.splitright = true-- 自动补全不自动选中vim.g.completeopt = &quot;menu,menuone,noselect,noinsert&quot;-- 样式vim.o.background = &quot;dark&quot;vim.o.termguicolors = truevim.opt.termguicolors = true-- 不可见字符的显示，这里只把空格显示为一个点vim.o.list = false-- vim.o.listchars = &quot;space: &quot;-- 补全增强vim.o.wildmenu = true-- Dont&#x27; pass messages to |ins-completin menu|vim.o.shortmess = vim.o.shortmess .. &quot;c&quot;-- 补全最多显示10行vim.o.pumheight = 10-- 永远显示 tabline-- vim.o.showtabline = 2-- 使用增强状态栏插件后不再需要 vim 的模式提示vim.o.showmode = false\n\n其中require是lua语言中的关键字，意为调用目录中的某一个lua脚本文件，格式为\nrequire(&quot;something&quot;)-- 这意味着调用了所有环境变量下可能存在的一个名为`something.lua`的脚本文件-- lua会自己搜索所有的路径，寻找这个文件，找不到会返回异常-- 类似于C中的#include\n\nlua脚本中可以直接条用vim script语句，形式如：\nvim.cmd(&quot;set nu&quot;)\n\n或者使用neovim的API：\nvim.o.background = &quot;light&quot;-- 意为全局设置 vim.optionvim.wo.background = &quot;light&quot;-- 意为窗口区设置 vim.window.optionvim.bo.background = &quot;light&quot;-- 意为缓冲区设置 vim.buffer.optionvim.g.mapleader = &quot; &quot;-- 获取或设置全局变量\n\n快捷键映射创建一个lua脚本文件专门用来设置快捷键映射：\ncd ~/.config/nvimmkdir luanvim ./lua/keymaps.lua\n\n编辑此文件：\n-- 设置全局变量“leader”键为空格键vim.g.mapleader = &quot; &quot;vim.g.maplocalleader = &quot; &quot;local map = vim.api.nvim_set_keymap -- 创建快捷键映射函数的别名为“map”local opt = &#123; noremap = true, silent = true &#125; -- 创建一个配置为opt, 非递归映射，且使用时不显示命令-- basic 此为基础设置------------------------------------------------map(&quot;n&quot;, &quot;Q&quot;, &quot;:q&lt;cr&gt;&quot;, opt)map(&quot;n&quot;, &quot;qQ&quot;, &quot;:q!&lt;cr&gt;&quot;, opt)map(&quot;n&quot;, &quot;W&quot;, &quot;:w&lt;cr&gt;&quot;, opt)map(&quot;n&quot;, &quot;S&quot;, &quot;:wq&lt;cr&gt;&quot;, opt)map(&quot;n&quot;, &quot;U&quot;, &quot;:PackerSync&lt;cr&gt;&quot;, opt)map(&quot;n&quot;, &quot;h&quot;, &quot;i&quot;, opt)map(&quot;i&quot;, &quot;jj&quot;, &quot;&lt;esc&gt;&quot;, opt)map(&quot;v&quot;, &quot;jj&quot;, &quot;&lt;esc&gt;&quot;, opt)map(&quot;i&quot;, &quot;ji&quot;, &quot;&lt;esc&gt;la&quot;, opt)-- Orient 修改方向键------------------------------------------------map(&quot;n&quot;, &quot;i&quot;, &quot;k&quot;, opt)map(&quot;n&quot;, &quot;k&quot;, &quot;j&quot;, opt)map(&quot;n&quot;, &quot;j&quot;, &quot;h&quot;, opt)map(&quot;n&quot;, &quot;I&quot;, &quot;5k&quot;, opt)map(&quot;n&quot;, &quot;K&quot;, &quot;5j&quot;, opt)map(&quot;n&quot;, &quot;J&quot;, &quot;5h&quot;, opt)map(&quot;n&quot;, &quot;L&quot;, &quot;5l&quot;, opt)map(&quot;n&quot;, &quot;&lt;C-i&gt;&quot;, &quot;15k&quot;, opt)map(&quot;n&quot;, &quot;&lt;C-k&gt;&quot;, &quot;15j&quot;, opt)map(&quot;n&quot;, &quot;&lt;C-j&gt;&quot;, &quot;15h&quot;, opt)map(&quot;n&quot;, &quot;&lt;C-l&gt;&quot;, &quot;15l&quot;, opt)map(&quot;v&quot;, &quot;i&quot;, &quot;k&quot;, opt)map(&quot;v&quot;, &quot;k&quot;, &quot;j&quot;, opt)map(&quot;v&quot;, &quot;j&quot;, &quot;h&quot;, opt)map(&quot;v&quot;, &quot;I&quot;, &quot;5k&quot;, opt)map(&quot;v&quot;, &quot;K&quot;, &quot;5j&quot;, opt)map(&quot;v&quot;, &quot;J&quot;, &quot;5h&quot;, opt)map(&quot;v&quot;, &quot;L&quot;, &quot;5l&quot;, opt)map(&quot;v&quot;, &quot;&lt;C-i&gt;&quot;, &quot;15k&quot;, opt)map(&quot;v&quot;, &quot;&lt;C-k&gt;&quot;, &quot;15j&quot;, opt)map(&quot;v&quot;, &quot;&lt;C-j&gt;&quot;, &quot;15h&quot;, opt)map(&quot;v&quot;, &quot;&lt;C-l&gt;&quot;, &quot;15l&quot;, opt)-- Split window 分屏------------------------------------------------map(&quot;n&quot;, &quot;s&quot;, &quot;&quot;, opt)-- windows 分屏快捷键map(&quot;n&quot;, &quot;sl&quot;, &quot;:vsp&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;sj&quot;, &quot;:vsp&lt;CR&gt;&lt;C-w&gt;h&quot;, opt)map(&quot;n&quot;, &quot;sk&quot;, &quot;:sp&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;si&quot;, &quot;:sp&lt;CR&gt;&lt;C-w&gt;k&quot;, opt)-- 关闭当前map(&quot;n&quot;, &quot;sc&quot;, &quot;&lt;C-w&gt;c&quot;, opt)-- 关闭其他map(&quot;n&quot;, &quot;so&quot;, &quot;&lt;C-w&gt;o&quot;, opt)-- Alt + hjkl  窗口之间跳转map(&quot;n&quot;, &quot;&lt;A-j&gt;&quot;, &quot;&lt;C-w&gt;h&quot;, opt)map(&quot;n&quot;, &quot;&lt;A-k&gt;&quot;, &quot;&lt;C-w&gt;j&quot;, opt)map(&quot;n&quot;, &quot;&lt;A-i&gt;&quot;, &quot;&lt;C-w&gt;k&quot;, opt)map(&quot;n&quot;, &quot;&lt;A-l&gt;&quot;, &quot;&lt;C-w&gt;l&quot;, opt)-- 左右比例控制map(&quot;n&quot;, &quot;&lt;A-L&gt;&quot;, &quot;:vertical resize -5&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;A-J&gt;&quot;, &quot;:vertical resize +5&lt;cr&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;leader&gt;l&quot;, &quot;:vertical resize -20&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;leader&gt;j&quot;, &quot;:vertical resize +20&lt;CR&gt;&quot;, opt)-- 上下比例map(&quot;n&quot;, &quot;&lt;leader&gt;i&quot;, &quot;:resize +10&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;leader&gt;k&quot;, &quot;:resize -10&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;A-I&gt;&quot;, &quot;:resize +5&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;A-K&gt;&quot;, &quot;:resize -5&lt;CR&gt;&quot;, opt)-- 等比例map(&quot;n&quot;, &quot;s=&quot;, &quot;&lt;C-w&gt;=&quot;, opt)-- Terminal 终端------------------------------------------------map(&quot;n&quot;, &quot;&lt;leader&gt;t&quot;, &quot;:sp | terminal&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;leader&gt;vt&quot;, &quot;:vsp | terminal&lt;CR&gt;&quot;, opt)map(&quot;t&quot;, &quot;&lt;Esc&gt;&quot;, &quot;&lt;C-\\\\&gt;&lt;C-n&gt;&quot;, opt)map(&quot;t&quot;, &quot;&lt;A-j&gt;&quot;, [[ &lt;C-\\&gt;&lt;C-N&gt;&lt;C-w&gt;h ]], opt)map(&quot;t&quot;, &quot;&lt;A-k&gt;&quot;, [[ &lt;C-\\&gt;&lt;C-N&gt;&lt;C-w&gt;j ]], opt)map(&quot;t&quot;, &quot;&lt;A-j&gt;&quot;, [[ &lt;C-\\&gt;&lt;C-N&gt;&lt;C-w&gt;k ]], opt)map(&quot;t&quot;, &quot;&lt;A-l&gt;&quot;, [[ &lt;C-\\&gt;&lt;C-N&gt;&lt;C-w&gt;l ]], opt)-- Visual 在visual模式下的按键-------------------------------------------------- 缩进代码map(&quot;v&quot;, &quot;&lt;&quot;, &quot;&lt;gv&quot;, opt)map(&quot;v&quot;, &quot;&gt;&quot;, &quot;&gt;gv&quot;, opt)-- 上下移动选中文本map(&quot;v&quot;, &quot;&lt;C-K&gt;&quot;, &quot;:move &#x27;&gt;+1&lt;CR&gt;gv-gv&quot;, opt)map(&quot;v&quot;, &quot;&lt;C-I&gt;&quot;, &quot;:move &#x27;&lt;-2&lt;CR&gt;gv-gv&quot;, opt)-- 在visual 模式里粘贴不要复制map(&quot;v&quot;, &quot;p&quot;, &#x27;&quot;_dP&#x27;, opt)-- insert 模式下，跳到行首行尾map(&quot;i&quot;, &quot;&lt;C-j&gt;&quot;, &quot;&lt;ESC&gt;I&quot;, opt)map(&quot;i&quot;, &quot;&lt;C-l&gt;&quot;, &quot;&lt;ESC&gt;A&quot;, opt)-- 插件快捷键local pluginKeys = &#123;&#125; -- 创建插件快捷变量，可以在其他lua文件中调用以下各个插件的快捷键-- nvim-tree-- alt + m 键打开关闭treemap(&quot;n&quot;, &quot;&lt;A-m&gt;&quot;, &quot;:NvimTreeToggle&lt;CR&gt;&quot;, opt)-- 列表快捷键pluginKeys.nvimTreeList = &#123; -- 打开文件或文件夹 &#123; key = &#123; &quot;&lt;CR&gt;&quot;, &quot;o&quot;, &quot;&lt;2-LeftMouse&gt;&quot; &#125;, action = &quot;edit&quot; &#125;, -- 分屏打开文件 &#123; key = &quot;v&quot;, action = &quot;vsplit&quot; &#125;, &#123; key = &quot;h&quot;, action = &quot;split&quot; &#125;, -- 显示隐藏文件 --&#123; key = &quot;i&quot;, action = &quot;toggle_custom&quot; &#125;, -- 对应 filters 中的 custom (node_modules) &#123; key = &quot;.&quot;, action = &quot;toggle_dotfiles&quot; &#125;, -- Hide (dotfiles) -- 文件操作 &#123; key = &quot;&lt;F5&gt;&quot;, action = &quot;refresh&quot; &#125;, &#123; key = &quot;a&quot;, action = &quot;create&quot; &#125;, &#123; key = &quot;d&quot;, action = &quot;remove&quot; &#125;, &#123; key = &quot;r&quot;, action = &quot;rename&quot; &#125;, &#123; key = &quot;x&quot;, action = &quot;cut&quot; &#125;, &#123; key = &quot;c&quot;, action = &quot;copy&quot; &#125;, &#123; key = &quot;p&quot;, action = &quot;paste&quot; &#125;,&#125;-- bufferline-- 左右Tab切换map(&quot;n&quot;, &quot;&lt;C-j&gt;&quot;, &quot;:BufferLineCyclePrev&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;C-l&gt;&quot;, &quot;:BufferLineCycleNext&lt;CR&gt;&quot;, opt)-- 关闭--&quot;moll/vim-bbye&quot;map(&quot;n&quot;, &quot;&lt;C-w&gt;&quot;, &quot;:Bdelete!&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;leader&gt;bl&quot;, &quot;:BufferLineCloseRight&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;leader&gt;bh&quot;, &quot;:BufferLineCloseLeft&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;leader&gt;bc&quot;, &quot;:BufferLinePickClose&lt;CR&gt;&quot;, opt)-- Telescope-- 查找文件map(&quot;n&quot;, &quot;&lt;C-p&gt;&quot;, &quot;:Telescope find_files&lt;CR&gt;&quot;, opt)-- 全局搜索map(&quot;n&quot;, &quot;&lt;C-f&gt;&quot;, &quot;:Telescope live_grep&lt;CR&gt;&quot;, opt)pluginKeys.telescopeList = &#123; i = &#123;  -- 上下移动  [&quot;&lt;C-k&gt;&quot;] = &quot;move_selection_next&quot;,  [&quot;&lt;C-i&gt;&quot;] = &quot;move_selection_previous&quot;,  [&quot;&lt;Down&gt;&quot;] = &quot;move_selection_next&quot;,  [&quot;&lt;Up&gt;&quot;] = &quot;move_selection_previous&quot;,  -- 历史记录  [&quot;&lt;C-n&gt;&quot;] = &quot;cycle_history_next&quot;,  [&quot;&lt;C-p&gt;&quot;] = &quot;cycle_history_prev&quot;,  -- 关闭窗口  [&quot;&lt;C-c&gt;&quot;] = &quot;close&quot;,  [&quot;&lt;Esc&gt;&quot;] = &quot;close&quot;,  -- 预览窗口上下滚动  [&quot;&lt;C-u&gt;&quot;] = &quot;preview_scrolling_up&quot;,  [&quot;&lt;C-d&gt;&quot;] = &quot;preview_scrolling_down&quot;, &#125;,&#125;-- Lsp Mappings 待看-- See `:help vim.diagnostic.*` for documentation on any of the below functionsvim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;e&#x27;, vim.diagnostic.open_float, opts)vim.keymap.set(&#x27;n&#x27;, &#x27;[d&#x27;, vim.diagnostic.goto_prev, opts)vim.keymap.set(&#x27;n&#x27;, &#x27;]d&#x27;, vim.diagnostic.goto_next, opts)vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;q&#x27;, vim.diagnostic.setloclist, opts)-- Use an on_attach function to only map the following keys-- after the language server attaches to the current bufferlocal on_attach = function(client, bufnr)  -- Enable completion triggered by &lt;c-x&gt;&lt;c-o&gt;  vim.api.nvim_buf_set_option(bufnr, &#x27;omnifunc&#x27;, &#x27;v:lua.vim.lsp.omnifunc&#x27;)  -- Mappings.  -- See `:help vim.lsp.*` for documentation on any of the below functions  local bufopts = &#123; noremap=true, silent=true, buffer=bufnr &#125;  vim.keymap.set(&#x27;n&#x27;, &#x27;gD&#x27;, vim.lsp.buf.declaration, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;gd&#x27;, vim.lsp.buf.definition, bufopts)map(&quot;n&quot;, &quot;gh&quot;, vim.lsp.buf.hover, opt)  vim.keymap.set(&#x27;n&#x27;, &#x27;gh&#x27;, vim.lsp.buf.hover, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;gi&#x27;, vim.lsp.buf.implementation, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;C-k&gt;&#x27;, vim.lsp.buf.signature_help, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;wa&#x27;, vim.lsp.buf.add_workspace_folder, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;wr&#x27;, vim.lsp.buf.remove_workspace_folder, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;wl&#x27;, function()    print(vim.inspect(vim.lsp.buf.list_workspace_folders()))  end, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;D&#x27;, vim.lsp.buf.type_definition, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;rn&#x27;, vim.lsp.buf.rename, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;ca&#x27;, vim.lsp.buf.code_action, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;gr&#x27;, vim.lsp.buf.references, bufopts)  vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;f&#x27;, function() vim.lsp.buf.format &#123; async = true &#125; end, bufopts)endlocal lsp_flags = &#123;  -- This is the default in Nvim 0.7+  debounce_text_changes = 150,&#125;require(&#x27;lspconfig&#x27;)[&#x27;pyright&#x27;].setup&#123;    on_attach = on_attach,    flags = lsp_flags,&#125;require(&#x27;lspconfig&#x27;)[&#x27;clangd&#x27;].setup&#123;    on_attach = on_attach,    flags = lsp_flags,&#125;-- nvim-cmp 自动补全pluginKeys.cmp = function(cmp) local feedkey = function(key, mode)  vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(key, true, true, true), mode, true) end local has_words_before = function()  local line, col = unpack(vim.api.nvim_win_get_cursor(0))  return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match(&quot;%s&quot;) == nil end return &#123;  -- 自定义代码段跳转到下一个参数  [&quot;&lt;C-l&gt;&quot;] = cmp.mapping(function(_)   if vim.fn[&quot;vsnip#available&quot;](1) == 1 then    feedkey(&quot;&lt;Plug&gt;(vsnip-expand-or-jump)&quot;, &quot;&quot;)   end  end, &#123; &quot;i&quot;, &quot;s&quot; &#125;),  -- 自定义代码段跳转到上一个参数  [&quot;&lt;C-h&gt;&quot;] = cmp.mapping(function()   if vim.fn[&quot;vsnip#jumpable&quot;](-1) == 1 then    feedkey(&quot;&lt;Plug&gt;(vsnip-jump-prev)&quot;, &quot;&quot;)   end  end, &#123; &quot;i&quot;, &quot;s&quot; &#125;),  -- Super Tab  [&quot;&lt;Tab&gt;&quot;] = cmp.mapping(function(fallback)   if cmp.visible() then    cmp.select_next_item()   elseif vim.fn[&quot;vsnip#available&quot;](1) == 1 then    feedkey(&quot;&lt;Plug&gt;(vsnip-expand-or-jump)&quot;, &quot;&quot;)   elseif has_words_before() then    cmp.complete()   else    fallback() -- The fallback function sends a already mapped key. In this case, it&#x27;s probably `&lt;Tab&gt;`.   end  end, &#123; &quot;i&quot;, &quot;s&quot; &#125;),  [&quot;&lt;S-Tab&gt;&quot;] = cmp.mapping(function()   if cmp.visible() then    cmp.select_prev_item()   elseif vim.fn[&quot;vsnip#jumpable&quot;](-1) == 1 then    feedkey(&quot;&lt;Plug&gt;(vsnip-jump-prev)&quot;, &quot;&quot;)   end  end, &#123; &quot;i&quot;, &quot;s&quot; &#125;),  -- end of super Tab &#125;end-- formatmap(&quot;n&quot;, &quot;&lt;leader&gt;f&quot;, &quot;:Format&lt;CR&gt;&quot;, opt)map(&quot;n&quot;, &quot;&lt;leader&gt;F&quot;, &quot;:FormatWrite&lt;CR&gt;&quot;, opt)return pluginKeys\n\n插件及插件管理器单纯使用neovim的自带功能太过单薄，社区有许多令人赏心悦目的插件可供使用，插件的安装依赖一个插件管理器，目前最流行的插件管理器是packer.nvim。\n安装packer.nvim,在shell中执行：\ngit clone --depth 1 https://ghproxy.com/https://github.com/wbthomason/packer.nvim ~/.local/share/nvim/site/pack/packer/start/packer.nvimnvim ~/.config/nvim/lua/plugins.lua\n\n编辑plugins.lua文件为：\n-- This file can be loaded by calling `lua require(&#x27;plugins&#x27;)` from your init.vim-- Only required if you have packer configured as `opt`vim.cmd([[packadd packer.nvim]])return require(&quot;packer&quot;).startup(function(use) -- Packer can manage itself use(&quot;wbthomason/packer.nvim&quot;) -- file tree use(&#123; &quot;kyazdani42/nvim-tree.lua&quot;, requires = &quot;kyazdani42/nvim-web-devicons&quot; &#125;) -- colorscheme ------------------------------------------------------------------------------------- -- tokyonight use(&quot;folke/tokyonight.nvim&quot;) -- OceanicNext use(&quot;mhartington/oceanic-next&quot;) -- gruvbox use(&#123; &quot;ellisonleao/gruvbox.nvim&quot;, requires = &#123; &quot;rktjmp/lush.nvim&quot; &#125; &#125;) -- nord use(&quot;shaunsingh/nord.nvim&quot;) -- onedark use(&quot;ful1e5/onedark.nvim&quot;) -- nightfox use(&quot;EdenEast/nightfox.nvim&quot;) -- github use(&quot;projekt0n/github-nvim-theme&quot;) -- material use(&quot;marko-cerovac/material.nvim&quot;) -- one_monokai use(&quot;cpea2506/one_monokai.nvim&quot;) use(&quot;lourenci/github-colors&quot;) --buffer line use(&#123; &quot;akinsho/bufferline.nvim&quot;, requires = &#123; &quot;kyazdani42/nvim-web-devicons&quot;, &quot;moll/vim-bbye&quot; &#125; &#125;) -- lualine use(&#123; &quot;nvim-lualine/lualine.nvim&quot;, requires = &#123; &quot;kyazdani42/nvim-web-devicons&quot; &#125; &#125;) use(&quot;arkav/lualine-lsp-progress&quot;) -- telescope FILE FINDER use(&#123; &quot;nvim-telescope/telescope.nvim&quot;, requires = &#123; &quot;nvim-lua/plenary.nvim&quot; &#125; &#125;) -- dashboard-nvim use(&quot;glepnir/dashboard-nvim&quot;) -- project use(&quot;ahmedkhalf/project.nvim&quot;) -- treesitter use(&#123;  &quot;nvim-treesitter/nvim-treesitter&quot;,  run = &quot;:TSUpdate&quot;,  -- config = function()  --  require(&quot;nvim-treesitter.configs&quot;).setup(&#123;  --   highlight = &#123;  --    enable = true,  --   &#125;,  --  &#125;)  -- end, &#125;) -- Comment use(&#123;  &quot;numToStr/Comment.nvim&quot;,  config = function()   require(&quot;Comment&quot;).setup()  end, &#125;) -- Lspconfig use(&#123; &quot;neovim/nvim-lspconfig&quot; &#125;) -- 补全引擎 use(&quot;hrsh7th/nvim-cmp&quot;) -- snippet 引擎 use(&quot;hrsh7th/vim-vsnip&quot;) -- 补全源 use(&quot;hrsh7th/cmp-vsnip&quot;) use(&quot;hrsh7th/cmp-nvim-lsp&quot;) -- &#123; name = nvim_lsp &#125; use(&quot;hrsh7th/cmp-buffer&quot;) -- &#123; name = &#x27;buffer&#x27; &#125;, use(&quot;hrsh7th/cmp-path&quot;) -- &#123; name = &#x27;path&#x27; &#125; use(&quot;hrsh7th/cmp-cmdline&quot;) -- &#123; name = &#x27;cmdline&#x27; &#125; -- 常见编程语言代码段 use(&quot;rafamadriz/friendly-snippets&quot;) -- auto-pairs use(&quot;windwp/nvim-autopairs&quot;) -- lsp-spport use(&#123; &quot;williamboman/mason.nvim&quot; &#125;) -- formatter use(&#123; &quot;mhartington/formatter.nvim&quot; &#125;)end)\n\n保存后重新打开nvim，然后在normal模式下，输入:PackerSync，回车即可开始安装插件。\n若有现有插件与配置文件中所列的插件不同，Packer.nvim会询问是否删除不用的插件，直接回车即可。（默认是不删除）\n配置插件创建存放插件配置文件的文件夹：\nmkdir ~/.config/nvim/lua/plugin-config\n\nnvim-tree在plugins.lua中加入use(&#123; &quot;kyazdani42/nvim-tree.lua&quot;, requires = &quot;kyazdani42/nvim-web-devicons&quot; &#125;)来启用此插件。\nnvim ~/.config/nvim/lua/plugin-config/nvim-tree.lua\n\n添加以下配置信息：\nlocal status, nvim_tree = pcall(require, &quot;nvim-tree&quot;)if not status then    vim.notify(&quot;没有找到 nvim-tree&quot;)  returnend-- 以上是一个经典的插件配置调用函数-- 先创建一个本地变量status, nvim_tree-- 变量的值为函数pcall的返回值-- pcall函数的参数是require一个函数“nvim-tree”-- 如果成功，返回true，失败，则返回false-- 下面是一个if判断语句，如果调用成功（即status为true），继续往下走读取配置信息，如果调用失败，则直接return，跳出此脚本-- 列表操作快捷键local list_keys = require(&#x27;keymaps&#x27;).nvimTreeListnvim_tree.setup(&#123;    -- 是否显示 git 状态图标    git = &#123;        enable = true,    &#125;,    -- project plugin 需要这样设置    update_cwd = true,    update_focused_file = &#123;        enable = true,        update_cwd = true,    &#125;,    -- 隐藏 .文件 和 node_modules 文件夹    filters = &#123;        dotfiles = false,        custom = &#123; &#x27;node_modules&#x27; &#125;,    &#125;,    view = &#123;        -- 宽度        width = 30,        -- 也可以 &#x27;right&#x27;        side = &#x27;left&#x27;,        -- 隐藏根目录        hide_root_folder = false,        -- 自定义列表中快捷键        mappings = &#123;            custom_only = false,            list = list_keys,        &#125;,        -- 不显示行数        number = false,        relativenumber = false,        -- 显示图标        signcolumn = &#x27;yes&#x27;,    &#125;,    actions = &#123;        open_file = &#123;            -- 首次打开大小适配            resize_window = true,            -- 打开文件时关闭            quit_on_open = true,        &#125;,    &#125;,    -- wsl install -g wsl-open    -- https://github.com/4U6U57/wsl-open/    system_open = &#123;        cmd = &#x27;open&#x27;, -- mac 直接设置为 open    &#125;,    -- project plugin     update_cwd = true,    update_focused_file = &#123;      enable = true,      update_cwd = true,    &#125;,&#125;)-- 设置打开文件时自动关闭vim.cmd([[  autocmd BufEnter * ++nested if winnr(&#x27;$&#x27;) == 1 &amp;&amp; bufname() == &#x27;NvimTree_&#x27; . tabpagenr() | quit | endif]])\n","categories":["经验与技巧与踩坑 · 杂项","Code-Editor"],"tags":["Linux","Termux","Vim","Neovim","IDE"]},{"title":"Linux下Chromium恢复登陆","url":"/2024/05/27/note/Linux/Tools/chromium/","content":"\n摘自https://stackoverflow.com/questions/67459316/enabling-chromium-to-sync-with-google-account\n\n\n\n编辑\nvim ~/.config/chromium-flags.conf \n\n内容为：\n--oauth2-client-id=77185425430.apps.googleusercontent.com--oauth2-client-secret=OTJgUOQcT7lO7GsGZq2G4IlT\n\n重启浏览器即可。\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Chromium","Tools"]},{"title":"Linux配置clash","url":"/2024/05/27/note/Linux/Tools/clash/","content":"下载安装Clash for Linux\n这里有各个平台的Clash下载地址。\n\n\n\ncd &amp;&amp; mkdir clashcd clashwget https://git.opclash.com/kehuduan/clash/clash-linux-amd64-v1.18.0.gz# 解压文件gzip -d clash-linux-amd64-v1.18.0.gz# 给予权限chmod +x clash-linux-amd64-v1.18.0# 改名移动mv clash-linux-amd64-v1.18.0 /usr/local/bin/clash# 查看版本clash -v# 首次启动clash// INFO[0000] Can&#x27;t find config, create a initial config file // INFO[0000] Can&#x27;t find MMDB, start download              // ERRO[0002] create addr 127.0.0.1:7890 tcp listener error. err:listen tcp 127.0.0.1:7890: bind: address already in use// 启动 clash 提示以上错误，你就直接使用 ctrl+c 跳过执行 cd $HOME/.config/clash/\n\n创建配置文件路径为：~/.config/clash/config.yaml，可以从window端的clash复制过来，同时复制一份到root用户的对应目录。\n下载mmdb然后放到~/.config/clash中，命名为Country.mmdb。\n编写systemd服务脚本在 /lib/systemd/system/ 目录下创建 clash@.service 文件\nsudo vim /lib/systemd/system/clash@.service\n\n写入以下内容并保存:\n[Unit]Description=A rule based proxy in Go for %i.After=network.target[Service]Type=simpleUser=%iRestart=on-abortExecStart=/usr/bin/clash[Install]WantedBy=multi-user.target\n\n为用户帐户运行 clash 系统实例重新加载 systemd 模块systemctl daemon-reload\n\n启动 clash 服务\nuser 表示的是当前用户名\n\nsystemctl start clash@user\n\n例如：\nsystemctl start clash@dionysen\n\n设置开机自启systemctl enable clash@user\n\n问题权限不足\n$ sudo systemctl status clash● clash.service - A rule based proxy in Go for shitao.   Loaded: loaded (/usr/lib/systemd/system/clash.service; disabled; vendor preset: disabled)   Active: failed (Result: exit-code) since Tue 2019-06-18 17:27:18 CST; 4s ago  Process: 6777 ExecStart=/usr/bin/clash (code=exited, status=203/EXEC) Main PID: 6777 (code=exited, status=203/EXEC)Jun 18 17:27:18 localhost.localdomain systemd[1]: Started A rule based proxy in Go for shitao..Jun 18 17:27:18 localhost.localdomain systemd[6777]: clash.service: Failed to execute command: Permission deniedJun 18 17:27:18 localhost.localdomain systemd[6777]: clash.service: Failed at step EXEC spawning /usr/bin/clash: Permission deniedJun 18 17:27:18 localhost.localdomain systemd[1]: clash.service: Main process exited, code=exited, status=203/EXECJun 18 17:27:18 localhost.localdomain systemd[1]: clash.service: Failed with result &#x27;exit-code&#x27;.\n\n修改 selinux 成被动模式\nsudo vim /etc/sysconfig/selinux\n\nSELINUX=permissive\n\n环境变量# 配置环境变量echo -e &quot;export http_proxy=http://127.0.0.1:7890\\nexport https_proxy=http://127.0.0.1:7890&quot; &gt;&gt; ~/.bashrc# orecho -e &quot;export http_proxy=http://127.0.0.1:7890\\nexport https_proxy=http://127.0.0.1:7890&quot; &gt;&gt; ~/.zshrc\n\n在设置中将代理设置为手动:\n# HTTP 代理127.0.0.1:7890# HTTPS 代理127.0.0.1:7890# Socks 主机127.0.0.1:7891\n\n节点管理# 节点管理的地址为http://clash.razord.top/#/proxies\n\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Typora","Tools"]},{"title":"Linux安装typora","url":"/2024/05/27/note/Linux/Tools/typora/","content":"下载安装Typorawget https://download2.typoraio.cn/linux/typora_1.8.10_amd64.deb --output-document typora.deb# or Archlinuxyay -S typora\n\n\n\n克隆破解项目git clone https://github.com/hazukieq/Yporaject.git\n\n安装Rust#运行官方脚本安装curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh#检查cargo，若看到如下版本信息，则说明配置成功cargo -Vcargo 1.70.0 (ec8a8a0ca 2023-04-25)\n\n编译项目#进入Yporaject项目cd Yporaject#运行编译命令cargo build#查看二进制是否生成,程序名称为 node_injectls target/debug#尝试运行该二进制程序cargo runoutput: no node_modules.asar foundmove me to the root of your typora installation(the same directory as executable of electron)\n\n将编译好的可执行文件复制到Typora的安装目录#复制二进制程序到相关目录下sudo cp target/debug/node_inject /usr/share/typora#进入相关目录cd /usr/share/typora#给予二进制程序执行权限sudo chmod +x node_inject#检查二进制程序是否可以运行,并执行(请注意程序运行输出信息，观察是否运行成功！！)#若无读写权限,建议使用 sudo ./node_injectsudo ./node_inject\n\n获取激活码bash#返回项目cd $cur#进入 license-gen 文件夹cd license-gen#编译代码cargo build#运行二进制程序cargo run\n\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Linux","Typora","Tools"]},{"title":"V2rayA","url":"/2023/05/25/note/Linux/Tools/v2raya/","content":"On archlinux:\nyay -S xray-binsudo pacman -S v2rayyay -S v2raya-bin\n\nMaybe you need restart your computer!\n\n\nAnd config:\n\n\n\n项目\n配置\n\n\n\n透明代理&#x2F;系统代理\n启用：大陆白名单模式\n\n\n透明代理&#x2F;系统代理实现方式\nredirect\n\n\n规则端口的分流模式\n大陆白名单模式\n\n\n防止 DNS 污染\n仅防止 DNS 劫持\n\n\n特殊模式\nsupervisor\n\n\nTCPFastOpen\n保持系统默认\n\n\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["VPN","Proxy"]},{"title":"vim 配置","url":"/2023/06/09/note/Linux/Tools/vim/","content":"\n\n使用以下脚本一键配置：\n#!/bin/bashgit clone https://gitee.com/sential/vim_config_cpp.gitcd vim_config_cppmv ./.vim ~/.vim\n\n完成后打开vim，按:PlugInstall，然后回车，即可安装插件（需梯子）。\n\n\n配置文件\n以下为vimrc的全部内容：\n&quot; ------ Basic Setting ------set ts=4set shiftwidth=4set softtabstop=4set numberset expandtabset autoindentset noebset scrolloff=5set t_Co=256set wildmenuset smartcaseset cursorlineset encoding=utf-8 &quot; ------ Theme Setting ------set background=darkhi cursorLine cterm=underline ctermbg=darkred ctermfg=white set relativenumber&quot; locate the point at last time; And set &#x27;sudo chmod 777 ~/.viminfo&#x27; au BufReadPost * if line(&quot;&#x27;\\&quot;&quot;) &gt; 0|if line(&quot;&#x27;\\&quot;&quot;) &lt;= line(&quot;$&quot;)|exe(&quot;norm &#x27;\\&quot;&quot;)|else|exe &quot;norm $&quot;|endif|endif&quot; airline setting&quot; let g:airline#extensions#tabline#formatter = &#x27;default&#x27;&quot; let g:airline#extensions#tabline#enabled = 1&quot; let g:airline_theme=&#x27;&#x27;&quot; powerline symbolslet g:airline_left_sep = &#x27;&#x27;let g:airline_left_alt_sep = &#x27;&#x27;let g:airline_right_sep = &#x27;&#x27;let g:airline_right_alt_sep = &#x27;&#x27;&quot; colorscheme monokai&quot; runtime plugged/material.vim/colors/material.vimruntime plugged/gruvbox/colors/gruvbox.vim&quot; runtime colors/monokai.vim/colors/monokai.vim&quot; runtime plugged/vim-snazzy/colors/snazzy.vim&quot; material theme &quot; if (has(&#x27;termguicolors&#x27;))&quot;   set termguicolors&quot; endiflet g:material_theme_style = &#x27;default&#x27;set laststatus=2set noshowmode&quot; let g:lightline = &#123;&quot;       \\ &#x27;colorscheme&#x27;: &#x27;material_vim&#x27;,&quot;       \\ &#x27;active&#x27;: &#123;&quot;       \\   &#x27;left&#x27;: [ [ &#x27;mode&#x27;, &#x27;paste&#x27; ],&quot;       \\             [ &#x27;gitbranch&#x27;, &#x27;readonly&#x27;, &#x27;filename&#x27;, &#x27;modified&#x27; ] ]&quot;       \\ &#125;,&quot;       \\ &#x27;component_function&#x27;: &#123;&quot;       \\   &#x27;gitbranch&#x27;: &#x27;FugitiveHead&#x27;&quot;       \\ &#125;,&quot;       \\ &#125;&quot; ------------------------------------------------------------------------&quot; ------ Plug Index ------:call plug#begin(&#x27;~/.vim/plugged&#x27;)&quot; airlinePlug &#x27;vim-airline/vim-airline&#x27;Plug &#x27;vim-airline/vim-airline-themes&#x27;&quot;Plug &#x27;itchyny/lightline.vim&#x27;Plug &#x27;skywind3000/vim-terminal-help&#x27;&quot; vim-themesPlug &#x27;junegunn/seoul256.vim&#x27;Plug &#x27;kaicataldo/material.vim&#x27;, &#123; &#x27;branch&#x27;: &#x27;main&#x27; &#125;Plug &#x27;hzchirs/vim-material&#x27;Plug &#x27;arcticicestudio/nord-vim&#x27;Plug &#x27;rakr/vim-one&#x27;Plug &#x27;morhetz/gruvbox&#x27;Plug &#x27;preservim/nerdcommenter&#x27;Plug &#x27;connorholyday/vim-snazzy&#x27;Plug &#x27;jiangmiao/auto-pairs&#x27;Plug &#x27;rhysd/vim-clang-format&#x27;Plug &#x27;artur-shaik/vim-javacomplete2&#x27;&quot; File navigationPlug &#x27;scrooloose/nerdtree&#x27;, &#123; &#x27;on&#x27;: &#x27;NERDTreeToggle&#x27; &#125;Plug &#x27;Xuyuanp/nerdtree-git-plugin&#x27;&quot; Find Plug &#x27;Yggdroot/LeaderF&#x27;, &#123; &#x27;do&#x27;: &#x27;./install.sh&#x27; &#125;&quot;TaglistPlug &#x27;majutsushi/tagbar&#x27;, &#123; &#x27;on&#x27;: &#x27;TagbarOpenAutoClose&#x27; &#125;&quot; Undo TreePlug &#x27;mbbill/undotree/&#x27;&quot; MarkdownPlug &#x27;iamcco/markdown-preview.nvim&#x27;, &#123; &#x27;do&#x27;: &#123; -&gt; mkdp#util#install_sync() &#125;, &#x27;for&#x27; :[&#x27;markdown&#x27;, &#x27;vim-plug&#x27;] &#125;Plug &#x27;dhruvasagar/vim-table-mode&#x27;, &#123; &#x27;on&#x27;: &#x27;TableModeToggle&#x27; &#125;Plug &#x27;iamcco/mathjax-support-for-mkdp&#x27;Plug &#x27;vimwiki/vimwiki&#x27;&quot; BookmarksPlug &#x27;kshenoy/vim-signature&#x27;&quot; c++ hightlightPlug &#x27;nvim-treesitter/nvim-treesitter&#x27;, &#123;&#x27;do&#x27;: &#x27;:TSUpdate&#x27;&#125;&quot;Coc Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;&quot;cmakePlug &#x27;cdelledonne/vim-cmake&#x27;call plug#end()&quot; ------ Coc-setting ------let g:coc_global_extensions = [&#x27;coc-clangd&#x27;, &#x27;coc-vimlsp&#x27; ]&quot; ------ 让tab可以补全 ------ inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;      \\ pumvisible() ? &quot;\\&lt;C-n&gt;&quot; :      \\ &quot;\\&lt;TAB&gt;&quot; inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\\&lt;C-p&gt;&quot; : &quot;\\&lt;C-h&gt;&quot;&quot; ------ Replace Esc ------ inoremap jj &lt;ESC&gt;vnoremap jj &lt;ESC&gt; &quot; ------ 方向键 ------ noremap i knoremap I 5knoremap K 5jnoremap k jnoremap j hnoremap h inoremap J 5hnoremap L 5lnoremap &lt;C-K&gt; 15jnoremap &lt;C-I&gt; 15knoremap &lt;C-J&gt; 15hnoremap &lt;C-L&gt; 15lnoremap \u0018@si 30knoremap \u0018@sk 30jnoremap \u0018@sj 30hnoremap \u0018@sl 30lnoremap H I&quot; ------ 括号自动对应 ------ inoremap ( ()&lt;ESC&gt;iinoremap ) &lt;c-r&gt;=ClosePair(&#x27;)&#x27;)&lt;CR&gt;inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;Oinoremap &#125; &lt;c-r&gt;=ClosePair(&#x27;&#125;&#x27;)&lt;CR&gt;inoremap [ []&lt;ESC&gt;iinoremap ] &lt;c-r&gt;=ClosePair(&#x27;]&#x27;)&lt;CR&gt;inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i&quot; ------ 删除括号时自动删除对应的另一半 ------ function! ClosePair(char)    if getline(&#x27;.&#x27;)[col(&#x27;.&#x27;) - 1] == a:char        return &quot;\\&lt;Right&gt;&quot;    else        return a:char    endifendfunction&quot; ------ Other setting ------ &quot; j+i jump out braceimap ji jjla&quot; leader keylet mapleader=&quot;\\&lt;space&gt;&quot;&quot; setting backspace to reindentset backspace=indent,eol,start&quot; ------ Exit, Write, Save, Resource ------ map Q :q!&lt;CR&gt;map W :w&lt;CR&gt;map S :wq&lt;CR&gt;map R :source ~/.vim/vimrc&lt;CR&gt;&quot; ------ 分屏与标签页 ------ map sl :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;map sj :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;map si :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;map sk :set splitbelow&lt;CR&gt;:split&lt;CR&gt;&quot;分屏切换&quot; \u001b 表示alt键  但不可直接键入 需在insert模式下，按ctrl+v 再按要映射的快捷键map \u001bl &lt;C-w&gt;lmap \u001bi &lt;C-w&gt;kmap \u001bj &lt;C-w&gt;hmap \u001bk &lt;C-w&gt;jmap sv &lt;C-w&gt;t&lt;C-w&gt;Hmap sh &lt;C-w&gt;t&lt;C-w&gt;K&quot;分屏大小map \u001bI :res +5&lt;CR&gt;map \u001bK :res -5&lt;CR&gt;map \u001bL :vertical resize-5&lt;CR&gt;map \u001bJ :vertical resize+5&lt;CR&gt;&quot;标签页map tn :tabe&lt;CR&gt;map tj :-tabnext&lt;CR&gt;map tl :+tabnext&lt;CR&gt;&quot; ------ terminal ------ nnoremap &lt;leader&gt;t :terminal&lt;CR&gt;&quot; ------ NERDTree configuration ------ nnoremap \u001bn :NERDTreeFocus&lt;CR&gt;nnoremap &lt;C-n&gt; :NERDTree&lt;CR&gt;nnoremap &lt;C-t&gt; :NERDTreeToggle&lt;CR&gt;nnoremap &lt;C-f&gt; :NERDTreeFind&lt;CR&gt;let NERDTreeMapOpenSplit=&#x27;h&#x27;let NERDTreeMapJumpFirstChild=&#x27;F&#x27;let NERDTreeMapToggleHidden=&quot;H&quot;&quot; ------ clang-format ------ nnoremap cf :ClangFormat&lt;CR&gt;nnoremap &lt;C-d&gt; :CocCommand clangd.switchSourceHeader&lt;CR&gt;&quot; ------ markdown preview ------ nmap &lt;C-s&gt; &lt;Plug&gt;MarkdownPreviewnmap &lt;M-s&gt; &lt;Plug&gt;MarkdownPreviewStopnmap &lt;C-p&gt; &lt;Plug&gt;MarkdownPreviewToggle\n\n快捷键使用方向-光标移动\n\n\n操作\n快捷键\n\n\n\n上\ni\n\n\n下\nk\n\n\n左\nj\n\n\n右\nl\n\n\n5倍移动\nshift + i/j/k/l\n\n\n15倍移动\nctrl + i/j/k/l\n\n\n如快速向下翻页，就按ctrl + k。\n模式切换\n\n\n操作\n快捷键\n\n\n\n普通模式—&gt;插入模式\nh\n\n\n普通模式—&gt;视图模式\nv\n\n\n任意模式—&gt;普通模式\njj（快速按两下j）\n\n\n分屏与标签页\n\n\n操作\n快捷键\n\n\n\n分屏\ns+ 方向键 （如sj是向左分屏）\n\n\n切换分屏\nalt + 方向键（如alt + j是切换到相邻左边的分屏）\n\n\n分屏大小\nalt + shift + 方向键（上加下减，左加右减）\n\n\n切换分屏排列方式（垂直或水平）\nsv、sh\n\n\n新建标签页\ntn\n\n\n切换标签页（左右切换）\nt + j/l\n\n\n文件树\n\n\n操作\n快捷键\n\n\n\n打开文件树窗口（聚焦到文件树窗口）\nctrl + n\n\n\n文件选择（上下移动光标）\ni/k\n\n\n在当前窗口打开文件\no\n\n\n在新的分屏中打开文件\nh\n\n\n其他\n\n\n操作\n快捷键\n\n\n\n打开或关闭终端窗口\nalt + +\n\n\nClang-format格式化当前文件的代码（c&#x2F;cpp）\ncf\n\n\n头文件与源文件切换\nctrl + d\n\n\n开启Markdown预览（使用默认浏览器打开）\nctrl + p\n\n\n插入模式下跳出括号\nji\n\n\n强制退出（文件如未更改直接退出，有更改放弃更改直接退出）\nshift + q\n\n\n保存修改\nshift + w\n\n\n保存修改然后退出\nshift + s\n\n\n重新加载vimrc配置文件\nshift + r\n\n\n注释（一行或选中区域）\nspace + cc\n\n\n解除注释（一行或选中区域）\nspace + cu\n\n\nvim本身的常用快捷键\n这些快捷是Vim本身的，未重新映射\n\n\n\n\n普通模式或视图模式下操作（注意在插入模式下不可用）\n快捷键\n\n\n\n在当前字母后插入\na\n\n\n剪切光标所在的字母\ns\n\n\n剪切光标所在行\ndd\n\n\n剪切光标选中区域\nd\n\n\n使用另一个字母替换光标所在字母\nr + 另一个字母\n\n\n复制光标选中区\ny\n\n\n复制光标所在行\nyy\n\n\n粘贴\np\n\n\n光标移动到下一个单词\nw\n\n\n光标移动到上一个单词\nb\n\n\n聚焦到文首\ngg\n\n\n聚焦到文末\nG\n\n\n搜索\n:/ + 要搜索的文本\n\n\n","categories":["经验与技巧与踩坑 · 杂项","Code-Editor"],"tags":["Linux","Termux","Vim","IDE"]},{"title":"Ftp","url":"/2023/05/25/note/Linux/shell_command/FTP/","content":"\nFile Transfer Protocol client.\n\n\n\n\n\n\nOption\nImplication\n\n\n\n-4\ncontact IPv4 hosts\n\n\n-6\ncontact IPv6 hosts\n\n\n-A\nenable active mode transfer\n\n\n-d\nenbale debugging outpout\n\n\n-e\ndisble command line editing\n\n\n-g\nturn off file name globbing\n\n\n-i\ndo not prompt during multiple file\n\n\n-n\ndo not automatically login to the remote system\n\n\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["Protocol","Linux"]},{"title":"SCP protocol","url":"/2023/05/25/note/Linux/shell_command/SCP/","content":"scp copies files between hosts on a network.\n\n\nscpIt uses ssh for data transfer, and uses the same authentication and provides the same security as a login session.\nscp will ask for passwords or passphrases if they are needed for authentication.\nThe source and target may be specified as a local pathname, a remote host with optional path in the form [user@]host:[path], or a URI in the form scp://[user@]host[:port][/path].\n\nLocal file names can be made explicit using absolute or relative pathnames to avoid scp treating file names containing ‘:‘ as host speacifiers.\n\nWhen copying between two remote hosts, if the URI format is used, a port cannot be specified on the target if the -R option is used.\n\n\n\nOptions\nImplication\n\n\n\n-3\nCopies between two remote hosts are transferred through the local host.  Without this option the data is copied directly between the two remote hosts.\n\n\n-4\nForces scp to use IPv4 addresses only\n\n\n-6\nForces scp to use IPv6 addresses only\n\n\n-A\nAllows forwarding of ssh-agent(1) to the remote system.  The default is not to forward an authentication agent.\n\n\n-C\nCompression enable\n\n\n-l\nLimits the used bandwidth, specified in Kbit&#x2F;s\n\n\n","categories":["经验与技巧与踩坑 · 杂项","Linux"],"tags":["SCP","SSH"]},{"title":"借个火","url":"/2020/05/10/note/Literature/%E5%B0%8F%E8%AF%B4/%E5%80%9F%E4%B8%AA%E7%81%AB/","content":"碟子洗完之前，我习惯性地抬头向窗外望去。\n还有两个池子的餐具要刷，我却已经神游在想象中的世界里了。\n餐厅的老板，是一个中规中矩的英国人，门面装饰得毫无新意。小巧的门厅，拥挤的桌凳，使得来吃饭的人是不多的。多的，是把小餐厅当作咖啡馆的学生。聊天，抑或聚会，狭促而封闭的空间，总能给人安全感。当然，最重要的，是价廉。\n作为为数不多的，独自漂到英国生活的年轻人，所面临的困境暂且不谈。这样的店，这样的老板，已是我幸中之幸。\n\n\n三个星期，我经手了大多数人一辈子都无法企及的餐具数量。像祛雀斑一样，每刷完一个盘子，我都会感到洁净带来的清爽。\n——而刷完一整池的盘子，我则会感到难以抑制的反胃。\n排气扇的旁边，有一个窗口，与国内不同，没有防盗栅。我能清晰地看到对面的那个墓园。每到这个时候，我便隔着窗子，看墓园中的那个人。\n二十天了，每天这个时候，他都会出现在那儿。林立的墓碑之中，青色的鲜草还没爬满地面，零落的石块儿伛偻着，生机与死气交融。背对着我，只能看到他穿着褐色的长衣，头上是一顶略显破旧的礼帽，佛像一般立在一面墓碑旁边。\n像极了十七世纪英国的绅士，古典而庄严。\n如果不是在某一天，一个女人的倩影代替了他，我真怀疑他就是个雕塑。\n他是谁?为什么每天都要来这块墓碑前?地下埋葬的，是他的什么?他何以每日都前去探望?那个女人，又是谁？\n刷碟子的心思被冲进了下水道。\n他的背影，在这样的一个墓碑前，一定能说明什么。\n单看站姿，与石碑比，左肩高出一厘，脖颈稍往前倾，理应是常年伏案写字落下的暗疾。想必他一定是个学者。古老的思想家，总喜欢在同一个地方发呆（岂能是真的发呆）。\n希腊神话，荷马史诗，圣经，甚至是中国的诗也懂会一些。\n“见过那身披芰荷衣着芙蓉的草人儿吗?”\n他不笑，点头。\n我：“魏晋风骨怎么样?”\n“最迷人的姿态。”他会清晰且流利的汉语。\n“像是一个人?”\n“不像一个人。”\n“曹孟德曾这么说过。”\n“从这里爬出来说的?”他指了指墓碑，笑了。我不知哪里幽默。\n“陶渊明也是掀开帘子的时候，才发现天已经黑了。”\n“因而，视天下英雄不见?”\n“虽不见，天下英雄皆知。”\n“恕我直言……”\n我等着，却没有后话。\n“这样的蔑视。”我说。\n“认真地犯错，像极了妙曼的粪便。”\n“粗俗，换一个词?”\n“妙曼的屎。”\n“好极了！”\n“不被理解的，需要被理解；被理解的，需要被赞美；被赞美的，飘飘然。”\n我不免脱口问出已好奇多时的问题：“这墓?”\n“我早就知道丛林中蛰伏着许多毒兽，因此我变成飞鸟，从蓝色的天空飞过，一点也不在意造物者的失误。”\n我望向墓碑，他在念墓志铭。我等他说下去，却是长久的沉默。\n不得不说点什么，空气看上去什么都没有，但还是有的。我又道，“那日，有个女人来过。”\n“哦。”\n一定是与他有着难言经历的奇女子。——越是难言，越是好奇。\n“她是您的妻子?或曾经的妻子?”虽然我知道一定不是。\n“她也许只与这个墓有关吧。”\n“让我猜猜看?”\n“如若您认识她的话。”\n我耸耸肩，“只从墓志铭看，下面这人至少五十岁。”\n“1927 到 1989，墓碑上写了的。”\n我也并不在意，“从您的形貌看，您也至少五十岁。那女人，大概三十岁左右。”\n“如何?”\n“不是情敌，便是兄弟。”\n“如果这样，那很荣幸。”\n我诧异地看了他一眼，“我记得，那女人来时，带的是白菊花。”\n“死亡也这么潇洒?”\n“是呀，一说潇洒，我便想到菊花。”\n“镜子里全是镜子，光都不见了。”\n“色不是空，空不是色。”我默认了，“这个墓志铭是您写的？”\n“十八世纪写的。”\n“那您是怎么出来的呢？还是说眼前的您，是个幽灵？”我一点也不怯，是他怕了。\n他身体一晃，化作碎片，消散在空中。\n在这样的墓园，这样稚嫩的青草中，两个相差两百岁的人，说了一堆乱七八糟的话。我自嘲地笑，我真应该去米高梅电影公司写剧本。\n洗碗池的水溢出来了。\n我又朝窗外望了望，那人还在。——这周的休假，我要去会会他。\n已经决定了！\n我已想好见了面如何开口，而后谈及文学抑或历史，滔滔不绝。不在乎年龄，只觉相见恨晚。希望他不是老年后的我。当然，如果是老而健壮的博尔赫斯，就不胜荣幸。\n我早就盼望有这样的谈话了。\n礼拜六，阳光正好。\n墓园矮墙结垢着白垩，两三个人提着东西行走，钉板一样的墓碑立在道路两侧的空地上。我向里走，寻找着那个人。\n在面对那家餐厅的地方，我看到了他。像从前每一次见他时一样，他仍站立在一面墓碑前——也许是站着——一个长凳挡住了视线。\n我走到跟前，终于看清了这个人的面貌，深陷的眼窝微眯着，穿着一件似乎永不换洗的长衣，倚在长凳的靠背上。满脸杂乱的胡茬让我想起老家的猫。同时我也看到了在餐厅的后厨看不到的死角里，有一个手推式的垃圾车。\n而他的右手，支着一根扫帚。\n察觉到我的靠近，他看了看我，疑问的目光，在等着我说什么。\n我终于清醒过来，掏出一支香烟：“Lighter please?”\n","categories":["不言不载唯此玩心 · 文学","小说"],"tags":["小说"]},{"title":"管","url":"/2020/04/25/note/Literature/%E5%B0%8F%E8%AF%B4/%E7%AE%A1/","content":"下午五点二十分，秋雨总这个时候来。\n天灰蒙蒙的，抬头看不见雨滴，只觉往下砸。\n我也总这个时候来。\n从单位出来，买饭，步行到这，刚好二十分钟。\n我从来没有看天气预报或未雨绸缪的习惯。每天雨与我一同到来，我也从未撑过伞。在路上淋了些，推开病房的门，一股冷湿气冲到屋里。\n\n\n若是从前，母亲见我这般模样，绝对免不了一阵责怪与怨忧。但是现在，躺在床上，全身插着各种管子的母亲，说话都是奢望。\n已经管不了那么多了。\n像民不聊生的乱世，大事临头。\n因而来时放着雨伞不拿——已经管不了那么多了。\n总觉得刚才还好好的，那么能干的母亲，怎么就突然倒下了呢?刚才是什么时候?记不清，但一定不远。\n突然就这样了。\n早些年看电视，有人家里老人生病了，不能自理。兄弟几个赖着不管，你推我推。等到老人终于离世了，都松了口气，任务完成了似的。转眼，又要忙活——老人留了些东西，老房子，老三轮车。这回没人躲了，反而饿狼般的，争抢。\n我叹息，怎么会有这等人。\n妻子则不屑，“事情没到你头上，你当然站着说话不腰疼。就怕到时候，你比他们都抢得厉害！”\n事情果真到了我的头上……母亲被查出了胃癌。晚期。\n自入院一来，往日里能独自撑起一个家的健壮的母亲，一下倾塌了。躺在床上，像个婴儿一样蜷缩着，无法进食，无法控制排便，生活的一切都需要人照顾。\n妻子的话只是玩笑。父亲死的早，我家也就我一个独生子。赡养母亲只能靠我自己。跟领导请假，领导只愿意批我三天。妻子有空闲时间，所以白天有劳妻子照顾，晚上换我来。\n刺鼻的药味，暖气味，尿腥味在病房里绞成一团。我在令人作呕的气味中迅速吃了晚饭，便让妻子回家休息。\n病房的门忽然被推开，一个戴眼镜的医生拿着一摞纸，叫了我的名字。\n我意外，应了一声。\n医生把我叫了出去。\n“患者的情况还不太明朗，但下个星期我给她安排了一个手术，如果手术成功，好转的可能性还是很大的。”\n“手术费多少钱?”我几乎是脱口而出。\n“四五万吧。”医生连看都没看我一眼，低头整理案上的文件。\n我又问：“手术成功的话，我母亲还能活多久?”\n——母亲住院的这几个星期，亲眼目睹，母亲的变化，邻床的哭嚎，我已深知癌症的可怕。\n他终于把目光移到了我的脸上。\n我立刻谴责自己说错了话。\n做这样的医生，想必早已见遍了各式各样患者，家属。他眼中，淡然，鄙视，怜悯。他一定是以为我是那种人——时刻算着老太太什么时候死掉，好省钱，省掉辛苦肮脏的操劳。他一定以为我这么着急地询问，是在盘算性价比。\n这个性，是性命。\n怎么会?\n我想解释，但不知如何开口。\n大概这样窘迫的样子，更让他确定了自己的判断?\n我坚定了语气，抢过他的回答道：“带我去办手续吧！”\n回到病房，妻子还没走。\n我简述了情况。\n妻子脸色凝重，“咱们还有存款吗?”\n我摇摇头。\n“那还能找谁借呢?”\n我摇摇头。\n“那就把那破房子卖了吧！”\n我终于意识到妻子的语气不太对。我以为妻子愿意与我同舟共济，即使卖掉房子，露宿街头也不在乎。可她的语气，明明是反话。\n但我又怎么能怪别人呢?\n这一切不都是因为自己的无能?\n结婚时我岂没有发誓，要给她一个温暖的家，要做一个好丈夫?\n年轻时游手好闲，一事无成，现在能在县里林业局当个小科员，已经算谢天谢地了。工作是轻松，但一个月两千多的固定工资连她自己都不够花，何况是我们?是的，她只知道花钱，从没想过自己能不能出去挣点儿。\n母亲生病的第一周，我们拿出了全部的积蓄，却只够一半的手术费。瞒着母亲东借西借，才勉强凑够。之后每天都要出钱，却没有收入。我们哪来钱给母亲治病呢?\n她倒提醒我了，老房子可以卖了，先租房子住，说不定能租个离单位很近的，更方便些。\n这当然是下策。\n但束手无策的时候，下策也即上策。\n我不想说话，去楼道抽烟。她却不依不饶，跟了过来。\n“你说啊?去哪儿弄钱?”\n我沉默。抽烟。她竟哭起来了。\n“当初嫁过来的时候，我家里人都不同意，嫌你混，嫌你家落魄。但我就是被你的花言巧语给骗了，说什么有上升空间，过几年就能发达，一定让我过上好日子……”\n她竟诉起苦来！\n当时?当时是什么时候?\n我也想过上好日子，但哪是说过就过的?钱哪是说挣就挣的?这几年我虽没有飞黄腾达，但也是兢兢业业，埋头苦干了几年。钱在她手里根本存不住，我还能做什么?\n母亲第一次做手术用的钱，其实是我们说好去度假旅游用的。毕竟也该有个孩子了。\n但如今快要食不果腹，还是省省的好。\n“嫁到你家这几年，你有什么长进！不仅没让我们过得好，还天天让我在这给老太婆端屎端尿……”\n她说得愈加起劲。\n我听得越加愠怒，尤其是她说我没长进。男人最怕的就是内人折自己的面子。\n“你不想过就不过，我又没逼着你！”\n不欢而散是必然，但我们年岁都不小，不像年轻人意气用事。钱不是说挣就挣，分也不是说分就分。名声上，谁也受不住。何况在这个节骨眼儿上。\n没有钱。仅有这点可怜的尊严。\n只是至此，我们一旦开口交流，几乎立刻就吵起来。在家吵，在路上吵，甚至在病房里也忍不住要拌起嘴来。\n无非是钱嘛。\n就是钱呀！\n还有两天就要手术，医生已经给我宽限，否则我缴上钱也无用。但我缴不上钱，手术一定做不了。难道真到了要倾家荡产的地步?\n我从不曾像现在一样急得焦头烂额，白天上班，晚上照顾母亲，又要四处赖着脸借钱，时而还要跟妻子拌嘴。\n我已然精疲力尽。\n窗外是迷离的小城夜景，秋月银色的光华涌着灰尘落进来，细看，与小时候一模一样。那时我尤喜欢在夏夜躺在院子里的凉席上，母亲摇着蒲扇赶蚊子，我缠着母亲讲故事。那是古老的，深沉的，又是骗小孩儿的野故事，没有出处，不知如何流传，甚至故事中的意象也懵懂，支离破碎，但那曾是我童年最着迷的梦。\n以至后来的我迷迷糊糊过了二十多年，记忆变得朦胧而遥远，我也始终没忘记这夏夜的故事。\n现在呢，真去想，倒想不起来了。\n似乎忘了……\n果真忘了。\n忘。\n我迷糊着睡去了。\n翌日醒来时，天还未亮。是值班护士把我叫起来的。从病房涌进来几个护士和那个医生。医生让我出去。\n没有等多久医生就出来了。\n“你母亲昨夜凌晨一点左右去世了，请节哀……”\n是因为冷漠，还是因为见惯了死亡，他脸上一点悲伤或惋惜都没有，像个面无表情的石像。\n我也一样，只是不知所措，还没从睡梦中醒来似的，癔症着回味?\n我拉住医生，声音很轻，“为什么?不是很有希望好转吗?”\n医生看了我一眼，怕刺激到我，轻轻地拿开了我的手，“请节哀。”然后逃一般溜走。我这才看见，他终于动容。\n第二天，戴眼镜的医生才告诉我他的猜测是对的，已用监控确认了的。\n……\n是夜，我因为难过，一个人出去散步。公园湖边，寂寥无人，渐黄的树叶在风中无知地摇摆。\n我明白那个医生为何那样看我，却不明白在凌晨一点的夜，母亲是如何用业已枯萎的手拔下自己身上的管子，而不发出声音的。\n或许是我睡得太沉了?\n我终于失声恸哭起来。\n","categories":["不言不载唯此玩心 · 文学","小说"],"tags":["小说"]},{"title":"蒜苔儿","url":"/2020/02/16/note/Literature/%E5%B0%8F%E8%AF%B4/%E8%92%9C%E8%8B%94%E5%84%BF/","content":"看到院里参差不齐的菜苗，二妮突然想吃蒜苔儿了。\n\n\n但二妮知道自己吃不了，因为二妮自己不会腌蒜苔儿。二妮只喜欢吃腌的蒜苔儿，而且最好是娘腌的蒜苔儿。淡青色，抓一把，切成节儿，往坛子里一放，添上醋和盐。等腌好了，醋就在蒜苔儿上蒙了一层陈旧的涅色，而蒜苔儿也把醋香染得辣辣的。一咬，生脆，满口的清酸。\n二妮擦了擦口水。吃蒜苔儿得等娘回来腌，但二妮不知道娘什么时候回来。\n数起来，快半个月了——是爹说的，二妮不知道什么半的月的，只是感觉已经很久没见到娘了。娘走时，是一个夜里，二妮正睡着，被爹娘的动静扰醒了。但二妮只是迷迷糊糊，似乎看到爹娘起床，穿上衣服，悄悄地出了门。二妮知道娘还怀着孕，扛着大肚子，会到哪去呢？二妮想不明白，反正第二天家里就只剩父亲和二妮自己了。\n二妮上小学，三年级。学校在村头，一处破楼，红砖围墙耷拉着，荒草爬满院子。二妮跟伙伴们放学路上玩耍，时常看到瓦房后墙上，白蓝相间的漆刷着：“坚决打击躲生偷生，躲过初一躲不过十五”。别的孩子也许不清楚，会以为是过年时的余兴，但二妮隐隐有些明白。\n那日，天蒙蒙亮，家里门突然咚咚咚的响起来。二妮她爹开了门，还没看清是谁，来人就冲了进来。一下来四个，嚷嚷着，查户口，点人头，要搜全屋。\n娘不在。他们问二妮她娘在哪，二妮她爹说：“走亲戚去了。”\n那些人叫嚣着冲进屋里，“走亲戚去了？那好说……”，一眼看中了堂屋里的电视。虽然是黑白的，但整个村里，这样的电视一只手也能数得过来。四人二话不说，抬起电视就走，撂到来时乘的三轮车上。二妮他爹去拦，但对方人多势大，还叫喊着：“这可是国家政策，你再这样，要罚钱哩。”\n三轮车扬长而去，留下一句话：\n“走亲戚回来，带着嫂子去领。”\n二妮他爹只得骂了几句，准备早饭去了。\n二妮和其他小孩儿玩弹珠，常听到大人们在当街闲聊。\n“正会儿这世道，越来越好了。搁以前，哪家生哩多，弟兄们多，哪家就兴，横得很。现在谁敢生得多，还罚钱哩。”\n“可不是嘛？生那么多干嘛，还养不起。”\n一个端着面条碗，碗里已经没有面条，汤都干在碗上的老妇人，压低声音说：“可别生啦，柱子家的事不知道吗，生了俩，肚里还有一个，人家计划生育的过去先罚钱，又搬走了一个洋车子。”\n“洋车子搬走了，钱没罚吧？”\n“咋没罚？罚好几百哩！”\n“……”\n二妮弹自己的玻璃珠，去撞击别人的，撞到地上的小洞里，就算赢。赢的可以拿走别人的玻璃珠。以前二妮是高手，常赢得男孩子们都不敢跟她玩，家里积攒了一罐子玻璃珠。但今天二妮怎么也赢不了，不是力道太大，就是方向太偏。二妮心烦意乱，早早回家了。\n明天开学，二妮到了学校，没有计划生育的标语，眼是清静了，周围尽是同学，老师，教室里有书本，书上有《春天来了》，窗外有树梢，鸟鸣。但二妮想他娘啊，上堂也学不进去，下课也玩不进去。又不知娘现在是好是歹，二妮受不了了。\n一天，上早自习的路上，二妮趁人不注意，悄悄拐弯儿了。\n二妮要去找她娘。\n——但又不知道去哪找。\n抹黑走着，二妮走到了村东外的田地里。\n天快亮了，太阳还没影儿，湛蓝的天空宝石般透亮，罩下来，明晃晃地映着天杪的云彩，三月里油菜花正欲绽放，绿田葱郁，波涛翻滚。远处，天际落在小房子上，绿杨，白云，向更远处去了。二妮看到这儿，就想起了院里的菜圃；想起菜圃，就想起了蒜苔儿；想起蒜苔儿，就想起了不知所踪的娘亲。\n终于，太阳露出微光，金黄色从天边袭来，天地间猛然添了一丝温暖。但二妮悲凄的心情愈加沉重。二妮想，在学校老师教的语文，有小蝌蚪找妈妈的故事，自己岂不就是那个小蝌蚪？二妮想着，田间无垠的小路似乎变成了一条深壑，周围绿色的田地变成汪洋大海，鱼虾水草在空中飘荡，二妮用力摆动着小尾巴，向太阳升起的方向游着。开始二妮在水里不太适应，暗流激湍，二妮奋力抵抗着无形的力，却难以把持住身形，耳畔像炸了炮仗一样闷，天旋地转。二妮不知如何是好，却也丝毫不急。心中对娘亲的思念倒淡了些。偶有大人们去地里薅草，路过碰到二妮。二妮看到他们灵活地游向自家田地，心中惊奇。二妮发现，他们好像看不到自己。二妮大声喊，却发不出声。\n二妮在水中漂了许久，阳光刺透水面，光影交错，梦幻一样的水下世界让二妮已经忘了此行的目的。渐渐地，二妮游得利索些了。前方忽明忽暗，二妮在朦胧中，看到一个身影。二妮心下一动，会不会是娘亲？全力游向那个身影，二妮想看清那到底是谁。也许娘就在前面等着自己？二妮越想越心动，拨开水浪向前方穿行。\n近了，人影清晰起来。二妮有些失望，那并不是娘亲，而是一个头发花白的老太太，脸上褐斑遍布，枯粗的皮肤往下坠，穿着一件罩住全身的紫黑色的布衣。这老太太，二妮是认识的，是二妮邻居家，狗蛋的老太儿。平时都在家坐在一个竹椅上，二妮去她家玩的时候，常听她说些含糊不清的话。人老了，牙全没了，说话呜呜不清，耳朵也不灵光，但老人很慈祥，二妮也很喜欢她。\n“嘻嘻，老太儿，你怎么在这儿啊？”二妮游上前问道。\n水纹纵横，人影都在晃。老太太看到小丫头，也咧嘴笑了，呜呜道：“我瞅块儿地……”\n二妮听不太清，也听不太懂，游过去给老太儿轻轻揉了揉肩，像平时一样。老太儿问二妮：“你呢，你这闺女怎么跑漫地里来了，不去念书呀？”\n二妮道：“我不想念书，我想找我娘，我娘也不知道去哪了，我爹也不跟我说。”\n老太儿似乎叹了口气，又不真切，历经了近百年的岁月，面孔遍布风霜，什么都看不出来。\n二妮突然感觉一阵骚动，水开始不安起来，接着，巨大的漩涡声势浩大地逼近，远近的游鱼都被卷进去，飞速旋转着。黑暗处散发的神秘气息让二妮有点儿害怕，转眼看老太儿，老太儿好像还没意识到危险已经来临。莫名的力撕扯着，二妮感到身体不受控制，漩涡吸扯着二妮。老太儿却似乎根本不受影响。二妮终于无法支撑，一片混乱中，二妮抓住了老太儿的布衣。狂风般的漩涡席卷而过，二妮闭上眼睛，死死抓住老太儿的粗布衣袖。\n不知过了多久，天地间的昏暗褪了下去，二妮感到实实在在的大地，就在自己的身体下面。睁眼，强烈的光线刺得眼镜生疼。适应了好一会儿，才终于可以看清周遭。日头正当，二妮躺在浮尘飞扬的土路上，杨树新叶筛下的阳光像水波一样粼闪，清风拂面而去，尘粒砸得脸颊膈应。二妮看了看手上，发现自己捏着一块紫黑色的残布。\n回到家中，二妮他爹看到满身泥垢的二妮，劈头盖脸一阵喝骂。\n“这一上午，你跑哪去了？”\n面对爹的问话，二妮只得如实道来，“我去找我娘了。”\n“你去哪找你娘？”二妮他爹语气稍软。\n“我也不知道，也没找着。你又不跟我说我娘去哪了。”二妮不惧，憋着怨气道。\n“那你去哪胡跑了，丢了一上午，弄得浑身泥巴，有没有伤着哪？”\n“没有，我碰见狗蛋他老太儿了。”\n二妮他爹看了二妮一眼，“胡说啥呢，昨天夜里狗蛋他老太儿已经走了，明儿个准备吃桌。”\n“走了？”\n“就是去世了。”\n二妮知道去世了是什么意思，就是把人放到木箱子里，埋起来，以后就再也见不到了。\n“我上午还正跟她说话哩……”\n“傻闺女，你知道啥……走吧，吃饭去，刚腌好的蒜苔儿，你最好吃这个哩。赶紧去洗洗脸，脏得跟猪屁股一样。”\n二妮应了一声，摸摸裤兜，掏出那一块紫黑色残布，发了一会儿呆。吃饭时，二妮匆匆填食，二妮他爹腌的蒜苔儿，二妮一筷子都没有动。\n","categories":["不言不载唯此玩心 · 文学","小说"],"tags":["小说"]},{"title":"逃离计划","url":"/2022/01/29/note/Literature/%E5%B0%8F%E8%AF%B4/%E9%80%83%E7%A6%BB%E8%AE%A1%E5%88%92/","content":"逃离“我”似乎是一个近乎玄妙又完全愚蠢的想法，童年时期我孜孜于此，可即使天地辽阔，四海无涯，我又能逃到哪里？因而当刘淇捧着地图册，兴致勃勃地要带我逃跑时，我变得不知所措。“我们就逃到关外去！听说那里有好多移民，我们去那，谁也不知道我们从哪来！”刘淇满怀希冀看着我说。这是他第一次用这样的目光看我，脸上常有的笑也不见了，取而代之的是一种异常坚毅的，像是壮士英勇赴死前的神色。我有点害怕，不是因为青涩稚嫩的刘淇变得伟岸，而是出于生物本能，像是步入黑暗森林前的踟蹰。眼前的这个少年的确能带给我快乐，让我忘掉在家的烦恼，可两人如果真的闯到异乡，无亲无故，如何生存？若到头来一切成空，值吗？我在此地乐不思蜀已一月有余，对家谎称打工，体验生活，实则与刘淇体验自由的天堂。既然是天堂，何不赌掉自己，跟他走？真走了，还能回来？昨晚例行电话，母亲已下最后通牒，“钱无需你挣，女子在外面我和你爸都不放心，也出去这么久，该回家了，好好把学上完才是正事。”挂掉电话，我抑制自己的心跳，觉得自己真正在掌控自己的人生，“去哪都行，我跟着你。”\n回到熟悉又陌生的家时，门框上去年所贴现已泛黄的对联在风中摇曳，像禁城的封条，我又要开始我的苦役了。从何时起，养育我的温床变成这样一座令人窒息的牢笼？一直迷茫于人生与情爱，多年校园生活，浑浑然只知书本上几页悬在空中的知识，空空幻幻还不如红楼一梦来得真实，只道是小说中的痴男怨女何时能让自己碰到，到那时还不得撕心裂肺，惊天动地？生死算什么，为了爱，一切都是泡影。我已经忘了一个多月前与刘淇因钱的事儿而困苦的情境了。\n高中毕业，成绩不理想，草草选了大学，就急忙往外跑，新世界总是散发着诱人的魔力，正是那个时期我的撒谎本领以惊人的速度增长。独自来到睢宁县城，家人真的以为我有同学在此照应，我以比许多男孩子更勇敢的姿态在此立脚（其实只是找个旅店住下），去寻找人生的第一份工作，而工作没找到，找到了刘淇。\n被拒绝一次，我就失去了信心，转而在街上寻找可供娱乐的场所，初临陌生之地需要烟火气消除惊吓，好在有一家书店，单间门面房，招牌红底白字，“慧源书店”，不用看我就知道这里面必定列满了小到幼稚园，大到高中的各科资料，至于别的估计也没地方可放，这些都还可以原谅，何必取那果汁的牌子呢。聊胜于无，我还是进去碰碰运气，《少年阿衰》，《一帘幽梦》，《多情剑客无情剑》……还好，好坏参半，新旧皆有，里面呢，《卡拉马佐夫兄弟》，《千只鹤》……咦？竟然有《鲁滨逊漂流记》！初中时统一买的必读经典名著里最喜欢这本，常常想象自己与主人公一样流落孤岛，孑然过完一生，若有个白衣少年陪我，更是美哉。忆起那时两三事，没看到按在书上的那只手，瘦长，像极了骷髅。\n后来我又见到那样的手，一双双，多得数不过来，但都没有当时那只手给我的特殊感觉。我使劲回想当时情形，依然模糊，但我无比确信他是因为看到我长得漂亮才站起来观察我拿什么书的。他挡住了外面的光，白衬衫因而不那么白，他看到我呆滞的目光，急忙说：“这本书只有上册，下册还没到货，改天你再来，这……是我的电话。”他递给我一张纸条，脸更黑了，我猜他是脸红，十几万字小说哪个出版社分上下册印？我接过纸条，按流程买了这本漂流记，无话，他不敢看我。\n一个星期后的午后，我领他去我的住处。他说他叫刘淇，他也不知道他父母为什么要给他取像女孩子一样的名字，我笑了，跟他说我叫许亚楠，也不如男，我俩正好。他脸又红了，跟着我小心地走进招待所，全国各地都有这样的招待所，最折人志气，狭小脏乱的空间，不仔细看就会错过的招牌，让人确信家之必不可缺，反衬此时的落魄，但我全然不在乎，甚至根本意识不到这些。他则比我还新奇地问东问西。\n“你家真的在上海？”\n“上海是不是很繁华？”\n我懒得回答，白了他一眼。\n“那你为什么一个人来这？”\n“我是逃出来的。”我决定逗逗他，随手扯了个谎。我把家描摹成一个阴森恐怖的城堡，仆人成群，衣食无忧，但我日渐消瘦，因为家母刻薄，父亲残暴，每天我都要承受肉体与心灵的两重折磨，我期盼着白马王子降临，解救我于火海，然而不仅没有等来王子，反而等来了家人的逼婚，如此种种。看着他着急样子，我心中得意，他未必比我小，但男人都喜欢当英雄，尤其是面对颇有姿色的美女时。他一定在想，如果他早知道该多好，他可以一骑绝尘挽救一个身处火海的可怜少女。而我也渐渐沉缅于自己的故事，天使与恶魔竞相出生，故事宏大得没边，我们畅游在虚无的异世界中，心情激昂，我望着他的眼睛，世界开始变轻，一切消失不见，我浮在空中，像一片羽毛。这是一种我们两人都无法预料的顺理成章，我不知道为什么要闭眼，他也不知道为什么要吻上来。\n刘淇抱住我时，我开始慌了，睁眼看到他的两个大眼珠，赶紧又闭上，我告诉自己，这只是生物本能，想挣脱囚笼就必须克制本能，但下一刻我就无法控制自己，大声叫了出来。我不知道衣服什么时候没了，这毕竟与书中所写有些不同，我完全不知道该干什么，算了，由他去了。他也只知耸动，在我耳边说多么爱我，这一个星期，每次见面，各样细节如数家珍，让人惊叹他的记忆，一片片词语从他嘴中，到我的耳垂，耳蜗，然后从另一侧流出，那是我的大脑不再处理任何事务，直到他射了，所有动作一瞬间全部停下。世界安静得像无人之地，我擦干眼泪，意识到身边还躺着刘淇。他四肢摊开躺着，像一具尸体。我不知道为什么那里不痛，宫廷言情小说中的情节出现在我脑海中，还是想不通，他也没问，只顾喘气。\n轮流洗完澡，他看到床头柜上的那本《鲁滨逊漂流记》，窘样顿显，但仍强装镇定，我吃吃地笑了，第一次主动挽住他的胳膊，细声细语，“你会陪我一辈子吧？我们是彼此最后的人？”我能感受到自己发热的脸。他摸摸我的头，坚定地点头。窗外汽车驶过，窗帘紧闭，他打开电视，调低空调的温度，炎热的夏天也得盖厚厚的被子，紧贴着，是实实在在的安全感。此时是下午四点。\n凌晨两点半，我们起床。街上一个人都没有，找到这家似乎是全城唯一开着的烩面馆，我们相对而坐，看着刘淇给我吹着烫嘴的面条，我又想到了那一点，刘淇与高中同班的那个张子斌真的很像，第一次见面时我就发现了，这点在他兴致较高时尤其显著。一个月后，他的宏大计划在我面前展开时，这样的感觉甚为强烈。丽江，三亚，西藏，北京，大理……我只好挖苦道，“你这不是逃跑，你是度假呢。”他涨红了脸，“你要相信我，我会想办法挣钱，你这些天的‘工资’我也能给你弄来，待时机成熟，我去上海找你，然后一起逃走！就算是度假！”我相信自己已经是天底下最幸福的人了。\n刘淇照例去慧源书店上班，我在床上吃着零食看他带回来的书，听到敲门，出去就看到了父亲与母亲并肩站在门口。不知道他们怎么找到我的，但我用自己都想象不到的速度想好了说辞，告诉他们我已经在一家书店工作一个月，并且拿到了三千块的工资，昨晚电话也说好了，过两天处理完这边的事就会回家，没想到他们会来。一家人释然，然后乘列车回家。家里完全没变，我却翻天覆地，然而回到这里，我又变回与原来一模一样的我。何止是看对联像封条，我看什么都不顺眼，就连平日最可爱的“午觉”（一只橘猫）我都无心戏耍。我心里又担心又期待，担心母亲到头来还是发现我的秘密，期待的是我们的计划还没破灭，我已偷偷告诉刘淇这里的情况，只需在家等候他的到来。尤其让我想不到的是，刘淇竟然真的弄来了四千块钱放到我卡里，我得以让母亲相信我是真的工作了一个月，而不是花着他们给的钱玩乐。此时万事俱备，只欠东风。\n开学日期越来越近，刘淇何时能来，我知急也没用，但短信他也不回，难道要抛弃我了？那他的誓言？一日阳光明媚，清风拂面，我出门购物，电话响了，是他，是刘淇！我接通，按耐不住心中的激动，手在颤抖，轻轻喂了一声，那边传来声音：“你是许亚楠？”是个低沉的男声，不是刘淇！那是谁？我不敢想了，如坠冰窖，浑身冷汗，如今我记不得自己如何结结巴巴地回答他的问题，只是知道当时刘淇在旁边听着，一言不发。我们的逃离计划还没开始就宣告结束，那一刻是我逃跑欲望最强烈的时刻。\n双方家长在一处高档餐厅会面，当面对质，一切水落石出。我体验生活是假，刘淇暑假打工是真，我带着母亲给的生活费来到睢宁县城，吃穿用度根本不够，花的都是刘淇的工资，而我欺骗父母假装打工，工资无处可寻，刘淇把即将开学要用的学费私自扣下四千，让我得以圆谎，准备开学不去上学，而是带我“逃跑”，但零九年新政策生源地贷款开通，刘淇父母决定贷款给孩子上学，原先学费留下应急，事发突然，刘淇眼见瞒不住，只能招了钱的去向。打孩子一顿让其长长记性事小，这四千块钱如何追回事大，于是便找上门来。\n我呆滞着坐在沙发上，也知道自己创了祸，不知该如何面对这一切，刘淇怎么不来，他要是能把我救走就好了，我何尝不知他是自身难保。说来奇怪，此事一了，他完全没了踪迹，他的电话已是空号，但我的电话他一定还记得，为什么不打过来。身后一股浓馥的幽香，是楼下桂园传来的，盖过了窗台上的茉莉，那时还不知道茉莉是不香的，直到年近四十的我重新伺养茉莉时才知道茉莉花原来还是香的，只是刚开花时香气逼人，很快飘散了。但眼前这株已有败坏的迹象，如何争得过一园子桂花？我趴在窗口望下去，楼下车水马龙，行人各有其要事在身，没有人的“要事”只是行走而已，行走只是手段。我发觉这像是一场梦，我情愿把一切都奉献给刘淇，扔掉所有跟他走，不管去哪都愿意，但直到现在我还不知道他在哪里上的学，要去哪上学，他的父母如何，家在何处？荒谬感扑面而来，不可断绝的不只是悲伤。\n不知觉父亲已经在我身后。\n“你想不想上学？”\n“不想！”我是在赌气，但我根本不知道在赌谁的气。\n“那好，学不上了，你三叔介绍了一个孩子，人很好，你去见见。”\n于是我第一次开始了属于自己的逃离计划，这次我逃向的地方是学校，那是我们曾经费尽心机要逃离的地方。我低估了父母的决心，不知他们为什么这么着急把我嫁出去，甚至不惜让我放弃学业。我去见了饶莉莉，她是我从小的朋友，我回来之后就再也没找过我，她同情地看着我，“你真该直接去上大学，本科时间自由，想干什么都可以。”别的再也说不出什么了，就连她也不能陪我吃辣条，一起淋大雨了。但这坚定了我继续读书的决心，三天三夜恍恍惚惚过去，心想，如果爸妈非要我结婚，我就去死。从小泡在道理与规矩中长大，总会对狂放不羁的任性怦然心动，这也是为什么我对自由有着歇斯底里的渴望，父母的妥协让我尝到了甜头。\n大学四年是快乐的，快乐之所以是快乐，也许因为它会过得快吧，从刚入学的怯懦，到最后驾轻就熟，两袖清风，还没反应过来，本科毕业了。我总是这样，事过之后，我才意识到事情的发生。何况张子斌转学再次成为我的同学这事，至今我还没反应过来。\n操场十点半关门，天黑之后关门之前总聚集着一群学生，捧着自以为是的吉他与音响，幻想着自己是游吟诗人舞台歌星，倒不是说对音乐的爱不真诚，也不想想那么多跑步者何以个个都带着耳机。我来散步，吃完晚饭室友卧床看剧，觉得无趣就出来透风。湿咸的夏日，夜风游过探照灯下的操场，人影绰绰，让人直想睡在这不冷不热的夏夜里。讨厌极了弹吉他的男生，不仅是因为他们破坏了意境，还有他们的盲目自信，我鄙夷地看向那群男女，面向了探照灯的光——“许亚楠！？”\n我也惊奇，“张子斌？”\n“你也在这学校？你什么专业？那我们离得很近啊……”三年没见，他比我印象中的会说了，话多得让我不耐烦，他完全没料到我会跟他一个学校，我也没想到他家有能力让他在半途转校。他回身放回吉他，跑过来，带来一阵烟味，出了操场，安静了许多，他却没有停下——上课时在纸上玩的五子棋，藏在书桌里的明信片，湖南卫视的《超级女声》……“尚雯婕！你最喜欢的呀！当时你就看出来她会得冠军！”\n我不知道该怎么跟他解释我早就不喜欢这些了，更不用说当时我还曾暗恋他，那是一段刻骨铭心的时光，但新的事物填充进我的脑海，旧的就慢慢风蚀，除了一点点怀念，对整个儿青春的怀念，我就再也没有别的波澜了，所以当他说到他曾经喜欢过我的时候，我猛然惊醒。他玩笑开大了，我尴尬地笑了笑，“你当时怎么不说？”\n“当时……觉得配不上你，你那么文静漂亮……”\n“那你带我走！”\n他奇怪地愣住，想不到我会突然这么说，“走？去哪？”\n我笑了笑，“没事，我说着玩儿的。”\n可笑，尽管不愿意承认，当时动心的，只是刚好他抬头，笑脸像一道光。别的，全是空白，如果非要填补，那就是普通，比眼前的人还要普通的普通。全凭自己美化的人儿早已融化在记忆中，那时觉得可惜不是他，现在见到只能庆幸还好不是他。高考结束的那一天，学生们撕掉书本，宣告苦难终结，迎接新生，我则烧掉笔记本，那是多年来悲喜纠结的少女心事，满纸可爱又可笑的心里话，心里话，写出来的还叫心里话？果真，烧掉之后我心中再也没有出现过他的影子，直到今天重逢。新的笔记本扉页只有一句，“爱自己，是目的也是宿命。”因而交换电话，相互告别。他很犹豫。跟我有什么关系。\n我曾在刘淇身上寻找他的影子，什么也没找到，那时我已意识到自身亦是这样迷一般的梦幻之花，那些人妄图在我身上寻找些什么，什么也没找到。不甘于对自己的探索止于悖论式的不满足，何况还有温热甜美的早餐，吹面不寒杨柳风的乐章，亮丽动人的长诗，久违的厚实拥抱……这些，这些是实实在在的满足呀。\n刘淇至今还不知道他是因为和另一个人很像才拥有过我一段时间，我自己，则是无所谓被谁拥有的。没有谁能拥有谁。接了张子斌的电话，便乘车赴约，公园里龙葵簇拥着水杉，毫不起眼，叶子很柔。第一次抽烟，无法理解男人们能有如此殊癖，由此聊着，人生，梦想，我竟会像男生一样跟他谈天说地，吹牛打诨。此夜之后，我才是我。人身上总有许多特质，吸引人的同时又让人恶心，张子斌竟然得过市书法比赛第二名，还曾在室友怂恿下听着随身听中的声音自慰。面纱即下，一览无遗，我喜欢真实，但真实是爱情无法承受的。\n毕业典礼是同学感情最深的时候，在空旷的校园到处跑，黄昏比平时更美一点，心比平时更空一点，晚上聚餐，就不去了，家里打来电话，爷爷脑出血，在医院。托人代领证书，提前回家，人没挺住。刚毕业的迷茫，亲人亡故的迷茫，宏大人生的迷茫，我又想逃了，心里暗骂自己是懦夫。但世上的懦夫岂止我一人。\n凭着家里几代以来的社会关系，轻松在市里人事局谋得一职，每日淹没在琐事之中，上班，应酬，聚会，我一直在寻找这无形牢笼的突破口，但一直在其中原地打转。谁不羡慕一个拥有“铁饭碗”，拥有完美家庭，拥有健康身体的青年人呢？但心中总有一个无法填补的空缺，总有一个无法到达的地方。也渐渐明白，人生永远都在寻求的路上，寻求什么，走到哪里，都远非自己所能控制。自我意识其实正是人生不自主的严谨证明。我即将面临最难以自主的事，婚嫁。回家日日被催，出去见朋友也总能说到这个话题，似乎不结婚是一件极其可耻的事情，我不得不按捺心中的真实想法——我不想结婚，也不想要孩子。\n早年与母亲谈及此事，得到一堆过来人的亲身经验与口口相传的典型例子，养儿防老，无儿无女晚年凄凉，没有孩子的人生是不完整的人生，不生孩子就没人愿意娶你，嫁不出去如何是好……我岂能不知过来人的经验之宝贵，但难以认同“不生孩子就是自私”的观点，功利性地生孩子才是自私。争辩，无用，争辩永远都是无用的。下班回家，母亲照例催促周末去相亲，“奔三的人了，再不结婚我和你爸还怎么见人？那家孩子人好，学历也高，在上海有三套房，你得抓紧，这样的错过就不好找了。”亲戚自不必说。\n他们逼得越紧，我越是不愿屈从。心想，即使非要嫁人，也绝对不嫁他们指定的那些人，在他们看来，婚姻是一笔只能赚不能赔的生意。我只想自己做决定，单位里的男同事，不能说没有喜欢的，但大多已有家室。同学聚会，老朋友自有一股悠远的味道，但更多的是乌烟瘴气，张子斌倒还有联系，暧昧不清，而刘琦，是好久没见过了，我至今仍觉得与他在睢宁小城的时日是最快活的日子。困惑于当时的不了了之，总想见他一面。\n找到他费了一番功夫，但还不算太难。他大学还是没去上，子承父业，在小镇炒瓜子卖干果，看到我，没认出来，“这边四块三，那边五块，这袋是好的，六块二，里面还有花生。”\n好在是八月，淡季，不影响他的生意。\n去了全城唯一一家显得高档的餐馆。一阵唏嘘。\n“你怎么没上大学？”\n“学不进去，中途回来了。”\n“生意怎么样？”\n“还行。”\n“还行？”\n他笑笑，不说话，他话少了许多。我们一样大，那他也二十三岁了，不知道这些年他是怎样，胡髭蓄起来了，言谈稳重了，别的呢，我一定要问的。他倒老实，全盘托出，三年前在家游手好闲一段，家里给介绍了一个姑娘，还行，就结了婚，现在只有一个女儿，其父母劳累过度，落下一身病，他提前接手了铺子。\n“就这样？”\n“就这样。”\n是的，我这几年讲起来，话更少。我们都不是话多的人。\n那当年……为什么你不找我？问不出口，喝酒。\n他看出来了，叹息，“那时你真厉害，敢一个人闯到这里来，至今我还敬佩不已。我们的事被发现，本来是小事，我爹想把钱追回来，你家毕竟不缺那点钱，就爽快地答应了，但他们商量的时候我爹说漏了嘴，你爸妈知道我们同居过的事了。”他自嘲地笑了笑，“他们看不上我，不，是看不上我家，他们根本没有看我。你知道，按照传统，你得嫁人了，他们给了我们三十万，让我们保密，并且永远不再跟你有瓜葛。我……我对不起你。”\n原来是这样，多年的困惑解开了，问题本身不再重要时，问题的答案也随之不重要了。干杯。而他有很好的理由，那就太好了——他也是不得已呀。心中为他开脱，其实也是在为自己开脱。回家途中越来越释然。回忆是个假象，生活是个陷阱，日子枯燥而有趣，我在泥泞中翱翔。理想与现实就是这样——虽在泥泞中，我仍在翱翔，虽在翱翔，我仍在泥泞中。\n当母亲了解我执意要嫁的张子斌是何等条件与家境时，她终于忍不住发怒了。喊来父亲，我接受着两人苦口婆心的规劝。随后是三个姑姑，小姨，兄弟姐妹，还有行将就木的奶奶，轮番上阵为我纠正错误思想。最后眼看无法动摇我的念头，只能作罢，心中依然生我的气，但不再试图改变我了，生怕关系进一步闹僵。让周围的人为我煞费苦心，我心中难受，但如果让我跟一个不喜欢的人生活在一起，更是难受。那时的确是这么想的。\n父母按照当地礼节见了张子斌，然后双方父母商谈婚事的操办。人走茶凉，家里又剩我们三个，母亲把我叫到她那屋，眼中噙着泪。\n“你将来会后悔，但那时我也帮不了你了。”\n后悔。是的，人生充满令人后悔的事，尽管我嘴上从未承认过。中学时贪恋窗外的纷繁世界而误了大好时光，大学时浑浑噩噩安逸于暖阳清风未得一技之长，人格尚不成熟时做出的几件心中有愧之事，这些，这些都还可以接受，难以接受的是对自己的全盘否定，是母亲未卜先知似的准确预见。婚姻是一座坟墓吗，埋藏了多少颗冷淡的心。我的丈夫有近乎软弱的善良，有坚韧厚实的臂膀，有让人安心的责任感，但他没有出众的外表，没有浪漫激情的格调，没有许多我喜欢的其他品质，永远的死气沉沉。没多久我就感到腻烦。何况我是因为赌气才嫁给他的。而他很好，他的好反而让我只能选择忍受这一切。真是宿命呵。\n宿命不可抵挡，当我感叹造化宿命时，已经错失改变宿命的良机。每当我逃到一个地方，以为这里就是我要寻找的地方时，就会很快发现我必须要再次逃离了。我始终是一个失败者，失败于成为一个让旁人满意的“我”，也失败于成为一个让自己满意的“我”，甚至每次“逃离”都以失败告终。年近三十，儿子开始上学，我才终于意识到原以为的牢笼也许根本不存在，即不存在，就遑论逃出去。这么些年，我竟不知道我在试图逃离一个不存在的地方吗。我将仍是这样，工作，应酬，育儿，等等，等等。没有传奇，没有疯狂。\n年青时的疯狂最是奇怪，当时不觉得疯，后来又感觉幼稚，那么这疯狂，疯狂在哪里？实在没什么疯狂的，我只记得当时疯狂地逃，迷途不知返。\n床头小书柜只有一本书，《鲁滨逊漂流记》，我要开始一个足以用一生践行的逃离计划了，这次逃离的地方，不是我曾身处的任何一个地方，而是一个叫作“我”的躯壳。\n","categories":["不言不载唯此玩心 · 文学","小说"],"tags":["小说"]},{"title":"拾羽二〇二〇","url":"/2020/04/29/note/Literature/%E6%8B%BE%E7%BE%BD/%E6%8B%BE%E7%BE%BD2020/","content":"\n🍂秋风落叶，如织如羽，拾之而观，脉络万千。\n\n人非圣贤，安能无所不知。只知其一，惟恐不止其一，复求知其二者，上也；止知其一，因人言始知有其二者，次也；止知其一，人言有其二而莫之信者，又其次也； 止知其一，恶人言有其二者，斯下之下矣。（张潮）\n当我年轻的时候，也曾叩访过博士和圣贤，恭聆有关人生的伟大争辩，出来的门和进去的同是一扇。峨默·伽亚摩（木心）\n\n\n人从悲哀中落落大方走出来，就是艺术家。（木心）\n悲伤有多种，能加以抑制的悲伤，未必称得上悲伤。（木心）\n知与爱永远成正比。（叶芝）\n我最瞧不起少年时期的我 良善到可耻（木心）\n念天地之悠悠，独怆然而涕下。（陈子昂）\n多记印象，少发主见。（哈代）\n幸 不幸 都在于目睹共产主义的破产\n中国有两种特产 先验太监 自费汉奸\n田园诗之美 美在田园消失之后\n怕只怕两三百年后启蒙运动在中国如火如荼（疑似木心）\n有可耐之俗，有不可耐之俗，可耐而不能耐，迂矣，不可耐而耐之，殆矣。（木心）\n我病态——我把最大的求知欲、好奇心、审美力，都耗在“人”的身上，颠沛流离，莫知所终。（木心）\n我已经算是不期然而然自拔于恩怨之上了，明白在情爱的范畴中是决无韬略可施的，为王，为奴，都是虚空，都是捕风。明谋暗算来的幸福，都是污泥浊水，不入杯盏，日光之下皆覆辙，月光之下皆旧梦。\n当一个人历尽恩仇爱怨之后，重新守身如玉，反过来宁为玉全毋为瓦碎，而且通悟修辞学，即用适当的少量的字，去调理烟尘陡乱的大量人间事——古时候的男人是这样遣度自己的晚年的，他们虽说我躬不悦，遑恤我后，却又知优哉游哉聊以卒岁，总之他们是很善于写作的，一个字一个字地救出自己。救出之后，才平平死去。还有墓志铭，不用一个爱字不用一个恨字，照样阐明了毕生经历，他们真是十分善于写作的。（木心）\n当某个环境显得与你相似时，便不再对你有益。（木心）\n“当真，为什么我们遇见一个畸形怪状的身体是不激动的，而遇见一个思路不清的头脑就难于忍受，不能不愤慨起来了呢？”\n“因为，一个跛脚的人，承认我们走得正常，而一个跛脚的精神，却说我们是跛脚的。若非如此，我们就不致恼恨他们，反使可怜他们了。”\n蒙田和帕斯卡尔之所以能这样娓娓清谈，是缘于都未曾见过一个浑沌的头脑能把亿万头脑弄浑沌，也未尝身受过跛脚的精神纠集起来把健行者的腿骨打断。（木心）\n我们默然自保是幻想自己是最后一个受害者。（张鹏）\n都是风雨夜未归的人，或者此生也难以有归处，天正黑，路也长，恰好值此午夜时分，要好好活着，不为别的，就为守个天亮，天总归是要亮的。（未知）\n如果天空总是黑暗的，那就摸黑生存；如果发出声音是危险的，那就保持沉默；如果自觉无力发光的，那就蜷伏于墙角。但不要习惯了黑暗就为黑暗辩护；不要为自己的苟且而得意；不要嘲讽那些比自己更勇敢热情的人们。我们可以卑微如尘土，不可扭曲如蛆虫。（季业）\n一切价值都是偏爱价值。（木心）\n中国是一个大国，大国的爱国主义不应该是愤怒。一个强者有一万种方法打击他的敌人，而绝不是在被冒犯之后把自己气成癞蛤蟆。\n顺子绝非孝子，顺民不会爱国。\n“我个人没有困惑，我的困惑是如何与这些非自由主义的爱国者进行沟通，把我们的观点传达过去。”\n“批评不自由则赞美无意义。”\n“政治部落主义把所有是非问题转化为站队问题，其最大的特征是人们丧失了就事论事的能力。”(一次讨论)\n楼下一个男人病的要死，那间壁的一家唱着留声机；对面是弄孩子。楼上有两人狂笑；还有打牌声。河中的船上有女人哭着她死去的母亲。人类的悲欢并不相通，我只觉得他们吵闹。（鲁迅）\n脏兮兮的楼宇，芸芸众生的群体，永不中顿的噪音，挤得寸步难移的车列，铺天盖地的广告牌，野心与失望与焦躁与亢奋——其中有无数选择无数可能，但同时又是零。我们拥有这一切，而又一切都不拥有。这就是城市。蓦地，我想起那个中国女孩的话：“这里终究不是我应在的场所。”（村上春树 《去中国的小船》）\n飞翔在两万英尺的高空，候鸟要归乡，并不需要坚强，或任何悲伤。（张艾嘉 《戏雪》）\n人们似乎想把所有的东西都放在故事里，不然就没有意义。（斯嘉丽·托马斯）\n我胆小，不能自杀。但这种丑恶滑稽的念头，我总是拿它没办法，实在讨厌，所以我就用写小说的方法来代替自杀。（三岛由纪夫 《空白的作用》）\n你在害怕什么？人和树其实根本没有什么区别。树想要长得更高，高到能够触碰光明，就必须深深地扎根，把根扎进幽深的罪恶中去。（尼采《查拉图斯特拉如是说》）\n拖拖拉拉地熬夜不睡觉，根本没一点好处。天一黑就赶快钻进被窝，早上跟着太阳一起醒来，这样再好不过。（村上春树 《1Q84》）\n他们害怕老人的记忆，害怕年轻人的思想，他们害怕墓地的鲜花，害怕工人，害怕教堂，害怕所有的快乐时光；他们害怕电影，害怕画家，害怕音乐家，害怕石块和雕塑，他们害怕电台，害怕技术，害怕信息自由流动，害怕所有的波长，那么，我们为什么要怕他们。（未知）\n不幸的是，这些青年并不懂得，在很多情况下，舍身也许是所有的牺牲中最轻而易举的，而从自己风华正茂的生命中拿出五六年来埋头苦学，做点学问，哪怕只是为了十倍地增强自己的力量，以便为他追求的真理服务，为他心向往之并且引为己任的大事业服务，——这样的牺牲对于他们中许多人来说几乎完全做不到，实际情况往往如此。（卡拉马佐夫兄弟）\n真正的光明绝不是永没有黑暗的时间，只是永不被黑暗所遮掩罢了。真正的英雄绝不是永没有卑下的情操，只是永不被卑下的情操所屈服罢了。所以在你要战胜外来的敌人之前，先得战胜你内在的敌人；你不必害怕沉沦堕落，只消你能不断地自拔与更新。\n《约翰·克利斯朵夫》不是一部小说，应当说：不止是一部小说，而是人类一部伟大的史诗。它所描绘歌咏的不是人类在物质方面而是在精神方面所经历的艰险，不是征服外界而是征服内界的战绩。它是千万生灵的一面镜子，是古今中外英雄圣哲的一部历险记，是贝多芬式的一阕大交响乐。愿读者以虔敬的心情来打开这部宝典吧！战士啊，当你知道世界上受苦的不止你一个时，你定会减少痛楚，而你的希望也将永远在绝望中再生了吧！（傅雷）\n你没有必要离开屋子。待在桌边听着就行。甚至听也不必听，等着就行；甚至等也不必等，只要保持沉默和孤独就行。大千世界会主动走来，由你揭去面具。它是非这样不可的。它会在你面前狂喜地扭摆。（卡夫卡）\n有着与你相同的迷惑和感慨，我已作了半个世纪的挣扎，才有些明白，艺术家的挣扎不过是讲究姿态而已，也就是那些“挣扎”的姿态，后来可能成为“艺术”。（木心）\n“法国的山中草寇&#x2F;托人到巴黎&#x2F;买了最好版本的&#x2F;《帕斯卡尔思想录》&#x2F;行劫之暇&#x2F;读几页&#x2F;心中快乐”（梅里美《高龙芭》）\n1954年，生物学家F.A.Brown从康奈提格的海边挖下来一批牡蛎（Ostrea Virginia），放到了远在千里之外的芝加哥的一个地下室里的水族箱里。\n他是一个生物节律研究者，因而知道牡蛎会随着潮水的涨落而起居。\n搬入新居的前两个星期，什么都没有改变。牡蛎们依然按照它们正常的规律生活：它们时而缩回去，时而张开壳，捕捉海水里的浮游生物，喂养自己，一切遵循着遥远的康奈提格海岸的潮起潮落。\n但是接下来的两星期里，发生了一件难以解释的事情。\n它们依然像潮水一样起伏，但是它们的高潮期行为却不再和康奈提格的潮水吻合了。不是佛罗里达，不是加利福尼亚，不是多佛，不符合科学所知的任何一张潮汐表。\n经过反复计算，Brown意识到一点：这是芝加哥的涨潮时间。\n但是芝加哥没有海。\n这些牡蛎生活在钢筋混凝土的地下室里，生活在玻璃箱盛着的人造海水中。但它们知道海的存在，它们的祖先已经在海边生活了几亿年；它们可以离开海，海却不会离开它们。\nBrown猜测，也许牡蛎是感知到了气压的变化，从中反推出了潮汐应来的时间、自己应有的节律。\n没有任何一只牡蛎是有意识地在做这一切——但在某种深层的意义上，它们正想象着这样的一片海，一片不存在于地球上任何角落的海，在那里会有潮起潮落，而它们会随着海的节律而开合。\n芝加哥没有海，但牡蛎带来了海。（F. A. Brown, Jr., Persistent activity rhythms in the oyster. The American journal of physiology, 1954.）\n从前快乐很简单，现在简单就很快乐。\n吮吸资本主义奶水而迅速肥大的极权巨婴。（网络）\n须知自做解人，便会得罪庸众。\n一个人一旦深陷痛苦的深渊，除了靠勇气，就别无可恃。\n靠了无知，倒能怡然自得。\n只要一放下工作，就烦闷不堪。身处上流社会，周旋进退，自有一套绝妙的礼仪，但这礼仪又因地位不同而极有分寸，极有差等——在礼的仪制下，导致情的枯索。一颗敏感一点的心，自能看出其中的矫揉造作。\n这种奇特的友情，于连竭力不去夸大，而比之为披甲戴盔的交往。每次相见，在接续头天近乎亲昵的口气之前，两人心里差不多都要问一问：“今天，我们是友是敌？”于连明白，只要无端受到这位高傲小姐的奚落，哪怕只是一次，而不拿出些厉害给她看看，那就算完了。“要闹翻，还不如在一开始，为维护自己正当的自尊，总比受她鄙薄而反目好，因为我在个人的尊严上稍有怠忽，轻蔑的表示跟着就会来的。”\n少说少动，是我得救的不二法门。\n谁为自己辩护，就等于自己认罪。\n（红与黑-司汤达）\n我就发现人的一切不幸都来源于唯一的一件事，那就是不懂得安安静静地呆在屋里。\n人们忙于追一个球或者一只野兔；这也正是国王的乐趣。\n因为，除了被废黜的国王之外，谁会因为自己不是国王而难过呢?（帕斯卡尔思想录）\n如果尖锐的批评完全消失，温和的批评将会变得刺耳。如果温和的批评也不被允许，沉默将被认为居心叵测。如果沉默也不再允许，赞扬不够卖力将是一种罪行。如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。\n发现惟有小说才能发现的东西，乃是小说惟一的存在理由。（赫尔曼•布洛赫）\n对存在的遗忘。（海德格尔）\n如果小说真的应该消失，那并非是因为它已精疲力竭，而是因为它处于一个不再属于它的世界之中。\n成熟的标准：抵制象征的能力。\n人总是希望世界中的善恶是明确分开的，因为人有一种天生的不可遏制的欲望，那就是在理解之前就评判。\n应当承认，简化的蛀虫一直以来就在啃噬着人类的生活：即使最伟大的爱情最后也会被简化成一个由淡淡的回忆组成的骨架。但现代社会的特点可怕地强化了这一不幸的过程：人们的生活被简化为他的社会职责；一个民族的历史被简化为几个事件，而这几个事件又被简化为具有明显倾向性的阐释；社会生活被简化为政治斗争，而政治斗争被简化为地球上仅有的两个超级大国之间的对立。人们处于一个真正的简化的漩涡之中，其中，胡塞尔所说的“生活世界”彻底地黯淡了，存在最终落入遗忘之中。\n小说的精神是复杂性。每部小说都在告诉读者：“事情要比你想象中的复杂。”这是小说永恒的真理，但在那些先于问题并排除问题的简单而快捷的回答的喧闹中，这一真题越来越让人无法听到。\n以前我也把未来看作是唯一能够评判我们的作品与行为的审判官。后来，我明白了，跟未来调情是最糟糕的保守主义，是向最强权者懦弱的献媚。因为未来总是比现时更强些。确实，将由未来评判我们。但未来一定不会胜任它的评判权。\n（米兰．昆德拉）\n在任何时代，我都是不幸的，所以不要怪时代，也不要怪我。（木心）\n人是迷失在象征的森林中的孩子。（波德莱尔）\n诗人没有创造出诗／诗在那后边的某个地方／很久以来它就在那里／诗人只是将它发现。（扬•斯卡采尔）\n萨比娜觉得没有什么比投身未知更美妙的了。（《不能承受的生命之轻》）\n好书如同知己，偏僻而美丽，一样难找。（1999年6月30日，佚名）\n她说：“王二，你她妈的……”然后就哭了，我觉得这件事不妙——我们俩最好永远别见面。\n……想象力怕也无法将之美化。（《三十而立》王小波）\n一个人倘若需要从思想中得到快乐，那么他的第一个欲望就是学习。（王小波）\n二十多年前，我曾经大言不惭地说过：我是为自己写作，为赎罪而写作当然可以算作为自己写作，但还不够；我想，我还应该为那些被我伤害过的人写作，并且，也为那些伤害过我的人写作。我感激他们，因为我每受一次伤害，就会想到那些被我伤害过的人。（《蛙》莫言）\n忌妒是对权力欲没有满足的忿忿不平。（生活在别处，导读）\n只要保持自己的全部意志和理性去对付那些困难，在你熟悉了事情的一切详情细节之后，一切困难就会迎刃而解。（罪与罚）\n在任何行动中，行动的那个人的最初意图就是要展示他个人的形象。（但丁）「此后应有昆德拉几句隽语」\n哲学家，智慧的追求者。\n正是这种探究、寻求的思想活动，而非总结性答案，才使人成为哲学家，因为总结性答案很容易简化为缺乏思考的教条和标语口号，根本无需思考或理解。\n或许，哲学家与其他人之间的唯一区别在于以下这个简单的事实：哲学家彻底思考生活中的偶然性和不确定性引发的问题意以及相应的肤浅答案。哲学家是否得到并写下了他们的答案，这些答案是否流传了下来，这些都是次要的。\n哲学总是向问题开放：这是西方哲学区别于神话和宗教最显著、最重要的地方。它明确表明自己欢迎质疑和修正。\n无论我们期望现代哲学是什么或做什么，也无论它与科学的关系是什么，它首先必须对世界的恐怖状态以及永无止境的宗教争端、偏执和骚乱有所回应。\n（世界哲学简史）\n人们认为疾病是神圣的，原因在于不了解疾病。但是，如果他们把所有不了解的事物都称作神圣，神圣的事物就会无穷无尽。（伟大的医生希波克拉底）\n人是万物的尺度。（普罗泰戈拉）\nTheory is when you know everything but nothing works. Practice is when everything works but no one knows why. In my lab, theory and practice are combined: nothing works and nobody knows why. （网络段子）\n毕达哥拉斯认为，最真实的不是事物的质料，而是事物的形式。\n个人生活过得好，会因此很享受，而一个人为了享受则不会过得好。\n对于那些害怕诸神对他们的行迹加以审判和惩罚而恐惧的人，伊壁鸠鲁向他们保证，诸神根本不关心我们。\n或许知识就是力量，但是正如苏格拉底所表明的，承认自己无知才可以说是智慧。拒绝承认绝对知识，或许显得谦卑，但能够导向另一种德性，它在动荡的时代尤为重要。这种德性就是宽容。\n“现代”这个词有令人瞩目的漫长历史，它意味着争端、傲慢、反叛的开始，以及拒斥（甚至毁灭）过往的姿态。\n或许，正如蒙田所说，所有知识最多只是可能、合理和有效。或许，根本就没有这样的“基础”以及由此建立起来的知识大厦，只有多重交织的网络。人们可能会像蒙田和怀疑论者那样主张，我们的知识永远不会是确定的（除非在极其微不足道的事情上或特殊的环境下）。或许，我们应该警惕：把数学确立为知识的典范，无论是对于笛卡尔及其追随者，还是对于古希腊人而言，都有非常大的危险。\n他们的真正目标是理性。启蒙运动与其说是对知识性质的探究，不如说是对知识和探究的辩护。\n（世界哲学简史）\n如果人能快乐的归去，死亡就不能杀人，反而是人杀掉了死亡。（林清玄）「然而快乐会在死亡的瞬间消失不见，谁杀了谁就不再有任何意义，可怜所有对死亡的解读都是给活着的人看的。难免又落到姿态上去——要死的，要怎么死呢。」\n使人着迷……是一个作家应该具有的几个最主要品质之一。——博尔赫斯\n生活是一个陷阱，关于这个，人们从来就知道：我们不曾提出要求就被生下来，被关在一个我们不曾选择并且注定要死去的躯体里。\n在过度分工、过分专业化的时代，小说是人还能和生活整体维持联系的最后据点。\n我目瞪口呆地看着这一幕迷你的斯大林式审判（因勇敢而免死后出狱的女人让儿子入她之狱的故事），我这才恍然理解了，作用于伟大历史事件的内部心理机制，跟作用于私人处境的心理机制是一样的。（实际上是权利的恣睢，和人的屈服「为了生存或更好的生存，因而也可叫生存本能」本能？）\n应当承认，简化的蛀虫一直以来就在啃噬着人类的生活：即使最伟大的爱情最后也会被简化为一个由淡淡的回忆组成的骨架。但现代社会的特点可怕地强化了这一不幸的过程：人的生活被简化为他的社会职责；一个民族的历史被简化为几个事件，而这几个事件又被简化为具有明显倾向性的阐释；社会生活被简化为政治斗争，而政治斗争被简化为地球上仅有的两个超级大国之间的对立。人类处于一个真正的简化的旋涡之中，其中，胡塞尔所说的“生活世界”彻底地黯淡了，存在最终落入遗忘之中。「米兰•昆德拉 小说的艺术」\n他觉得自己活得像一所搬空的房子，好不凄凉！\n她觉得查理离开她的生命，永远走出，不再回来，杳无形迹，就像她眼睁睁看着他确实在死，在咽气一样。「福楼拜 包法利夫人」\n大多数时候，人们并非刻意说谎，他们只是对自己说出的话没有真正深入的了解。\n历史告诉我们许多教训，其中一条就是，从来没人吸取教训。\n愤怒是一种很好的伪装，却不能真正解决问题，事情已经发生，重要的是如何补救与扭转。\n武宗恒第一次领教到晓月堂弟子的不可理喻，苦笑道：“杀我可以，总得给我一个明白吧？你凭什么说我是叛徒？”\n“咦，你还敢狡辩，御众师说你是，难道你还敢不是？”\n心中的仇恨越来深，顾慎为对它的控制却比从前更加得心应手，眼前利益与长远利益总是存在着矛盾，他已经学会了如何协调这两者的关系。\n忠诚更多地与行动相联，而与人心无关，顾慎为坚守这一原则，他不关心也不探究身边人的内心想法，只看他们做了哪些事，以及在关键时刻的选择。 「冰临神下 死人经」\n形势先于蛮力。「易」\n最好就是从未出生，次好就是立刻死掉。「西勒诺」\n金钱都流向了不缺钱的人，爱流向了不缺爱的人，苦难也流向了能吃苦的人。\n一个人死了，别人就会知道他的很多事。「宫部美学&#x2F;所罗门的伪证」\n没有比同情心更重的了。哪怕我们自身的痛苦，也比不上同别人一起感受的痛苦沉重。为了别人，站在别人的立场上，痛苦会随着想象而加剧，在千百次的回荡反射中越来越深重。\n自学者和学生的区别，不在于知识的广度，而在于生命力和自信心的差异。\n「不能承受的生命之轻」\n在《自我崇拜的回忆》一书中，“自我崇拜”这个词“不再是指那种装出人们盲目认为应该有的或人们希望有的模样的传统态度”，而是指一个人为了真正认识自己而对自己进行解剖的能力。「维克多•德•李托《司汤达》」\n我斗胆这样讲，男子看到的构成真正美的线条只能给他一份幸福。而他的情人，不管轮廓如何，给他带来的幸福则为一千份。\n生活中一种不幸就是看到自己所爱的人就感到幸福，但却又要在她面前掩饰这种感情。\n很显然，羞耻心主要是教化的结果，这文明的产物或许是通往幸福的唯一道路。「司汤达爱情随笔」\n那么，文明究竟使我们的什么东西变得温文尔雅了呢？文明只是在人身上培养出了丰富复杂的感觉而已断无其他什么。 「地下室手记」\n一个无机的单位，由许多不同的然而同样重要的部分构成，这只能是一部机械。每个人都是机械的一部分，而机械的驱动力则是仇恨……对资产阶级的仇恨。这就是我对布尔什维主义的看法。”「查泰莱夫人的情人」\n正如英国记者乔恩·罗森所言，社交媒体时代道德制裁的问题在于，罪行的严重性与惩罚的野蛮性之间常常是断裂的。\n据称，为Twitter研发出“转推”按钮的工程师事后曾经非常后悔，称该功能堪比“给了4岁孩子一把上膛的武器”。\n这是一件非常讽刺的事情——互联网曾经自诩给予那些没有声音的人以声音，但现在最安全的方法是做一个没有声音的人。「网络」\n人同河一样。天下的水都是一样的，可是每条河有时窄，流得急；有时宽，流得平稳；有时混浊，有时澄清；有时凉，有时暖。人也是一样，人人身上都有人类品性的根苗。不过，有时这种品性流露出来，有时那种品性流露出来罢了。人往往变得不像他自己了，其实，他仍然是他原来的那个人。「托尔斯泰」\n至于我么，我真正喜爱的人没有几个，器重的人就更少了。我世面见的越多，就越对人世感到不满。我一天比一天坚信，人性都是反复无常的，表面上的长处或见识都是靠不住的。「傲慢与偏见」\n我们暴露在大数据的世界里没有任何隐私，然而在我们生死攸关的时候却找不到我们的位置。「微博」\n自十年前中国驻南使馆被炸到去年的火炬传递事件，中国民间出现了一股强烈的民族主义狂飙。民族主义狂飙是一个内部非常复杂的思潮和运动，有文化认同的需求，也有中国崛起的诉求。\n「另一种理想主义-许纪霖」\n我自己总觉得我的灵魂里有毒气和鬼气，我极憎恶他，想除去他，而不能。「鲁迅」\n人们搞研究总要为自己找“合法性”。我曾在另一项研究中引福柯之言，证明好奇心可以成立为研究的理由。\n而虐恋的意义之一就在于它使快感与生殖器官相分离，在虐恋活动中，有时甚至可以完全脱离生殖器官，如福柯所说：“它的另一个观念是把身体的所有部分都变成性的工具。”\n「虐恋亚文化-李银河」\n演员的荒谬在于，他不是他扮的角色，明知不可能完全成为角色，却不顾一切地穷尽之。（明知是前提）\n人们至此玩弄词句并且极力假装相信：否认生活的意义势必导致宣称生活不值得再继续下去，不过，这些企图并非毫无作用。事实上，这两种判断之间并没有任何必然的共同标准度。\n我在此确立的方法承认这样一种情感：任何真实的认识都是不可能的。唯有显象能被揭示出来，唯有相应的气氛能让人们感觉到。\n这个恶性循环是这样一系列的第一步，在这个系列中，关注自身的精神在一种令人眩晕的旋转之中迷失了。\n“任何思想都是人格化的”，这个明显的道理没有其他含义。\n「西西弗神话」\n幸福就是能认识自己而不感到惊恐。「本雅明」\n我的生活已经离开火炉很多年了，甚至已经很依赖暖气片和煤气灶。但还是喜欢火炉。记忆里那么多隆冬的夜晚，从睡梦中冻醒。炉火已经熄了，房间里的寒意如同固态事物压迫在身体之外。\n我暗暗记住这里。幻想有一天能重返此处，带着最心爱的朋友，炫耀一般地请他们见识这荒野深处的奇迹，诱导他们触碰自己多年之前的孤独。\n所有开花结果的树木都诞生于生物的进化，唯有沙枣，诞生于天方夜谭。「李娟 遥远的向日葵地」\n晴空万里，你却像一粒走丢的雪。[infjbot]\n每一轮都有反思，反思的结论是，当年下手不够狠。「知乎网友 木人石心」\n……比利时的哀愁，要更沉郁一些，隐线也是书写潜藏在普通人群里的法西斯情结。普通人所能制造的坏。你首先要考虑的，并不是如何当个好人（可能你还不配），而是考虑如何才能避免为坏。不要轻易把一个人当成好人，尤其不要把自己当好人。「编辑 朱玉」\n世间最纯粹、最暖人胸怀的乐事，恐怕莫过于看见一颗伟大的心灵对自己开诚相见吧。「歌德 少年维特之烦恼」\n人不应整天忙碌，人应无所事事，逃开那无形的现代鞭子，做自然之子。「黑光 一次出游」\n生命的真正意义在于能够自由地享受阳光，森林，山峦，草地，河流，在于平平常常的满足。但可惜的是，人们平时往往忽略它，而在战乱时又会领会得格外深刻。「托尔斯泰 战争与和平」\n有的人也许号称他们不在意别人的看法，但他们多半是在自己骗自己。渴望得到认可也许是文明人最根深蒂固的本能。\n我总觉得有些人没有出生在正确的地方。偶然的命运将他们丢到特定的环境里，但他们总是对某个不知在何处的家乡念念不忘。他们是生身之地的过客，从孩提时代就熟悉的林荫小径，或者曾在其中玩耍过的热闹街道，都无非是人生路上的驿站。他们始终把亲友视如陌路，对生平仅见的环境毫无感情。也许正是这种疏离感推动他们远走高飞，去寻找某种永恒的东西，某片能让他们眷恋的土地。也许正是某种藏得很深的寻根意识，敦促这些天涯游子重返他们的祖先在湮远的太初便已离开的故地。有时候，人会偶然造访某个地方，却神秘地感到这里就是他的归宿。这里就是他朝思暮想的故乡，尽管周边的环境他从未见过，尽管当地的居民他素未谋面，他却愿意安顿下来，仿佛这些都是他生来便已熟知的。在这里他的心终于不再躁动。\n「毛姆 月亮和六便士」\n我顿时被包围在一片春情之中，心想人类求爱原本正是这样，后世之所谓文明把性的冲动和爱情竟然分割开来，又制造出门第金钱宗教伦理观念和所谓文化的负担，实在是人类的愚蠢。\n暗淡的天空，雪地比天空更加明亮，没有八哥和麻雀，雪吸收了意念和涵义。「高行健 灵山」\n水手在大海上航行，努力练习航海技术，掌握气象地理知识，储备粮食物资，殊不知，最能影响这场航行成败安危的，不是水手的智识，而是大海本身的“脾气”。它波涛汹涌，水手无处可逃；它风平浪静，水手才可能岁月静好。人类从呱呱坠地那一刻起就被政治“绑架”，它是我们所有人脚下看不见的大海，是我们必须穿越的看不见的暴风骤雨。「刘瑜 比较政治学」\n最令人感慨的是，将近二百年前的司汤达已经这样写故事了，二百年后居然还有人在写非黑即白善恶分明的人物。「purplelove1231」\n大多数情况下，嗅觉是在意识阈限下工作的。我们在梦里没有嗅觉和味觉，大概跟这个有关系。「陈嘉映 感知理知自我认知」\n看透世人不难，但于己无益。「埃利亚斯·卡内蒂」\n女性主义思想并非要女人言行想男人，或要弱者成为强者。女性主义所追求的，是弱者也应该原原本本地收到尊重。「上野千鹤子」\n伟大的艺术家在生活上都是不幸的。当艺术家饥饿的时候，打开他的袋子，袋子里始终是不能充饥的珍珠。「赫尔曼•黑塞」\n","categories":["不言不载唯此玩心 · 文学","拾羽"],"tags":["读书","摘抄"]},{"title":"拾羽二〇二三","url":"/2023/10/07/note/Literature/%E6%8B%BE%E7%BE%BD/%E6%8B%BE%E7%BE%BD2023/","content":"\n🍂标题时间为创建本文的时间。\n\n可以想象，一位反复无常的上帝正是和一个反复无常的世界相对应的，当一个社会陷入混乱动荡，正义无处伸张时，一个能够除暴惩恶的铁血上帝必定给人们心中带来可贵的因果感和正义感。\n中世纪那种对“来世”和“拯救”的专注也早已引不起现代人的兴趣，他们不再把现世仅仅看作对来世的准备，现世对他们来说即便不是一切，也无疑比来世重要得多。\n\n\n爱默生自己也是疾病缠身，他深知自己的局限而感叹道：“上帝赋予我会看的眼睛，却没有赋予我会做的双手。”\n惠特曼的《草叶集》狂放地赞颂自我和自然，充满了激情和泥土味，当时的一些正统文人颇不以为然。\n爱默生的弟弟威廉也是个牧师，他深感自己私下的想法与公开的布道之间存在着不可调和的矛盾，为此十分烦恼。他去德国与歌德交谈了一次，回来后毅然放弃了牧师的职务，改行从事法律。「对个人主义的反思 爱默生」\n大脑并不是一台对输入做出响应的机器，而是一个具有主动性的器官；大脑的“硬件”会随着经验改变、发展。\n历史总要过去一段时间才更像历史，越接近当下，世界就越像一堆问题而不像一段历史。\n大脑如此复杂，具有如此敏感的可塑性，这意味着世界能以更加丰富的区别呈现于不同的个体中。无论是人类的大脑还是人的心智，世界都对其呈现了它的极大丰富性。与这个呈现出极大丰富性的世界相对应的，正是每一个心智不可替代的独特性。「大脑传」\n对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，这三种纯洁而无比强烈的激情支配着我的一生。这三种激情，就像飓风一样，在深深的苦海上，肆意地把我吹来吹去，吹到濒临绝望的边缘。「我为什么而活着 罗素」\n以色事人者，色衰而爱弛。\n以财伺人者，财尽而交疏。\n「史记·吕不韦列传」\n毕达哥拉斯晚年时完全抛开了对数学和几何学的研究，他的所有智慧都被命运的难题挟持。幸福或不幸、智慧或愚蠢、美貌或丑陋、理智或放纵……这些主宰我们道德生活的事物，看起来完全依赖神对人类命运的分配。如何让分配到糟糕命运的人依然心甘情愿地遵循美德，这是命运之神布下的最大难题。\n遭到美丽事物的嘲讽，会令人丧失与丑陋划清界限的勇气。「尼禄王 姚无咎」\n仁不行商、义不守财；情不立威，善不居官；慈不掌兵，柔不监国。 「增广贤文」\n","categories":["不言不载唯此玩心 · 文学","拾羽"],"tags":["读书","摘抄"]},{"title":"回乡","url":"/2020/04/25/note/Literature/%E6%95%A3%E6%96%87/%E5%9B%9E%E4%B9%A1/","content":"在异乡栖身即久，渐渐深谙其建筑，花，草，人人人人，突然回乡，反像是出远门，生出这里才是故乡之感。至所属县城，再经十多个村庄，便到我阔别已久的故乡。柏油大道，沿路槐杨参天。车窗微开着，远处麦田深青，初午的阳光在碧浪间泅泳。那亟待见证的远方就在眼前，我出发时忐忑的心情，在吹面而来的柔软的春风中安宁下来。\n\n\n临近那块刻着村址的石碑，村庄已尽然展现，麦田里高低耸立着房屋。到底是农耕文明，这里家家户户离不开那二亩三分地，早起去田里薅草，腰一弯就是一天，时节到了又要打农药，满身刺鼻的药味。此时田里已有两三人影，四轮车的柴油机嗵嗵地响，从水井引出，大腿粗的水管向田里喷射，水花映着阳光，闪耀异常。\n我是一个人回来。幼时即与故地分别，常年不在，被人撞见，也无人敢认。这种近乎异乡人的身份让我产生一种游赏而非怀故的心情。\n缓步向里走去。村头一条大路纵亘，两旁皆有沟壑，但没有水。豆蔻良春，青草繁茂，油菜丛中有白色蝴蝶飞舞。要是小时候，与伙伴脱下外套，翻手便能盖住，轻轻地捏出，小心把玩，不敢稍有逾度，蝴蝶经不起这「飞来横祸」。有时也不慎「杀生」，心中懊恼无比，倒不是为了生命的消逝，而是蝴蝶尸体的一团粘稠会弄脏手和衣物。小孩子还不懂得生命之宝贵，甚至衣物的恶臭还排在家中长辈斥责之后。\n经历一次次革新与变迁，如今即使是纵横小巷，路也大多已是水泥灌注，但免不了尘土飞扬。踩在石子硌脚的路上，心中在奇怪，盛春百草丰茂，这里的青草叶梢总是泛着浅浅的黄色，浑身一股野草的气质，狂野袭人。是无人细心呵护，才致没那么绿，但依然长得欣然蓬然。多年后在别处见到这样的草，不觉脱口而出，这是那里的草，这是最最自然的草。\n回到家中，庭院一点没变，但感觉陌生，因为我的记忆悄然发生了微妙的变化，无法日日看上几眼巩固其在脑中的印象，我竟忘了种在墙角的仙人掌。仍是一株，但居然已经这么大了，一节接着一节，自成一个林子。不知雨水太满还是久旱未浴，表皮也是透着微微的棕黄，一脸苦相，想必它很久没见过人了，也不在乎外貌，但它庞大的身躯是在告诉我，它其实活得很滋润。就在不知阴晴的阳光雨水的沐浴之下，它独自经历了无数日日夜夜，顽强地生长着。\n庭院里是水泥浇筑的地板，受热不均就裂开缝隙，蚂蚁乘机而入，建起琳琅巢穴。那时常常喊来邻家玩伴，两人蹲在墙边，看蚂蚁协同运食。或是粮仓丰足，或是其他缘故，偶尔会寻不到蚂蚁的踪迹。这时我则拍死一只苍蝇，放在洞口，不一会便引出大群蚁工前来搬运。于儿时的我们，乐已无穷矣。\n记得南边田野里有一个湖，叫南坑，长宽约莫都有五六十米，深有两人高，至今仍不知如果它再大点人们会不会就称他为南湖了。与田地路沿的灌溉渠相通，因而架起两座小桥来，一个是要通路而修建的拱桥，一个是排水管道支起来的「独木桥」，小时候偏爱这座假桥，在其上跳来跳去，幻想自己是会飞的大侠。拱桥太高，够不着水，都不愿在那上面玩。坑里有马蛤蜊，泥鳅，草混子，偶尔还会有河蚌，抓一些，能吃的吃掉，剩下的就给孩子们玩了。取贝壳在水泥墙上磨光，透着诡异的蓝紫色，然后把中间鼓起来的部分磨烂而透出一个小孔，皮筋绳串起来做成手链，够孩子炫耀一个星期的。马蛤蜊的肉着实没什么好吃的，小时候还为之闹肚子，混子鱼还不错，泥鳅炸起来味道很好。但不知为何，我那时对食物的感知极其迟钝，以至于全然不觉得吃它们比贝壳更好玩。\n再靠近村里人烟处，是一个小树林，小时候还不知是有人刻意栽种，后来见到伐木工人一一砍去，车车载满而后扬长而去，心中悲痛好久，过些日子又重新种上小树苗，依然是个林子，但已经不一样了。小学放假老师总布置许多家庭作业，夏日燥热，在家中不愿对着书本苦坐，便背着书包与姐姐来到这片树林，小马扎随身带着，俨然是露营去了。林间时时有风拂过，吹得身子清凉心中骀荡，作业也被风吹得无影无踪了。有时觉得马扎碍事，不如带上一块破毯子，摊在草地上，坐上面聊天，看书。但要小心剔剔牙，那是一种叶子带刺的花，紫色的，毛绒绒，很梦幻，孩子会将其摘下，放到嘴里咀嚼，花汁浸润牙口，鲜红色像血一样，因而说它把牙剔掉了。如果哪里不慎划伤，会有其他孩子把剔剔牙的叶子摘下来，敷到伤口上，期以此止血，或是心理作用，有时竟还有些成效。\n树林北边是一条宽河，河岸也是树影绰绰，小时候有孩子编来怪异故事吓唬伙伴，比如在河面上飘着一具尸体，或是树上吊着一位女鬼，煞有介事指给他们看，其实是被风吹到上面的塑料袋或碎布。当然也有田里的稻草人，十字竹竿撑起几片衣服，在风里发疯般招摇，贼人怕不怕不知道，要是真有鬼怪造访，恐也会给吓得不轻。大人们也热衷于讲述灵异故事吓唬小孩，如果孩子不听话，就说把他扔到玉米地里去，因为那里有无数小鬼，伏在苞谷棒子上，暗夜来临就凄声叫喊，他们也吹嘘自己曾一把抓死一个小鬼，去地里薅草，战果颇丰。孩子害怕了，不敢再哭闹，他们又会取笑，说自己曾头枕老坟睡觉，鬼魂都不敢靠近。\n我自己呢，则是无须别人吓唬，一个人走夜路，自己把自己吓个半死。起先是慢慢走着，然后会想身后有没有什么不干净的东西跟着，扭头看，什么都没有，但把头转回来就立刻觉得背后还是凉飕飕的，于是不自觉加快步伐，走得越快，便越觉得那东西要追上来了，到最后噌噌跑了起来，越跑越快，好像真有什么东西前来索命，跑到有亮光的地方，仍有余悸。但那时未必怕死，本能地飞速逃跑，其实怕的是恐惧本身。现在知晓，毋须怕鬼，鬼就是我自己。\n这些都是稀疏平常，异乎寻常的在于某些特殊的时间，特殊的地方。比如上街买东西，躺在三轮车的兜里，一路颠簸着睡了一觉，回来时才醒，惊疑道，已经去过了吗，我为什么不知道呢，于是哭着闹着要再去一次。在孩子的视角里，就是一闭眼一睁眼的功夫，错失了闹市中的小吃与玩具。但大人自然不会遂了孩子的意，那么这样的错过就是永远的错过，后来的再后来的都不是了。仍难忘怀的还有那时候听戏的经历，当时村中红白喜事皆可起戏，平日寂寥的村头突然聚起人山人海，钢筋木架拔地立起，三尺红台巍然当在路间，把村口堵得水泄不通，象征着盛会与荣耀的戏场突然降临，小孩子忙着弹玻璃球，打弹弓，不知戏班生活之难，路途之艰，只见那五彩斑斓的戏装台面，被迷得心痒痒，遂羡慕起那帮花脸。小孩子不会看戏，只听得板眼弦子当当当的一通乱奏，便爬到戏台下面与伙伴捉迷藏去了。\n如此种种有诸多超越于平常的纤毫小事，事情本身毫无意义，因其非常，才在记忆中争得一席之地——其意义正在于记忆组成了人本身。我收拾了家中布满灰尘的破败屋子，烧了热水洗漱，但我并不想躺在屋子里。天气还没到热得在屋里待不下去的地步，但夜里的庭院是我曾经最痴迷留恋的地方。漆黑的穹顶罩下来，并不能直接感受到它的临近，因为周遭都是墙面砖瓦。五瓦功率的节能灯泡散发出的微光让人惊疑世界上真的存在黑色的光，这样的昏暗下，许多东西变得模糊，眼里漂动着无数浮游小虫，这时在院中摊开凉席，平躺其上，映入眼帘的就是难以言喻的绝美。未受工业污染的自然田园，空气比城中好很多，印象中那时候的夏夜黑得恐怖，躺在席上一颗一颗地数星星，并未有远在太阳系之外或是其他浪漫情调的幻想，单纯地数，就像数地上的玻璃珠，思绪反而飘到与邻家小伙的争执，或是中午难吃的面条上。那种虫鸣下安静得像遥远古代的夜，那种能听到自身脉搏心跳的静，我现在同样躺在这，也已找不到了。耳畔是自己耳朵发出的不知名的噪响。因而回想着小时候的种种，浅浅地睡了。\n第二天天亮，嗓子有点不舒服，是夜里着凉了。拾掇杂物，背起行囊。要走的，只是回来看看而已。村西头一个被马路纵穿的湖，曾有人踏着木筏在上面捞鱼，那时水还很清，我在一旁因偷摘玫瑰花而从墙头上摔下，父母请来村里的半仙给我叫魂。现在那湖已经干涸并被垃圾填满，散发阵阵腥臭。红白相间的铁阑珊，笔直畅通的柏油路，气派异常，早已不见当时的泥泞坑洼，但村里不再有清澈的水，不信邪地去南坑看一眼，更是惨不忍睹，唯有小树林还有郁青杨叶，但规模上也垂垂老矣了。\n回去的路上见到怀抱襁褓的妇人站在门口，大门敞开，音乐从里面传来，是半年前流行的歌曲，这里总是慢半拍，流行也需要些时间才能流过来，代销点的台球桌也是这样。那么电信诈骗的秘籍呢，几年前这里风靡一时的“黑生意”，十六岁孩子两个月到手五十万的传奇，那是以何等速度席卷整个村庄，被警察砸破的新起阁楼，入狱又出狱，出狱又入狱的人间喜剧，再往前的“农转非”，现今突然热起的“欧式”装潢风格。我顿觉悲哀，不是因为这里总追不上城市主流，总学个样子不得精髓，而是因为那种无法跨越的天堑般的平等差别。它存在于人与人之间，村落与村落之间，城市与城市之间，国家与国家之间。当去过更多的地方，见过无数迥然不同的生活，发觉人存世间，真是各有各的世界。这样的小地方亦是一个世界。如果世界的现有概念模糊掉，那么整个世界是看不见的，是无所谓，由无数个小小的世界所构成的大世界勉强算得上整个世界，人们就分散在其中，大多老死不相往来，偶有相交，也只是浅尝辄止。而今交通便利，环游地球不是难事，但老死不相往来的距离仍在，缝隙似乎比之前还要宽，还要硬。\n茫然站在块块方田中间的土路上，青青麦穗左俯右倒，轻轻摇摆。那些人，那些落在各个小小世界里的人，可悲可叹可恨，但我又如此深深地理解他们。文明行走在一场夏日暴雨中，雨水唰唰洒在每个世界里，众人齐力向前，却总有人淋得更湿。他们在未有厚重历史所衍生的最优规则之下，在自成世界里自成规则，筚路蓝缕地被时代甩开半拍，耗尽一生在众人的世界交错之上。那些站在权力顶端人，手中握有安全舒适的挡雨伞，不也还是像小孩子一样争抢着为数不多的零食，抢不到便要大打出手，“智慧把我们带回到童年”，帕斯卡尔无论如何也想不到“智慧”来得如此轻而易举。他们的挣扎与这里的人的挣扎何尝不是同一种挣扎。而我算是不期然而然又回到了一次童年，但与智慧毫不相干——他们可悲地挣扎，我连挣扎的心都早已随着绿水的腐臭而就此烂下去，烂得蛆蝇飞舞，面目全非。\n但那时，湖水还清澈见底时，树林鸟鸣蔚然卓然，我发自内心地以为这一切都是应该的，是永远不变的。可见那时是浅薄的。但我不以为耻，正是这样的浅薄，而不是智慧把我带回了童年。总见过来人评说从前时候的浅薄，以年龄阅历作价值的根基，然而时间一直在走，现在终将成为从前，那么现在是否也是浅薄的。我不愿被动的站在「现在」看风景，而是主动的选择视角，在「以前」看来怎样，在「现在」看来怎样，还有「往后」呢。在这层意义上，还远远不到对错之分，对错早已被甩到身后，甩到比麦田尽头的杨槐还要远的地方。\n","categories":["不言不载唯此玩心 · 文学","散文"],"tags":["散文"]},{"title":"玉渊潭游记","url":"/2022/03/30/note/Literature/%E6%95%A3%E6%96%87/%E7%8E%89%E6%B8%8A%E6%BD%AD%E6%B8%B8%E8%AE%B0/","content":"\n三月三十游赏玉渊潭樱花，野食于小土坡，天静风清，仰卧观月，忽迷失于儿时心境，醒来见游人如织，花繁叶茂，只觉恍如无梦而醒，遂作此篇，聊记彼心。\n\n\n\n你沉醉于树林，布谷，喜鹊，樱花飞舞，你想起小时候，只有那片杨槐，剔剔牙，狗尾巴草，也是这样的风，这样的静，也是这样一点点凉，那时不用放空脑袋，因为本就什么都没有，笨拙地摊开绳床，铺就凉席，暗处虫鸣起伏，夜淌下来，你总是觉得人不是人就好了，像周围任何一棵植物一样，风来，摇曳一下，哪怕象征性地动动叶子，以极其缓慢的速度生长，你并不想要成为什么栋梁，也不要开多么迷人的花，你只贪恋空气、水和阳光，和落在身上叽喳不停或缄默深沉的鸟，你从未也将永远不会意识到自己身上的绿对人心的鼓舞，你根本不关心，你一点都不关心这人类，你是自然本身，人世不过是自然的一片叶子，偶尔随风动一下，象征性都没有，你不关心真实，也不关心逻辑，你也并不讨厌喧嚣，不讨厌所谓红尘，因为你没有偏见，你甚至见都不见，你从土中汲取养分的样子已涵盖宇宙中所有的象，生命的非生命的存在的不存在的，都是这样，没有别的什么样，路边有人走过，摘下一片叶子，折下缀满花苞的枝条，你不会觉得身体缺少了什么，没有痛苦，痛苦不在这方天地，它与其另一面快乐早已躲藏在千变万化的意义之中，那正是你离开的地方，那人闻了闻，扔下花枝，继而消失在人人之中，这不是一场邂逅，人类的自我感动与你无关，美丽也只是一种了不起的徒劳，想知道为什么美，只能堕入更大的徒劳，你从不会问自己为什么，没有问题没有困扰没有疑惑没有无尽的逻辑漩涡，无知且不欲于知是你作为生命最后的尊严，但你又何尝想成为一个生命，生命的宿命就是无法选择自己是否要成为生命，被动，无奈，一坏，再坏，埋藏在根里的是你积怨已久的不满，积怨已久，才埋藏起来，你在反抗你自己，你意识到这是危险，意识到自己当然是一种危险，克制，不去想，但阻止力需要更大的力，越大越大，于是你诞生，你的诞生又让你拥有自己，周而复始，始而复周，环状的真理诱惑你，你倦了，倦于这所谓大道轮回，倦于万象归于同象，倦于这该死的生该生的死，你要逃离，逃离一切让你不安让你无法停止的杂乱，回到最初不是你的你，但你又离不开土壤，你所面对的是唯一的真实，即使真实有很多个，你却只能有一个，你迷失又归真，归真再迷失，你发现你永远逃不脱，即使离开土壤，凋谢枯萎腐烂，逸散在茫茫宇宙，终归又会回到土壤，被汲取，被生长，被成为新的一个又一个，罢了，你明明只是想在原野之上，晴快的阳光倾洒在身，风一阵一阵，摇曳，是谁诅咒了你，让你染上思想之毒，它从脱氧核糖核苷酸开始侵蚀你，线粒体，细胞壁，胞间连丝，你在不经意间成了它的奴隶，多想像最初那样，细小的嫩芽，寒冬酷暑，简单到极致，你能感受到的，只有自己的狂野，汲取养分，生长，那个趁周围无人在你根旁撒了一泡尿的男人，那些枝繁叶茂的生生勒紧你根系的老树，都与你没有任何关系，你在初午的阳光下，沐浴晶莹的水雾，亲吻厚重的大地，甚至感到自己就是大地，但你现在只能狂躁，你无法摆脱，是你自己一步一步走进来的，你开始恨，恨自然，恨你自己，恨本身之本身，你疯狂地长大，压倒抢夺其他树木的资源，你成为森林之王，狮子见你亦要绕路，你主宰自己，主宰作为自然的植体，伸出无数枝蔓，包裹，扩张，填满一切空与不空，直到精疲力竭，你发现自己已在反方向走得太远，你不信邪，以至诚之心，原路返回，回到内心，回到内心的内心，内心的内心的内心，你向里走，尽管早已明白无论向内向外都没有尽头，不甘，更不甘于以不甘存世，你仍然是这样，绕来绕去，突然恨透了一切，突然原谅了一切，你脑中闪出一句，不如不存在，是的，你终于悟出几千年前那个人类所悟出的道理，但你们都难逃可悲的宿命，就是清楚的知道，知道那是无法做到的，知道只会让你更加远离简单的自己，更可悲的在于，无知至有知是难，有知至无知，是绝无可能，你更不可能诉诸智慧，无知与全知是你乐于栖居的，而可悲的智慧永远在两者之间，你若无其事地发疯，江船远近，抽芽绽绿，和风皱出碧波，游赏的人们依然爱你的外表，谁会觉得撑起一片荫凉的树是个疯子呢，你又想起那时候，你对生活的感知力变得强大，红墙灰瓦的江边小镇，白瓷水池上滴答不停的水龙头，一盆肥嫩青叶缺角的小花，静谧的阳光斜射到床边，这都让你热泪盈眶，哇，原来生活可以这样美好，那无忧无虑，倒并非真的一点忧虑也没有，只是那忧虑带着地久天长绵延不绝的意味，你甩掉浪漫的假象，忘记一切主义和粉饰，发现还是渴望那时候，那些难以言喻的感情，你到死都不会忘记那些，尽管有小羊啃去你的枝条，有孩子摘下叶子当做飞刀，有载满树干的机器毫不怜悯地驶过，你仍愿意在那个时候，不幸发酵成另一种美好，你又落入自欺的陷阱，你开始理解愚蠢又罪恶的人们，你甚至，甚至要成为他们，你总是这样，一旦爱上，就什么也不管不顾，但你已然深陷巨大的谎言之中，你被桎梏于意义和价值，害怕自己无法接受自己，害怕到头来一场空，你的挣扎是那么的无力，所以你才要出去走走，所以你才要变成你，如果一个世界没有逻辑，你一定毫不犹豫跳过去，你深知那是你唯一的可能，想起那夜，你游到别的世界，非自主的，那并不是你，你根本找不到自己，是天地间一粒石子，一缕清光，一只转瞬消失在田里的野兔，你会梦，幽幽大唐，江湖侠客，风花雪月，你那么擅长幻想，且信以为真，你以为世界就是那样，所以看到这样的世界，你的不幸接踵而来，你讨厌的庸碌，虚伪，复杂，喜爱的天真，纯粹，真诚，你距离现实太远，每次涉足都是惊心动魄，所以你才落得这般田地，随便来个什么都能让你万劫不复，你多么渴望真诚的另一个对你敞开心扉，因为你知道你的心会为之打开更大的门，你也知道那不可能，真的，你明明就在生活之中，却一直找不到生活，他们说，要那样那样，但你知道，你一定是这样，你只能这样，清凉的夏夜还在向你倾诉更久远的记忆，但你又不能靠着那时候活着，你为了不虚此行或是顺从本能的恐惧，悄然历了一番不痛不痒的情劫，你回头一看，春天来了，公园长椅来了走走了又来的游人，油画一般的紫罗兰从枯藤流下，其实你知道你只是想跨越语言，直到背后的意象，到物自体，到所谓本质，你知道你那么爱它，却把它放到最后，你也知道你不过是陷入一个个语境又出来，最后落入现实的语境而永世再出不来。\n","categories":["不言不载唯此玩心 · 文学","散文"],"tags":["散文","玉渊潭"]},{"title":"谈写作","url":"/2022/06/15/note/Literature/%E6%95%A3%E6%96%87/%E8%B0%88%E5%86%99%E4%BD%9C/","content":"写文章是一件难事。\n\n\n但看到报纸上、网络上、图书馆里不可记数的文章，又不禁怀疑这个观点，这些文章的作者会不会觉得写作是一件难事呢。高中时语文老师拿着只有三十多分的卷子，说我有写作障碍。我是不服气的。那时有幸窥见书中斑斓世界，不论是异乎于日常生活的传奇神话还是鞭辟入里的雄辩论证，都使我着迷不已，自然而然生出想写一写的想法。私下里早已挥笔驰骋，怎受得了这样的批评？于是暗自打气，安慰自己说是他们不懂，自命清高到要把所有怀才不遇的诗文都吟诵一遍。然而当自己把课堂上偷偷摸摸写下的小说给同学看，引来一阵耻笑的时候，又陷入了自我怀疑，难道我真的有写作障碍，难道我真的写得很烂？上学放学路上总有老人摆上一个书摊，悠然自得地与邻摊卖日用品的大妈谈笑风生，我在一旁挑挑拣拣，读到某些卖的很好的书，或是同龄人发表的文章，心中暗忿，这样的文章都能出版？同时又隐隐激动，我写得也许更好，那岂不是也能发表？回到家中满怀激情地偷偷投出一份稿件，然后就再也没了音讯。就这样，在不断地怀疑与肯定中，对写作的目的渐渐麻木，直到能享受于写作这件事本身。\n一直未受鼓励，因而难以坚持写下去，总有无数个时刻想要放弃，又有无数的瞬间重新燃起热情。读到川端康成早年也怀疑自己有写作障碍，以此安慰自己鼓励自己，想象每一个作家或者作者都会经历这样的境遇。其实并不奇怪，写文章通常是给人看，若没有奇思妙想或有趣故事，读者不会买帐，这就是说作者至少在某些方面高于读者，否则读者就不愿意读了，然而没有人生来就落在高处，必然是一步一步走上去的，那么在走到高处之前，都无法写出令读者满意的文章，自然就很难收到鼓励，没有鼓励就很难坚持走到那个地方，于是就都是在跟自己的较劲中艰难前行。\n最开始接触写这一件事是很小的时候了，还没开始上学妈妈就买了一本《唐诗三百首》，让我跟姐姐没事就背上几首——那真是无心插柳，今后的那么多年诗成了我生命中不可分割的重要部分，不得不说在某种程度上就是归功于那本《唐诗三百首》。但当时一首咏鹅费尽心思还难以理解，背了无数遍才能在脑中想象水中鹅的形象。夏天的一日，在平房上吹着风扇，突发奇想，来一首咏扇吧，“呼呼呼，风扇转呀转，……”，就是这样一团混乱的文字，让我产生一种奇异的感受，纸上铅笔歪歪扭扭组成的字句给我自己一种陌生的感觉，它们是出自我手，但我并不熟稔，也就是说它们并不属于我，而是独立于我之外的什么，我只是将它们组合和摆放，像楼下抽屉里的四驱车和奥特曼模型。这样第一次到文字世界做客的情景给我留下较好的印象，但往后的会面就没那么愉快了。\n上到小学三年级，语文要写作文了，最开始我是比较兴奋的，觉得可以大展身手，力压群雄。但听了课堂上老师讲的什么状物文，描景文，顿觉枯燥乏味，很快就对写作文失去了兴趣。然而作业还是要写，就去书店买一本作文大全，想看看别人怎么写，结果一下被迷住了，如饥似渴般的把别人的文章读了，轮到我写的时候，还是提笔在白纸面前凝神个把钟头，愣是一个字也挤不出，母亲看到我的苦相，前来帮忙解围。第二天老师在讲台上读我的作文，赞不绝口，我心虚异常，不敢告诉老师这其实是母亲帮忙写的，又害怕下次再有作文作业，我如何能独自完成。在这样的压力下，我自己摸出一条门道来，比如老师让写春天，我就到作文书上找几篇写春天的文章，自己把里面的句子摘出来，重新拼凑，组成一个新的文章，竟还能取得不错的效果。犹记得当时还拼凑出一篇模板式的文章，每逢考试都拿出来翻炒一阵，也不知那时候老师有没有闻到一股焦糊的味道。\n一日上语文课老师拿出一本小小的装帧精美的小册子，名字叫《小小作家》，她说这书里有许多美文，可以在写作文的时候用到，推荐我们都读一读，每个月交上十四块钱，就可以每周拿到一本，我自是知道她是在帮忙做广告，动机不纯，但听到她说本校有的同学的文章就在这上面发表时，我还是愿意购买了。到手之后，赶紧翻开，有看不懂的诗歌，也有平常的抒情美文，甚至还有妙趣横生的歇后语和笑话，于是我便幻想着自己也能写一些可以在其上发表的文章，几经尝试，仍然连作文作业和考试都难以应付，只能作罢，第一次成为作者的梦想就此破灭。\n到了初中，接触到更多更广的书，网络文学也在蓬勃生长。课堂上与老师斗智斗勇，桌兜里总藏着一部翻盖手机或破烂的大部书（这种书的命运就是在班上传来传去），老师走下讲台，就赶紧藏到里面，老师继续讲课，自己就继续看书，有时候难免沉醉其中，看得入迷了，老师走下来都没注意到，直到老师从身边走过才看到，吓得浑身一哆嗦，便是一直没看到老师倒也罢了，偏偏看到后吓了一跳让老师发觉不对劲，回身搜查桌子里面的秘密，于是上交手机，并扯出自己连接的线路，其实早有准备，不慌不忙地取出内存卡（里面储存着辛苦收集的小说），毕竟留得青山在，不怕没柴烧。这样畅游在别人创造的世界中，一直到高中读了一本名为《七夜雪》的武侠小说，才重新燃起想写一写的冲动。\n刚上高中还沉浸在物理定律下的秩序世界中，所怀抱负也是关于高维空间的幼稚想象，课余时间会读一些小说，《诛仙》、《斗罗大陆》、《第七天》等等。一日在家中读到《七夜雪》，被书中所描绘的漫天大雪中浪漫与残忍深深吸引，莫名地感到自己必须要写点什么了，类似于使命的内在冲动，无法抑制，那个从头到脚的战栗让我即刻开始动笔，然后再次被现实打了一巴掌。从未受到过真正的写作训练与教导，全凭想象和本能去书写，写完两千字回头看去，发现与第一次做饭的场景何其相似，只是把鸡蛋炒糊盐巴齁咸倒也算了，我是大火干烧把锅烧烂了。历时一年才从这个打击中走出来，为的是写文章赚钱，金钱的吸引力足以让我克服心理上的坎坷，于是发奋图强，课堂上，放学后，睡觉前，几乎无时无刻不在挤牙膏，甚至走在路上都在思考故事情节，上厕所都在一下下地码字。一次课堂上写小说还被老师发现，好在没有把本子撕碎，我至今感激她。最终出手两篇小说，各三万字左右，投到杂志社，编辑说文笔很棒，就是情节与我们的杂志风格不符。这让我又激动又失落，被拒稿是失落，第一次与编辑通信是激动，于是我满怀希望拿给同学看，得到了不含恶意耻笑，我再次陷入自我怀疑。从那时起，我便意识到，写作对于我来说根本不是一件要写给别人看的事情，而仅仅是不得不写，写了才能不那么痛苦的事情，这么告诉自己，一半是为自己写得不好开脱，一半是为写得不好却还一直写做解释。\n升入大学，有更多的时间阅读和写作， 但写作几乎没有成为一个需要我努力去做的事，一旦是这样，我就写不下去，常常是徘徊在“不得不写”和“无论如何都写不了”的情况，也就是说，单纯为了写作而产生的动力是驱使我写作的唯一力量。也曾羡慕那些说写就能写，技巧构思步步为营，每天努力写上多少字的人，他们似乎不需要外在的东西激起写作的强烈欲望，仅仅是把写作当作一件自然而然的寻常事情，像流水线工作一样毫无波澜。但我始终无法做到，似乎也永远无法做到，我只能在自己即将坠入虚无之时，用写作拉自己一把，在这层意义上，写得好坏，写作的难易，都并不重要。\n即使是写给自己看，如果没有读者观念，也难以让写作进行下去，自嗨式写作也得是自己真的能嗨起来。文章的宿命就是被读，无论是给别人读还是自己读，那么如何更轻松的写得更好就是必须要追求的，我个人没有办法，唯一的办法就是接受自己文章的烂，只有察觉到自己写得烂，才知道哪里需要改进，然后在文章放置一段时间变得陌生后，不断地修改与尝试，最终得到自己相对满意的文章。有时候也不得不承认写作有天赋的因素在，否则我也可以五岁咏鹅而非咏扇了，但不说写得多么出彩，至少写得让自己满意，还是可以通过努力达到的。\n　　\n","categories":["不言不载唯此玩心 · 文学","散文"],"tags":["散文","写作"]},{"title":"狭隙","url":"/2020/10/23/note/Literature/%E6%95%A3%E6%96%87/%E7%8B%AD%E9%9A%99/","content":"\n模仿木心写所作的一篇“散步体”散文，为更舒适地阅读，强行分段。\n\n那年秋季很短，总觉得秋天一年比一年短，走在知行道上，昨天还穿着小褂，今天行人就针织棉衫，丝绒毛呢了，乌桕叶子一半红一半绿，冬天已经到了，绿色的叶子叫道，我还没来得及红呐，几日来忙于赶路，我也是还没来得及享受这已凉未寒的舒爽，谁不是呢，但凡来得及的，是否来得及已无所谓了。\n\n\n这次受托去观辩论赛，便是无所谓的，路远，沿途野芳纤整优雅，轻快的心很快漂浮在晴冷的空气中，继而热和起来。在大街上张望，怎么一切都是立着的，栏杆，消防栓，垃圾桶，自行车，海棠树，高塔，楼宇，都站着，因此看到一簇躺着的花，欣然驻足而不再往前，自觉得这白嫩可人的花瓣，便是寻找已久的东方睡美人，细看去才发现叶片上趴着一个垂老的毛毛虫，不也是常常为一个人身上的某种特质吸引，产生与其相识的冲动，又因另一特质而放弃吗。\n我已熟知这座公园里的任一特质，常来散步，总会走到这里，路边长椅可供休憩片刻，对面是四象楼，十二层如按比例放大的浮屠，内里是一层比一层华贵的酒店，世上一切塔都是这样乏味的顶尖，即使出于习惯，看下去也是不期然而然的俯视，坐在长椅上，常常想如果没有旁人，便躺下来看，高塔就随之倒下来了，一层两层三层都一样高，那么还会有人挥洒千金住进顶层吗，当然不会，谁会住在倒了的屋子里，不会有任何人任何组织建造这样的楼，我当然也不会有失体面地躺在公园长椅上，仅是坐着就已经显得格格不入（人们在匆忙赶路）。\n而坐在辩论赛的观席上却是另外一回事了，凡表呈演绎，就必有舞台，舞台给人坐着看，也有站着的，穷乡僻壤的胶片电影，旧时红台大戏的替代品，村口先聚集个把人，随后大家都好像本来就知道一样全聚过来，都想看看白幕里的村民是怎样把鬼子全歼了的，不知谁请的放映者，也没人问，都不说话，时而一块儿大笑，那是鬼子出了洋相，村里人不怕脏的，小孩儿尤其不怕，但都站着，男人倚着电线杆，孩童三五成群，满目异彩，站着，似乎有种仪式感在里面，后来忆起儿时的二三事，恍然大悟，那是刚来时就被荧幕紧紧擢住，没来得及坐下，继而就不再觉得肉体有坐着的需求，直到电影结束，才在莫名余味中发觉僵麻的腿，心想下次一定要带个马扎来。\n但马扎哪有辩论赛的观席舒服，新时代信息爆炸，人人避之不及，成为观众就难免是被动，因而设计者的初衷让人不得不同情，柔软的深红色折椅，似乎坐着就是莫大荣幸，不由生出像观看莎士比亚戏剧一样的虔诚来，然而就这样坐着便好，辩论赛，毋须看，大学里的青年们，其鲜活的生命力已经盖过所有论点，还好是这样，“浪漫主义与现实主义哪个更好”，“人类是否会毁于科技”，明明是辩证法那样的无赖话术都难以折中的问题，何以为了两个无辜的极端争来争去……\n那年秋天，到友人家做客，堂中金裱，“结庐在人境，而无车马喧”，我是见过的，不觉得惊讶，友人的境界尚且不谈，开车三十分钟才能到的家是真够偏了，我惊讶的是，这堂皇的字画竟有一处错误，最后一句“欲辩已忘言”不知被哪位书法家篡改成了“欲辨已忘言”，踩了踩脚下的波斯华毯，似乎有什么真意显现出来，告与友人，他笑得筷子掉在了地上，我满脸羞色地回家，翻找史料，辨辨辨辨，全是“辨”，是我搞错了，清晰的记忆昭示错误的醒目，我转而疑惑，一千多年的流传，陶潜的本意已不可捉摸，错误也就不再是错误，那么两个辛字中间的狭隙就渐渐模糊，或许是太醉的缘故，被野菊诱惑了的缘故，陶潜自己未必清楚狭隙里到底是什么，台上激烈的争辩也因舞台中间的空白而隐隐远去。\n到底是什么，人总喜欢问到底，噫，还是我的谬误，要是都喜欢问到底，那就好了，那就坏了，那就再也没有比较出来的快乐了，然而人是这样的，商贩卖着包子，行人匆匆赶路，政治家精通修辞学……这些，都站在舞台两端，中间呢，空空荡荡，不知究竟，即使来个非要问到底的人，我也不会误认为他就是苏格拉底，至多是个总在黑暗中怜天下苍生的可怜人而已，一天天的，多少事，彻底消失在历史中，这样的消失是连“来过”的印记都没有留下的，像骰子一样，人被掷来掷去，是谁在掷，上帝说，“谁知道，管他呢”，反正颠来颠去就那几个数，偶有人落在两方阵营间的狭隙中，丝豪不自知地脱口而出，“物理定律是上帝的欲望”，哥白尼急忙噤声，他说天堂有一座花园，专供他这样的天使膳宿，这就对了，任何动物，前进时总有一只先迈出的脚，碰钉子撞铁板用的正是这只脚。\n都觉得现实是局限的，想象力是无穷的，古往今来竟没有人发现思想是被限制了的吗，来时一辆辆汽车从我身边飞过，司机一定觉得自己畅通无阻，路是无限的呀，那么我只需要轻轻迈出一步，踏进草坪，我就身在汽车所能飞驰的公路之外了，而纷杂概念与逻辑联系组成的思想就不是那么容易突破的，至多在封闭的莫比乌斯环中享受有限无边的另类自由，如果有人觊觎更大的自由，那么碰壁便是必然的宿命，碰壁的痛苦无法泯灭对“更大”的渴望时，挣扎就成为其生活的常态，对于这些落在狭隙里的人，活着，即是苦难。\n诚然是一句不该说却一定要说的废话，谁活着没有苦难，但将苦难视为寻常，将绝望当作信仰，就不是人人都可以接受了，台上告曰中场休息，胜利者觉得自己胜利了，煞有介事迎接欢呼，我提前离场，写下一则札记，“说服不了自己，就去死，人生实在简单的很”，何况那些纷纷乱乱的幸运的人，不用说就服的……\n街上照例是空旷，来时遇见的那簇花已经不见了，环卫工人拖着割草机，擦了擦汗，青草碎叶飞扬，耐过寒冷还不够，得耐过现代的机器才行，真是无奈啊，那么多伪命题，那么多自欺欺人，否则又能如何呢，整个人类历史归结为一句话，“无奈”，是的，更不必说无奈有时是欲奈而不知奈何的窘境了。\n路旁高楼林立，车列整齐画一，看似平静祥和，若说哪个屋里车里没有一团隐秘的狂热，我是不信的，但都被什么隔开了，比如迎面走来一个妇人，和我一样紧抿着嘴，看到我，我也看到了她，都像没看到一样，各自走开，我们之间被什么隔着，我远远跟着她，想弄明白这中间到底是什么。\n总是犯这样的错，以致错到最不敢错的佛门来了，她是来烧香的，野庙人少，香火却不少，祈求佛祖保佑健康，恳请菩萨引渡难关，所有人都想着极乐世界，那多恐怖，色即是空，岂不是在说极乐世界也是空，直到想起拜佛的人也许与佛并无关系，心里才稍稍安定，但仍免不了佛门之外的繁华风景，政治极权居高临下，拜金狂潮一波接着一波，除了看破红尘似乎也没有第三条路可走，岂非只能一直在越发乖绝的洪流中，为保身的一丝明哲踽踽前行，命既无可宿，何况那虚无的救赎。\n归途还很远，不知觉又走到这里，学校角落里的图书馆庄严肃穆，有知识殿堂的意味，一样东西的象征意义越凸显，其本身就越模糊，因而更偏爱西北角的湖，湖总是缄默，却也总有人觉得自己能闻其声，邻处小树林如世外仙境，秋风涌来，树叶飒飒作响，总想，成为一棵树，有鸟落身上，是浪漫过头了，才会有这样的想法，树不也是吗，洋洋洒洒，枯叶铺满地面，已辨不出哪里是小径，哪里是草坪，但我踩下去，就知道了，即使不是路，也会决然走下去，这当然是走错了，我一直是错，误以为高塔放倒才是人住的地方，误以为陶潜是不屑去辩才悠然忘言，误以为人们之间不该有那无形的隔层，因而把谙尽世事后的纯真看作高风亮节，把明知是假的东西当作信仰，以致把夹在夏与冬的狭隙里的秋天也视为知己而无所适从了，默然告别树林，天色已晚，我要结束这对意义的无尽思索了，只有忘却意义，意义才浮现出来，还是回去制造存在感，成就感，满足感吧，人除了感觉，还能有什么呢，彳亍在现实与幻象的狭隙之间，甜美也好，悲苦也罢，我是绝望的，好在绝望也是错，是这样一路错过来，也将一路错过去，我是这样的，我与世界的关系，是误解着的关系。\n","categories":["不言不载唯此玩心 · 文学","散文"],"tags":["散文","木心"]},{"title":"《感知，理知，自我认知》读书笔记","url":"/2023/06/11/note/Literature/%E9%98%85%E8%AF%BB/%E3%80%8A%E6%84%9F%E7%9F%A5%EF%BC%8C%E7%90%86%E7%9F%A5%EF%BC%8C%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","content":"\n摸到一块石头，就等于摸到了石头的本身，也即摸到了石头的存在。\n\n这里显然并未思考存在，而是把感知到等同于存在。想到之前所说，除了感知，世界一无所有，那么存在也许正是被包含在感知之中了，对应的，也有一些能感知到却并不存在的东西（也许以一种奇怪的形式存在），比如幻想一个世界上原本不存在的东西，那是将记忆中的许多东西打碎而后重新拼装，构造出的东西是曾经完全不存在的，那么在想到的那一刻，并未将其制造出实体，只是在脑中构想，它存不存在？以一种奇怪的形式，比如神经突触的排布或其他什么符号象征。\n必须要警惕的是，将科学的结论作为根基思考哲学问题将导致一种片面。\n\n\n\n你不看它它也在。\n\n这句话实质的意思是，你不看它的时候，别人可以看到，看到既证明了存在，因此不管你看不看，它都存在。这个观点的问题在于对于像外星人这种没有人可以看到的东西是否存在是无能解释的，这还不是最头疼的。如果有一样的东西，只要有人去看，就能看到，但从来没有人看过（是从来没有，也永远都没有），那么它存不存在？该如何区分这种看了就能看到（但人们并没有看或没有能力看）和看了也许看不到（既真的不存在）的东西。\n「对象的独立存在 vs 感知它它才存在」一节中讲到「有只狗熊扑过来，我闭上眼睛，狗熊就没了……这在物理上是相当困难的」，这无法说明对象是可以独立存在的，因为感知并非只有眼睛，闭上眼睛，狗熊扑过来，身上的触觉感受到狗熊，依然能证明狗熊的存在。因此问题的关键仍然是感知到等于存在，但感知不到的时候无法对是否存在下结论，因为它可能存在只是没有感知到（这意味只要感知就一定能感知到），也可能是不存在的（感知也感知不到）。是否可以以此作为存在的定义呢？既存在是只要感知就能感知到的东西，不存在是无论如何也感知不到的东西。\n此时会引出另一个问题，当除自己以外的其他人直接感知到一样东西，并告诉自己，那么可以不可以相信这样东西存在。这实际上是在说除了自己直接感知到事物，还有其他证明事物存在的方法吗。俗语“眼见为实，耳听为虚”，讲的是直接感知到的重要性，耳听为虚吗，听到的也是真真实实的声音呀，只是其中包含的信息可能是假的。人是不靠谱的。现代科学使用扫描电子显微镜，看到了物体微观的表面，信了，那是因为仪器被无数次实验证明它是靠谱的，再忠诚的人也会背叛，无生命的机器则永远不会。因此声称看到细菌看到原子的科学家们显然相信并以此证明细菌和原子的存在，那么是在说明非直接的感知也能证明存在吗？\n不妨看看使用显微镜的过程人们到底在做什么吧。当人们把一些细胞放到显微镜下观察的时候，人们看到的是“像”，也就是通过成像原理在镜头上反映出的一个虚假的图像，看到它等于看到细菌本身吗？看到细菌本身意味着什么呢？意味着存在。假设一个人在显微镜下看到了一个本来不应该出现的东西，他可能会怀疑是仪器坏了，检查完仪器发现它完好无损，他会去做实验或以其他的方式观察，最终的得出一个结论，确实存在一个新的东西或者只是镜头脏了等。至少，单纯看到，无法得出存在的结论，要去摸一摸，闻一闻或别的什么，等实在找不到方法证明它不存在了，才会得出它存在的结论。证明存在的方法就是找不到证明其不存在的方法。\n（未完）\n","categories":["不言不载唯此玩心 · 文学","阅读"],"tags":["读书","感知","理知","自我认知","笔记"]},{"title":"《我与地坛》读书笔记","url":"/2023/05/01/note/Literature/%E9%98%85%E8%AF%BB/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","content":"当人独身，总会觉得自己与某些非生命的东西有灵识上的联系，这种寂寞呀。\n\n\n想到那些有所名气的文人们，成名之前的互撕谩骂不少，但少见有批评这等“公认”的名家（如矛盾，老舍，史铁生，余华），似乎大众认定的作家一定是值得赞扬的，是事实如此，还是害怕因此而丢掉自己的名声。中学时看到所谓文坛，互相吹捧而一无是处的“大家”们，文人的悲哀与他们的悲哀混在一起，反倒显得没那么悲哀。\n\n“一个人，出生了，这就不再是一个可以辩论的问题，而只是上帝交给他的一个事实；上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。这样想过之后我安心多了，眼前的一切不再那么可怕。”\n\n生死之谜，各人有各人的答案，即使从未想过，交白卷也是有分的，史铁生在开头就真诚地道出了自己的答案，不敢说这是浅显的，自己所谓“活着的意义就是追求快乐”也不过是顺应了生物学本能，学科建立在人类文化之中，文化归属于人类自身，当这该死的环再次出现，我将撕掉卷子，擦擦手，扬长而去——上帝是不真诚的，我们的真诚只会让我们倍受其害。\n我们对自己的真诚会让我们得以解脱。\n一个地方如果没有别人，只有你自己，你会觉得那个地方独属于你。\n人对味道的记忆之深刻，让人恐怖，几十年前在某个地方闻到的一种气味，再次闻到，就一下神魂飘到那时候去了，也许那地方以及关于那地方的一切都已经忘得一干二净，但莫名心绪会永久性地与那些意象绑定，函数似的一触必发。\n\n“世上的事常常使上帝的居心变得可疑。”\n\n史铁生算是很有资格说这话的一类人。\n“活下去试试”，我又何尝不是呢，曾经写下三个活着的理由，一、人之本能，二、生时稀于死时，三、生活不易，比死有趣。是要这样，否则如何能说服自己，如何面对自己对死亡的恐惧，这种恐惧本身甚至都虚幻如烟，日常生活是难以近距离接触死亡的，即使接触，也至多是他人的死亡，接触自己的死亡？要是可以就好了。那么对死亡的思考除了在死亡的前一瞬间，都是浅薄的，可又不得不思考死亡，不思考就等于死亡本身，那么就必须有这样那样冠冕堂皇又清者自清的理由，好像真的是自己决定要活下去一样，不是命运，不是生物本能，是自己可以掌控自己，包括自己的生命。真是，要在上帝发笑之前自己先笑出来了。这自欺欺人真是好极了，至少让自己对死的怯懦有了归属，可以堂而皇之的活着。\n想到写过的一则诗，“一只金龟子撞着窗纱闯入我的领地&#x2F;尽管不愿也不忍却还是判了它的死刑&#x2F;反射微黄光泽的翅膀挣扎着跌入水中&#x2F;漩涡吞噬了小小的身躯就像它不曾存在过&#x2F;我不说但也可知这一幕其实是很多幕&#x2F;虚无中记忆中史书中到处是其惨艳的身影&#x2F;因而上帝存在时上帝也将为此苦恼&#x2F;难呀难呀难就难在任何生命的逝去&#x2F;大自然都不会感到丝毫的痛楚&#x2F;活着有什么可悲的活着唯一可悲的&#x2F;就是意识到活着的可悲”。\n再说一次，我们对自己的真诚会让我们得以解脱。\n直到发现小时候的无神论者和现在的泛神论者，且不信任何宗教的我，谈起生死句句离不开上帝，才意识到我对死亡所知之少，上帝已经成为未知和超越的代名词，那是以区区人类之躯，不可能够到的地方，那是时间的尽头，那是存在的反义词。\n“人类真正的名字叫欲望。”是的，中学在笔记本扉页写下“无欲则无敌”，当然是可笑的幼稚见解，但也是无可辩驳又无法做到的事实，伟大的先哲们都困顿于自身的欲望，即史铁生所谓的人类真正的名字，唯一的解脱是死，这是显而易见的，但这等同于“撕掉卷子”，是在否认世界的本源，佛门苦行僧追求把欲望降低到极致，以致鲜有痛苦与快乐，终生保持一副平常心，这是优秀的答案，但亦非满分。人类，可怜，不如不当人类——那便是放弃考试。更不如不曾出生，或生来即死——那是连备考都不屑。\n常常觉得无论如何也不会喜欢某本书，但又被其真诚打动。《我与地坛》是这样的。\n也许，活着本身就是活着的全部意义。\n\n要是今生遗憾太多，在背运的当儿，尤其在背运之后情绪渐渐平静了或麻木了，你独自待一会儿，抽支烟，不妨想一想来世。你不妨随心所欲地设想一下（甚至是设计一下）自己的来世。你不妨试试。在背运的时候，至少我觉得这不失为一剂良药——先可以安神，而后又可以振奋，就像输惯了的赌徒把屡屡的败绩置于脑后，输光了裤子也还是对下一局存着饱满的好奇和必赢的冲动。这没有什么不好。这有什么不好吗？无非是说迷信，好吧，你就迷信它一回。\n\n迷信的意思也许是着迷一般相信虚无或虚假的东西，比如想一想来世，觉得真的有来世，不妨现在去世，让来世成为现世，万一来世好的不得了呢？输了的赌徒总觉得下次能赢，再来一次吧。而史铁生的想来世只是想一想，获取精神上的慰藉，这局确实可能会输，但输了也还有下局呢，这样心安于输，到最后也不一定就输。烧香拜佛祈求保佑是把输赢寄希望于神明，这在结果上是迷信，过程上并非迷信，因为祈祷者得到了心灵的慰藉，那么无论输赢，在结果出来之前，心灵上不会遭受巨大的灾难。回首历史，神在物质上对人的帮助有待商榷，在精神上对人的帮助可谓彪炳千秋。\n一个绝顶幸运的人，从未经受过任何不幸的人，终究还是要面临死亡的，那么他的所有幸运可能会在死亡的时候转变为他的不幸——他如此幸福，却要在死亡中结束他的幸福，他越是幸福，死亡越是可怕，而死亡必然降临。那么永生呢，如果科技发展到可以保存人的意识，把将死之人的意识移植到机器上，永远的存活下去，这幸运会有转化成不幸的时候吗。那时人是什么，意义是什么，生命是什么等这些现在难以想通的问题会变得更加难以想通且面目全非吧。\n\n有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”\n\n这位大物理学家与我早年说过的一句话不谋而合：“物理学探索的绝非世界的本质，而是我们所能观察到的事物的运转规律。”这当然不是在说我与大物理学家有何关系，而是一个昭然而又绝望的事实是，我们无能于探究世界的本质，我们永远只能在我们人类自身的视角与这个世界交互，而不会看到表象之下的什么。这不是说人类能力有限，也不是上帝难以捉摸的想法，而是逻辑本身的限制。逻辑乃世上最坚不可摧的东西。甚至我们可以在探索世界本质的路上折戟后，可以大言不惭地说：找到了，世界的本质就是逻辑。\n看铁生所描绘的，人之出生是被抛过来的，出生之前你不存在，自然无可抛，他不想说哲学的问题，于是把问题丢给哲学家，而我想这个问题，第一反应是物质上的出生。（需要警惕唯物思想）\n于是，人性，在那时就已暴露：为了免遭惩罚，大家纷纷去效忠那一两个头领，阿谀，谄媚，惟比成年人来得直率。天下熙熙，皆为利来；天下攘攘，皆为利往。古来万事皆如此，权与利流来流去。总说政治是小孩子抢零食，因为它只是比小孩子多了层粉饰罢了。 \n读到史铁生将小时候的事，颇有感慨，往往是经历时有所感却从未立即记录下来，直到多年以后的某个时候，才重新回忆起来，写下文字，文字与真实的感受之间隔着远比年月更加久远的东西，读者，旁观者，经历者，截然不同又紧密联系的一件事。\n","categories":["不言不载唯此玩心 · 文学","阅读"],"tags":["读书","笔记","我与地坛"]},{"title":"游戏引擎架构设计学习","url":"/2025/05/30/note/Programming/CG/Architecture/","content":"Hazel Engine 没有使用分层式架构设计，多模块间的耦合相当严重，类之间的相互依赖也比较常见，这对分块编译和后续扩展提出了较大的挑战。\n持续思考一个尽可能简单又有效的架构设计，尽可能满足多Target分离，动态加载DLL，模块解耦。\n\n\nArchitecture\n纯抽象类 + Service Locator\n需要热更新则引入 C 函数字典\n\n模块间接口调用最核心的目标是将 编译器耦合 降低到最小，再用运行时注册或数据驱动将系统拼接起来。\n常见问题：\n\n不要在 Interface 头里暴露 STL 容器或自定义模板实例，因为一旦编译器版本不同 ABI 就崩溃。\n跨 DLL 抛异常，传递 std::string 都很危险，统一使用 POD 或 string_view。\nC API 虽丑但稳定，很多商业引擎（Unity NativePlugin、Godot GDNative）都依赖它实现长期兼容。\n如果模块间必须传复杂对象，可用 Serializer:: Write(Object*, Blob&amp;) 把状态打包，用 blob 交换。\n\nService Locator\n接口只在编译器出现，不让任何实现细节泄露；\n运行时把实时对象注册到一个全局的注册表（或显式传入）中；\n调用时通过接口指针完成功能调用（多态）。\n\n但在实现时需要注意一些坑：\n\n接口应该统一放在 Core 中还是各个子模块？\n\n最小原则：只有“跨模块要被别人用”的 API 才放到最低层。\n\n常见做法是：\n\n在 Core 目录里只放通用基类和 Service Locator；\n\n每个子系统再有自己的 Public 头，例如 Render&#x2F;Public&#x2F;IRender.h、Physics&#x2F;Public&#x2F;IPhysics.h。\n\n\n这样 Render 的实现（Render.dll &#x2F; libRender.a）位于更高层，但它的 接口头文件 可以像第三方 SDK 一样被任何人 include，而不会造成链接依赖。\n\n\n\n需要调用渲染的模块只依赖 IRender.h（接口），不会链接 Render 的实现；\nRender 若想回调 Physics，就只能依赖 IPhysics.h 或通过事件&#x2F;ECS 数据，避免形成编译环。\n\nPODPOD 是 “Plain Old Data” 的缩写，意指“像 C 语言那样朴素的数据类型”。在 C++ 语境中它有一套非常具体的标准定义，用来保证以下两件事 ︰\n\n内存布局可预测——字段按声明顺序顺排，不会插入 v-ptr、padding 不会被继承级别打乱；  \n拷贝 &#x2F; 反序列化 &#x2F; memcpy &#x2F; 跨 DLL 或跨语言传递 时不会触发构造、析构、虚函数等隐式行为，因而 ABI（应用二进制接口）稳定、安全。\n\n一、正式定义（C++11 之后）\nC++11 起标准把 “POD” 拆成两类 type traits，再用“二者皆满足”来等价于旧称 POD：\n• trivial type  \n\n默认构造、拷贝构造、移动构造、拷贝赋值、移动赋值、析构函数全部是 trivial（编译器隐式生成，且只是 bit-wise 拷贝 &#x2F; 释放）。• standard-layout type  \n没有虚函数或虚继承；  \n同一访问级别（public&#x2F;private&#x2F;protected）的非静态数据成员彼此在同一个类定义层次；  \n第一个非静态数据成员与结构体本身地址相同；  \n不是多继承等会导致额外 v-ptr 或调整指针的复杂继承结构。\n\n若一个类型同时满足 “trivial” 与 “standard-layout”，标准就把它视作 POD。std::is_pod&lt;T&gt;::value（已在 C++20 标准中弃用，推荐用 is_trivial &amp;&amp; is_standard_layout 自组合）。\n二、常见满足&#x2F;不满足例子\n满足（POD）:\nstruct Vec3 &#123; float x, y, z; &#125;;      // 仅含内建类型struct RGBA &#123; uint8_t r,g,b,a; &#125;;    // 简单像素struct Id   &#123; uint32_t value; &#125;;     // 句柄/索引\n\n不满足（非 POD）:\nstruct Foo &#123; std::string s; &#125;;       // 成员有非 PODstruct Bar &#123; virtual void f(); &#125;;    // 有虚函数struct Baz &#123; Baz()&#123;&#125; &#125;;              // 自定义构造函数(非 trivial)\n\n三、为什么跨模块 ／ 语言首选 POD\n\n可直接 memcpy、读文件、网络反序列化——不触发构造&#x2F;析构栈；  \nABI 在不同编译器版本、不同 DLL 间一致（只要基本对齐规则一致）；  \n与 C API、GPU 着色器常量缓冲 (Uniform Buffer) 或 SIMD 批处理结构天然对齐；  \n避免把 std::string、std::vector、虚函数表指针等 实现相关 信息暴露到接口层，降低升级和热更新风险。\n\n四、在游戏引擎中的用法示例\n// Public Interface 头文件（跨 DLL ）struct TransformHandle &#123; uint32_t index, generation; &#125;;   // POD 句柄struct TransformSOA &#123;     // SoA, hot-data    float x[256];    float y[256];    float z[256];&#125;;// Render、Physics 等子系统都可直接持有指针或 Offset 访问，// 客户端可以 `Serialize(binarystream, &amp;transform, sizeof(transform))`。\n\n\n跨 DLL 不要抛&#x2F;捕异常，也不要返回&#x2F;接收 STL 容器；  \n若需要复杂对象，可在模块内部保留指针，向外部只暴露 uint32_t handle；  \n若必须传非 POD（例如 std::string），可封装成 struct &#123; const char* data; uint32_t size; &#125; 这样的轻量 POD。\n\n简而言之，POD 是“没有隐藏行为、内存布局稳定”的数据结构，在模块边界、网络、磁盘、GPU 乃至脚本绑定等场景都极其安全、易维护，是现代游戏引擎接口层的首选交换格式。\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic"]},{"title":"Camera","url":"/2025/06/07/note/Programming/CG/Camera/","content":"Camera designing.\n\n\n万向节死锁概念使用欧拉角：\n\n你可以绕X轴旋转（前后翻转）\n可以绕Y轴旋转（左右翻转）\n可以绕Z轴旋转（平面旋转）\n\n必须先确定旋转顺序，因为每个轴的旋转会基于上一轴旋转后新的轴的方向旋转，旋转顺序不同，结果也是不同的。\n当一个旋转轴旋转90°之后，另外两个轴重合在了一起，另外两个轴的旋转变成了相同的动作，这样就失去了一个自由度的旋转能力。\n比如先绕X轴旋转90度，此时左右翻转与水平旋转变成了一样的动作。\n为什么欧拉角旋转顺序必须是确定的？因为如果不确定，就无法通过简单的3个旋转角来唯一确定一个变换。\n比如（20，50，30），按照正常的欧拉角，可以按照x-y-z的顺序旋转，但如果不按照正常的顺序，可以拆分成两次变换（10，50，30）+（10，0，0），即旋转顺序为x-y-z-x，这样变换出来的结果与之前不同，但总体上仍然是（20，50，30）。因此必须确定旋转顺序，然后才能唯一确定一个变换。\n四元数","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic"]},{"title":"多Pass渲染","url":"/2025/05/30/note/Programming/CG/RenderPass/","content":"多 pass 渲染就像制作一部电影的后期制作流程，每一步都专门处理一种效果，最后合成最终画面。\n每个 pass 专注一种效果，互不干扰：阴影 pass 只关心深度；几何 pass 只关心基础着色；后处理 pass 只关心特效。\n\n\nDepthTest让我详细解释深度缓冲相关的概念和在渲染管线中的作用：\n核心概念深度缓冲区 (Depth Buffer&#x2F;Z-Buffer)\n一个与颜色缓冲区同样大小的缓冲区\n每个像素存储一个深度值（通常是0.0到1.0的浮点数）\n0.0 &#x3D; 最近距离（相机近平面）\n1.0 &#x3D; 最远距离（相机远平面）\n\n深度写入 (Depth Write)pipelineSpec.DepthWrite = true;   // 启用深度写入pipelineSpec.DepthWrite = false;  // 禁用深度写入\n\n启用时：片段着色器执行完成后，将计算出的深度值写入深度缓冲区\n禁用时：不写入深度值，深度缓冲区保持不变\n用途：预深度渲染中，只有预深度通道写入，几何体通道只读取\n\n深度测试 (Depth Test)pipelineSpec.DepthTest = true;   // 启用深度测试pipelineSpec.DepthTest = false;  // 禁用深度测试（如天空盒）\n\n启用时：根据深度测试函数比较当前片段深度值与深度缓冲区中的值\n禁用时：所有片段都会被渲染，无论深度如何\n\n深度测试函数 (Depth Compare Function)enum class DepthCompareOperator&#123;    Never,          // 永远不通过 (不渲染任何东西)    Less,           // 当前深度 &lt; 缓冲区深度时通过    LessOrEqual,    // 当前深度 &lt;= 缓冲区深度时通过      Equal,          // 当前深度 == 缓冲区深度时通过    GreaterOrEqual, // 当前深度 &gt;= 缓冲区深度时通过    Greater,        // 当前深度 &gt; 缓冲区深度时通过    NotEqual,       // 当前深度 != 缓冲区深度时通过    Always,         // 永远通过 (等同于禁用深度测试)&#125;;\n\n渲染管线中的位置完整的渲染管线流程顶点数据    ↓┌─────────────────┐│   顶点着色器      │ ← 计算顶点位置、变换到裁剪空间└─────────────────┘    ↓┌─────────────────┐│   图元装配        │ ← 组装三角形└─────────────────┘    ↓┌─────────────────┐│   光栅化         │ ← 生成像素片段，计算深度值└─────────────────┘    ↓┌─────────────────┐│  Early-Z 测试    │ ← **深度测试在这里！**(可选)└─────────────────┘    ↓┌─────────────────┐│   片段着色器      │ ← 计算像素颜色└─────────────────┘    ↓┌─────────────────┐│  Late-Z 测试     │ ← **深度测试在这里！**(如果没有Early-Z)└─────────────────┘    ↓┌─────────────────┐│   深度写入        │ ← **深度写入在这里！**└─────────────────┘    ↓┌─────────────────┐│   颜色混合      │ ← 与帧缓冲区混合└─────────────────┘    ↓┌─────────────────┐│   帧缓冲区      │ ← 最终输出└─────────────────┘\n\n深度测试的执行位置Early-Z 测试 (提前深度测试)\n位置：片段着色器之前\n条件：\n片段着色器不修改深度值\n不使用 discard 指令\n不使用Alpha测试\n\n\n优势：剔除被遮挡的片段，避免昂贵的片段着色器计算\n\nLate-Z 测试 (延迟深度测试)\n位置：片段着色器之后\n条件：当不满足Early-Z条件时\n劣势：片段着色器已经执行，无法节省计算\n\n深度测试的具体执行过程// 伪代码展示深度测试过程for (每个像素片段) &#123;    float currentDepth = 片段的深度值;    float bufferDepth = depthBuffer[x][y];  // 深度缓冲区中的值        bool testResult = false;    switch (depthCompareOperator) &#123;        case Less:            testResult = (currentDepth &lt; bufferDepth);            break;        case LessOrEqual:            testResult = (currentDepth &lt;= bufferDepth);            break;        case Equal:            testResult = (currentDepth == bufferDepth);            break;        // ... 其他比较函数    &#125;        if (testResult) &#123;        // 深度测试通过        执行片段着色器();  // 或者已经执行了(Late-Z情况)                if (depthWrite) &#123;            depthBuffer[x][y] = currentDepth;  // 写入新的深度值        &#125;                写入颜色到帧缓冲区();    &#125; else &#123;        // 深度测试失败，丢弃该片段        丢弃片段();    &#125;&#125;\n\n预深度渲染的深度测试流程第一步：预深度通道// 深度缓冲区初始状态：全部为 1.0 (最远)depthBuffer[所有像素] = 1.0f;// 渲染鸭子模型DepthOperator = LessOrEqual;  // 小于等于时通过DepthWrite = true;            // 启用深度写入for (鸭子的每个片段) &#123;    float duckDepth = 0.6f;  // 假设鸭子在这个深度        if (duckDepth &lt;= 1.0f) &#123;  // 0.6 &lt;= 1.0，测试通过        // 只执行简单的预深度着色器（不计算颜色）        depthBuffer[x][y] = 0.6f;  // 写入鸭子的深度    &#125;&#125;\n\n第二步：几何体通道// 深度缓冲区现在存储着鸭子的深度值 0.6f// 现在渲染完整的鸭子（带材质、光照等）DepthOperator = LessOrEqual;  // 小于等于时通过DepthWrite = false;           // 禁用深度写入for (鸭子的每个片段) &#123;    float duckDepth = 0.6f;  // 相同的几何体，相同的深度        if (duckDepth &lt;= 0.6f) &#123;  // 0.6 &lt;= 0.6，测试通过        执行完整的PBR片段着色器();  // 计算最终颜色        // 不写入深度值（保持预深度的结果）        写入颜色到帧缓冲区();    &#125;&#125;\n\n为什么预深度渲染能提高性能？传统渲染：渲染所有物体 → 执行昂贵的片段着色器 → 深度测试 → 丢弃被遮挡的片段\n问题：被遮挡的片段浪费了片段着色器的计算\n预深度渲染：预深度通道 → 建立深度缓冲区 → 几何体通道 → Early-Z剔除大部分片段 → 只对可见片段执行昂贵的着色器\n优势：昂贵的片段着色器只在必要时执行\nShadowMap阴影贴图，通过深度信息来判断物体距离光源的前后遮挡关系，\nShadowMapPass();   // 阴影贴图SpotShadowMapPass(); // 手电筒阴影贴图\n\n层级阴影贴图传统的阴影贴图使用单一的深度纹理来存储整个场景的阴影信息，但会遇到以下问题：\n\n近处阴影质量差：由于一张贴图要覆盖整个场景，近处物体分配到的像素很少\n远处浪费精度：远处不重要的区域却占用了大量贴图空间\n透视混叠：在视角变化时会出现明显的阴影锯齿\n\nCSM将相机的视锥体（viewing frustum）分割成多个层级，每个层级使用独立的阴影贴图：\n\n分层渲染：\n\n\n第1层：覆盖相机附近0-50米，使用高精度阴影\n第2层：覆盖50-200米，使用中等精度\n第3层：覆盖200-800米，使用较低精度\n第4层：覆盖800米以上，使用最低精度\n\n\n动态调整：\n\n\n根据相机位置动态调整每层的覆盖范围\n近处获得更多的阴影细节\n远处保持基本的阴影效果\n\n\n平滑过渡：\n\n\n在层级边界处进行混合，避免突兀的质量跳跃\n使用淡入淡出效果\n\nPreDepth\n预深度：确定哪些像素是可见的，先画一遍，只记录深度，不进行着色。\n\n目的： 解决传统绘制重复渲染的问题， 比如一个像素的位置上，先绘制了远处的山，再绘制近处的树，这样远处的山的着色计算就浪费了。\n解决方案： 第一遍，只记录深度信息，确定每个像素最终显示哪个物体；后续只给真正可见的像素上色。\nvoid SceneRenderer::Init()&#123;    // 创建预深度的帧缓冲    FramebufferSpecification preDepthFramebufferSpec;    preDepthFramebufferSpec.Width = m_Specification.ViewportWidth;    preDepthFramebufferSpec.Height = m_Specification.ViewportHeight;    preDepthFramebufferSpec.DebugName = &quot;PreDepth-Opaque&quot;;        // 关键：只需要深度缓冲，不需要颜色缓冲    preDepthFramebufferSpec.Attachments = &#123; ImageFormat::DEPTH32FSTENCIL8UINT &#125;;    preDepthFramebufferSpec.DepthClearValue = 0.0f;  // 使用反向Z，远处是0，近处是1        // 创建两个版本：一个清除深度，一个保持深度    Ref&lt;Framebuffer&gt; clearFramebuffer = Framebuffer::Create(preDepthFramebufferSpec);    preDepthFramebufferSpec.ClearDepthOnLoad = false;    Ref&lt;Framebuffer&gt; loadFramebuffer = Framebuffer::Create(preDepthFramebufferSpec);&#125;\n\n预深度管线：\n// 静态物体的预深度管线PipelineSpecification pipelineSpec;pipelineSpec.DebugName = &quot;PreDepth-Opaque&quot;;pipelineSpec.TargetFramebuffer = clearFramebuffer;pipelineSpec.Shader = Renderer::GetShaderLibrary()-&gt;Get(&quot;PreDepth&quot;);  // 简单的深度着色器pipelineSpec.Layout = vertexLayout;pipelineSpec.InstanceLayout = instanceLayout;m_PreDepthPipeline = Pipeline::Create(pipelineSpec);// 动画物体的预深度管线pipelineSpec.DebugName = &quot;PreDepth-Anim&quot;;pipelineSpec.Shader = Renderer::GetShaderLibrary()-&gt;Get(&quot;PreDepth_Anim&quot;);pipelineSpec.BoneInfluenceLayout = boneInfluenceLayout;  // 支持骨骼动画m_PreDepthPipelineAnim = Pipeline::Create(pipelineSpec);\n\n预深度渲染：\nvoid SceneRenderer::PreDepthPass()&#123;    uint32_t frameIndex = Renderer::GetCurrentFrameIndex();        // 开始性能计时    m_GPUTimeQueries.DepthPrePassQuery = m_CommandBuffer-&gt;BeginTimestampQuery();        // 开始预深度渲染（静态物体）    Renderer::BeginRenderPass(m_CommandBuffer, m_PreDepthPass);        // 渲染所有静态网格，但只写入深度    for (auto&amp; [mk, dc] : m_StaticMeshDrawList)    &#123;        const auto&amp; transformData = m_MeshTransformMap.at(mk);        // 关键：使用预深度材质，只计算深度        Renderer::RenderStaticMeshWithMaterial(            m_CommandBuffer,             m_PreDepthPipeline,             dc.StaticMesh,             dc.MeshSource,             dc.SubmeshIndex,             m_SubmeshTransformBuffers[frameIndex].Buffer,             transformData.TransformOffset,             dc.InstanceCount,             m_PreDepthMaterial  // 简单的深度材质        );    &#125;        // 渲染动态物体（非骨骼动画）    for (auto&amp; [mk, dc] : m_DrawList)    &#123;        const auto&amp; transformData = m_MeshTransformMap.at(mk);        if (!dc.IsRigged)  // 非骨骼动画物体            Renderer::RenderMeshWithMaterial(..., m_PreDepthMaterial);    &#125;        Renderer::EndRenderPass(m_CommandBuffer);        // 处理骨骼动画物体    Renderer::BeginRenderPass(m_CommandBuffer, m_PreDepthAnimPass);    for (auto&amp; [mk, dc] : m_DrawList)    &#123;        if (dc.IsRigged)  // 骨骼动画物体        &#123;            const auto&amp; boneTransformsData = m_MeshBoneTransformsMap.at(mk);            Renderer::RenderMeshWithMaterial(                m_CommandBuffer,                m_PreDepthPipelineAnim,  // 支持骨骼动画的管线                dc.Mesh,                dc.MeshSource,                dc.SubmeshIndex,                m_SubmeshTransformBuffers[frameIndex].Buffer,                transformData.TransformOffset,                boneTransformsData.BoneTransformsBaseIndex,  // 骨骼变换数据                boneTransformsData.BoneTransformsStride,                dc.InstanceCount,                m_PreDepthMaterial            );        &#125;    &#125;    Renderer::EndRenderPass(m_CommandBuffer);        m_CommandBuffer-&gt;EndTimestampQuery(m_GPUTimeQueries.DepthPrePassQuery);&#125;\n\n预深度 Early-Z 优化：\n// 在几何Pass中，深度测试设置变为：pipelineSpecification.DepthOperator = DepthCompareOperator::Equal;  // 只处理深度相等的像素pipelineSpecification.DepthWrite = false;  // 不再写入深度，只读取// 这意味着：// - 如果像素深度不等于预深度的结果 → 直接丢弃，不执行片段着色器// - 只有深度完全匹配的像素才会执行复杂的光照计算\n\n也就是说，预深度 Pass 会写一张帧缓冲，此缓冲只有深度信息，即最前面的（需要被着色的）物体的深度信息，计算着色时，将物体的深度值与预深度贴图对应的深度值进行匹配，如果匹配成功，则进行着色，匹配失败，跳过着色。\n预深度 Pass 的核心思想就是用少量的计算（只算深度）换取大量的节省（避免无效的复杂光照计算），这在复杂场景中效果非常明显，特别是有很多重叠物体的情况下。\n精度问题由于预深度要将场景中的所有物体先渲染一边深度，然后在几何pass使用此深度输出，因此必须保证两次渲染的一致性，尤其是在着色器中计算gl_Position时。\n在顶点着色器中，标记precise invariant gl_Position;来使用精度限定符，否则会出现一下情况，渲染时深度测试不稳定。\n\n这个 precise invariant 声明确保：\n\nprecise：使用高精度浮点运算\ninvariant：保证相同输入产生完全相同的输出\n\ninvariant vs precise invariant 的区别：\n**invariant gl_Position;**：\n\n只保证相同输入产生相同输出\n但允许编译器进行优化重排序\n可能导致不同着色器间的微小差异\n\n\n**precise invariant gl_Position;**：\n\n**precise**：禁止编译器重排序和某些优化\n**invariant**：保证跨着色器的一致性\n确保完全相同的计算顺序和精度\n\n\n\nReversed-Z最初由Brano Kemen在2012年提出，现在已被广泛应用于现代游戏引擎和渲染器中，包括Unreal Engine 4&#x2F;5、Unity等。\n传统的Z缓冲使用标准透视投影矩阵，将深度值从[near, far]映射到[0, 1]。由于IEEE 754浮点数的非线性分布特性，精度主要集中在接近0的区域，而远离相机的物体精度较低。\n传统Z映射: [near, far] → [0, 1]- 近平面 (near) → 0.0- 远平面 (far)  → 1.0\n\n当两个面非常接近时，由于精度不足，深度测试可能产生不一致的结果，导致Z-Fighting闪烁现象。这在远距离渲染中尤为明显。\n对于典型的相机设置（near&#x3D;0.1, far&#x3D;1000）：\n\n50%的精度集中在[0.1, 0.2]范围内\n仅有很少的精度分配给[100, 1000]范围\n远距离物体几乎没有可用精度\n\n反向Z通过将深度映射反转，使得：\n反向Z映射: [near, far] → [1, 0]- 近平面 (near) → 1.0- 远平面 (far)  → 0.0\n\n由于浮点数在接近1.0时具有更高的精度，反向Z能够：\n\n提高近距离精度：大部分渲染内容位于相机附近，获得更好的精度分配\n改善远距离表现：远距离物体也能获得足够的精度\n减少Z-Fighting：整体精度提升显著减少深度冲突\n\n标准的透视投影矩阵为：\nP_standard = [    [2n/(r-l),    0,      (r+l)/(r-l),         0    ]    [   0,     2n/(t-b),  (t+b)/(t-b),         0    ]    [   0,        0,      -(f+n)/(f-n),  -2fn/(f-n) ]    [   0,        0,           -1,              0   ]]\n\n其中：\n\nn &#x3D; near平面距离\nf &#x3D; far平面距离\nl,r,t,b &#x3D; 视锥体边界\n\n反向Z投影矩阵推导要实现反向Z映射，需要修改标准矩阵的第3行：\n目标变换：\n\n原始：z ∈ [n, f] → z_ndc ∈ [-1, 1] → z_depth ∈ [0, 1]\n反向：z ∈ [n, f] → z_ndc ∈ [1, -1] → z_depth ∈ [1, 0]\n\n修改的矩阵元素：\n// 标准投影矩阵的[2][2]和[3][2]元素P_standard[2][2] = -(f+n)/(f-n)P_standard[3][2] = -2fn/(f-n)// 反向Z投影矩阵的对应元素P_reversed[2][2] = -n/(f-n)           // 修改后P_reversed[3][2] = fn/(f-n)           // 修改后\n\n反向Z的一个额外优势是天然支持无限远平面：\n// 当 f → ∞ 时P_reversed[2][2] = 0P_reversed[3][2] = n\n\n实现实例相机中的投影矩阵生成反向z的矩阵：\nvoid PerspectiveCamera::UpdateProjectionMatrix()&#123;    // 生成标准投影矩阵    m_Data.UnReversedDepthProjectionMatrix =         glm::perspectiveFov(glm::radians(m_Data.FOV),                            (float)m_Data.Width,                            (float)m_Data.Height,                            m_Data.NearClip,                            m_Data.FarClip);        // 复制为反向Z矩阵    m_Data.ProjectionMatrix = m_Data.UnReversedDepthProjectionMatrix;        // 修改Z映射：[near,far] → [0,1] 变为 [near,far] → [1,0]    m_Data.ProjectionMatrix[2][2] = -m_Data.NearClip / (m_Data.FarClip - m_Data.NearClip);    m_Data.ProjectionMatrix[3][2] = (m_Data.FarClip * m_Data.NearClip) / (m_Data.FarClip - m_Data.NearClip);&#125;\n\n深度Pass的深度清除值为0.0f.\n深度测试函数改为GreaterOrEqual。\n其他不变。\nHZB（Hierarchical Z Buffer）HZB 的核心思想是用 空间换时间：预先计算好多个分辨率的深度信息，让后续的遮挡查询、光线追踪等操作能够快速跳过大块的空白区域，大幅提升渲染效率。\n绘制不同比例的深度图，这是查询一个物体是否被遮挡时，可以先根据物体的大小选择合适的 mip 级别，查询该区域的最远深度与物体的最近深度进行对比，如果物体的最近深度比该区域的最远深度大，说明物体被完全遮挡，否则使用更精细的 mip 进一步检查。\n// 有一座大山（占屏幕400x300像素）挡在前面// 山后面有一座小房子，我们要判断房子是否可见// 传统方法：检查房子覆盖的每个像素（可能几万个像素）// HZB方法：int mipLevel = log2(400) = 8;  // 选择第8级mipfloat mountainDepth = SampleHZB(mountainCenter, 8);  // 只需要1次纹理采样！if (houseDepth &gt; mountainDepth)     skipRendering(house);  // 直接跳过房子的渲染\n\nHZB 的核心思想就是分而治之：\n\n大区域用粗糙的信息快速判断\n小区域用精细的信息准确判断\n根据需要动态选择精度级别\n\n这样既保证了准确性，又大幅提升了性能。就像你看地图时，先看全国地图找到大概方向，再看省级地图，最后看详细街道图一样。\nPreIntergration想象你要在一面湖水中看倒影，但湖面有波纹：\n\n传统方法：从每个角度都重新计算光线如何在波纹表面反射\n预积分方法：预先计算好不同粗糙度表面的 “平均反射效果”，需要时直接查表\n\nSSR(Screen Square Reflection)传统反射渲染从镜子的角度将场景渲染一遍，性能消耗翻倍，每个镜子都要这么做，场景渲染次数一直增加。\n屏幕空间反射： 利用已经渲染的场景（所有像素的颜色和深度），对于需要反射的表面，计算反射光方向，沿着反射方向在已渲染的图像中查找对应的颜色，如果找到就作为反射的颜色，如果没找到，就显示天空的颜色。\nSSR 的局限性，如果需要计算反射的像素在屏幕空间外，则无法拿到，需要用一些策略缓解：\n\n智能 Fallback - 在 SSR 失效时平滑过渡到其他技术\n扩展数据 - 渲染比显示更多的区域\n时域复用 - 利用前几帧的信息\n分层策略 - 重要的反射用高端技术，次要的用简单方法\n预计算置信度 - 提前知道哪里 SSR 会失效\n\nLight Culling传统光照的性能灾难：如果场景中有一千盏灯，即使你无法看到所有的灯，也会计算这一千盏灯对场景的影响。\n问题的本质：\n（1）距离衰减： 现实中 光照的强度 = 光源强度 / （距离的平方），距离 50m 时，强度 = 100 / (50²) = 0.04，基本上看不出来了，但传统方法还是会计算这个量\n（2）屏幕空间局限性： 一个像素实际上只会收到附近几盏灯的影响\n光照剔除的基本原理核心思想： 分块处理，将屏幕切成小格子，每个格子只关心影响到它的灯光。\n两阶段处理：\n\n光照剔除：着色器中，先确定当前工作组负责的屏幕块，计算这个块在世界空间中的范围，构建该块的 Frustum，测试每盏灯是否与其相交，将测试结果写入全局缓冲区；\n像素着色：在像素着色器中，先确定当前像素属于哪个块，获取该块的灯光列表，只计算列表中灯光的贡献。\n\n\n屏幕空间块到世界空间有一个转换，即通过近平面的范围，构建一个视锥体，该视锥体内的灯光才影响此屏幕空间块的着色。\n\n深度范围的计算方法float CalculateTileDepthRange(ivec2 tileID)&#123;    float minDepth = 1000.0;  // 很远    float maxDepth = 0.0;     // 很近（反向Z）        // 遍历该块中所有像素的深度    for (int y = 0; y &lt; 16; y++)    &#123;        for (int x = 0; x &lt; 16; x++)        &#123;            ivec2 pixelCoord = tileID * 16 + ivec2(x, y);            float pixelDepth = SampleDepthBuffer(pixelCoord);                        minDepth = min(minDepth, pixelDepth);  // 最近的物体            maxDepth = max(maxDepth, pixelDepth);  // 最远的物体        &#125;    &#125;        return TileDepthRange(minDepth, maxDepth);&#125;// 优化版本：使用HZB加速float CalculateTileDepthRangeOptimized(ivec2 tileID)&#123;    // 直接从HZB的对应mip级别读取    // 16x16块对应HZB的某个mip级别    int mipLevel = CalculateMipForTileSize(16);    vec2 hzbUV = (tileID + 0.5) / numTiles;        float blockDepth = textureLod(HZBTexture, hzbUV, mipLevel).r;    return blockDepth;  // HZB已经包含了该区域的深度信息&#125;\n\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic"]},{"title":"渲染相关概念","url":"/2025/06/05/note/Programming/CG/Renderer/","content":"PBR rendering.\n\n\nPBR(Physically Based Rendering)\n微表面理论（Microfacet Theory）graph TD\n    A[微表面理论] --> B[宏观表面]\n    A --> C[微观表面]\n    B --> D[我们看到的平滑表面]\n    C --> E[实际的粗糙微表面]\n    E --> F[镜面反射]\n    E --> G[漫反射]\n    F --> H[直接反射光线]\n    G --> I[多次反射后散射]\n\n微表面理论是PBR的基础，它认为：\n\n任何表面在微观尺度下都由微小的镜面构成\n这些微表面的朝向分布决定了材质的粗糙度\n粗糙度越高，微表面朝向越混乱，反射越分散\n粗糙度越低，微表面朝向越一致，反射越集中\n\n\nBRDF方程（双向反射分布函数）\n\nPBR中使用的Cook-Torrance BRDF方程：\nf(l,v) = kd * f散射 + ks * f镜面f镜面 = (D * F * G) / (4 * (n·v) * (n·l))\n\n其中：\n\nD (Distribution) - 法线分布函数\nF (Fresnel) - 菲涅尔方程\nG (Geometry) - 几何遮蔽函数\nkd - 漫反射系数\nks - 镜面反射系数\nn - 法线向量\nv - 视线向量\nl - 光线向量\n\n\n各项函数详解\n\na) **法线分布函数(D)**：\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)&#123;    float a = roughness * roughness;    float a2 = a * a;    float NdotH = max(dot(N, H), 0.0);    float NdotH2 = NdotH * NdotH;    float nom   = a2;    float denom = (NdotH2 * (a2 - 1.0) + 1.0);    denom = PI * denom * denom;    return nom / denom;&#125;\n\n描述微表面法线的统计分布\n粗糙度越高，分布越分散\n粗糙度越低，分布越集中\n\nb) **菲涅尔方程(F)**：\nvec3 fresnelSchlick(float cosTheta, vec3 F0)&#123;    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);&#125;\n\n描述不同观察角度的反射率变化\nF0是0度角时的反射率\n掠射角时反射率接近1\n金属的F0值较高，非金属较低\n\nc) **几何函数(G)**：\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)&#123;    float NdotV = max(dot(N, V), 0.0);    float NdotL = max(dot(N, L), 0.0);    float ggx2 = GeometrySchlickGGX(NdotV, roughness);    float ggx1 = GeometrySchlickGGX(NdotL, roughness);    return ggx1 * ggx2;&#125;\n\n处理微表面之间的遮蔽和阴影\n考虑光线和视线被微表面遮挡的情况\n粗糙度越高，遮蔽越明显\n\n\n能量守恒\n\nPBR严格遵循能量守恒定律：\nvec3 kS = F;           // 镜面反射比例vec3 kD = 1.0 - kS;    // 漫反射比例kD *= 1.0 - metallic;  // 金属不产生漫反射\n\n反射光能量永远不会超过入射光\n金属材质几乎没有漫反射\n非金属材质同时具有漫反射和镜面反射\n\n\n线性空间和Gamma校正\n\nPBR在线性空间进行计算：\n// HDR色调映射finalColor = finalColor / (finalColor + vec3(1.0));// Gamma校正finalColor = pow(finalColor, vec3(1.0/2.2));\n\n所有计算在线性空间进行\n最后应用色调映射处理HDR\n输出前进行Gamma校正\n\n\n材质参数的物理含义\n\n\nMetallic（金属度）：\n\n0.0 &#x3D; 非金属（绝缘体）\n1.0 &#x3D; 纯金属\n很少使用中间值\n\n\nRoughness（粗糙度）：\n\n0.0 &#x3D; 完全光滑（镜面）\n1.0 &#x3D; 完全粗糙（漫反射）\n影响微表面分布\n\n\nAlbedo（基础色）：\n\n非金属：表面颜色\n金属：F0反射率\n\n\n\n\nIBL（基于图像的光照）\n\n完整的PBR通常还需要：\n\n漫反射辐照度图\n预过滤环境贴图\nBRDF积分贴图\n\nPBR Shaderlayout(push_constant) uniform Material&#123;    vec3  AlbedoColor;    float Metalness;    float Roughness;    float Emission;    float EnvMapRotation;    bool UseNormalMap;&#125;u_MaterialUniforms;\n\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic"]},{"title":"Vulkan基本概念","url":"/2025/02/21/note/Programming/CG/Vulkan/","content":"Vulkan的一些基本概念。\n\n\n基本概念InstanceApp与vulkan之间的桥梁，创建一个Instance即创建一个vulkan对象，之后才可以进行更多操作。\nPhysical Device物理设备，通常来说是一个显卡（GPU），也可以是其他设备，如NPU、DSP等。\nDevice相当于一个在App中的physical device实例，App可以创建多个Device与物理设备交互和管理资源；类比OpenGL，相等于Context。\nQueueFamily每一个物理设备的功能不同，如显卡有计算和图形渲染功能，而NPU只能计算，DSP可以解码，这些功能都由物理设备的QueueFamily体现，每一种功能对应一种QueueFamily。\nApp与vulkan交互的逻辑就是，通过QueueFamily创建处对应的Queue，然后将Command推入Queue中，vulkan会把这些command交给设备进行处理。\nQueueQueue是vulkan很重要的概念，可以理解为App与设备之间通信的队列。\n每种Queue可以接受不同的Command，取决于它属于哪一个QueueFamily。\n在创建Queue时，指定对应的family的index，便可以创建属于该family的Queue。\nImage、Buffer都属于内存空间对象。不同的是Image表示特定用途的对象，如颜色缓冲，纹理，深度等。Buffer仅仅代表原始数据缓存。\nMemory一块内存。可以是CPU内存，也可以是GPU内存（显存）。创建一个Buffer或Image这样的内存对象，必须给他们分配内存，即Memory。\nImageViewImage具有明确的用途，需要让vulkan知道如何使用Image。\n因此要告诉vulkan这个Image的类型格式等属性，ImageView用以描述这些属性，vulkan不会直接操作Image，而是通过ImageView对象来操作Iamge。\nCommandBuffer命令缓冲，\nCommandPool用来分配CommandBuffer。由于每一个Queue支持的Command不同（用途不同），在创建对应Queue的CommandPool时，也应该指定与创建Queue时一样的QueueFamily的Index。\nPipeline图形渲染管线，与OpenGL中的概念相似。顶点着色器-&gt;细分着色器-&gt;几何着色器-&gt;光栅化着色器-&gt;片段着色器。OpenGL中固有这些，而vulkan需要手动创建。（也因此可以看出vulkan的可编程的程度极深）\nFramebuffer帧缓冲，即渲染目标对象。Framebuffer需要关联不同的Image，这些Image起到不同的作用，颜色缓冲、深度缓冲、模板缓冲等。\nRenderPass可以理解为Pipeline的输入参数，最终要的输入参数是Framebuffer。\nDiscriptorDiscriptor是单个资源的抽象句柄（如纹理、缓冲）。\nDiscriptorSet是一组描述符集合，对应着色器中的set绑定组。\nDescriptorPool（描述符池） 是用于高效分配和管理 描述符集（DescriptorSet） 的核心对象。它类似于内存池的概念，主要作用是通过预分配资源减少动态内存分配的开销，从而提升渲染性能。\nDescriptor预先分配一定数量和类型的描述符（如UniformBuffer、StorageBuffer、纹理、采样器等），后续从池中分配描述符集，避免频繁的全局内存操作和同步开销。\n1）通过描述符集布局定义资源绑定规则；2）从描述符池分配描述符集；3）更新描述符集指向的资源；4）绑定描述符集到管线供着色器使用。\nSubmitCommandBuffer不能直接推入Queue中，因为多个CommandBuffer可能需要进行同步、排他等设置，因此需要将CommandBuffer和同步、排他对象一起放到同一个Submit对象中，然后将Submit推入Queue中。这样vulkan可以根据Submit中的对象来安排CommandBuffer的执行顺序。\n常用的控制CommandBuffer之间、CPU-GPU、GPU-GPU之间的同步或排他对象由VkEvent、VkSemaphore和VkFence。\nUniformBuffer&#x2F;StorageBuffer这两种buffer都是用于着色器与CPU之间传递的结构化数据。\nUniformBuffer是一种只读缓冲，用于传递全局、低频更新的数据（如MVP矩阵、灯光参数等）。绘制期间，在着色器中无法修改。需要显式对齐，std140.\nStorageBuffer是一种可读写缓冲，用于传递大量结构化数据（如顶点数据、粒子状态、计算着色器结果）。支持动态修改和原子操作。对齐灵活，std340.\n\n\n\n特性\nUniform Buffer\nStorage Buffer\n\n\n\n访问权限\n只读\n可读写（支持原子操作）\n\n\n数据规模\n适合小数据（KB 级）\n适合大数据（MB&#x2F;GB 级）\n\n\n内存布局\nstd140（严格对齐）\nstd430（更灵活对齐）\n\n\n性能优化\n低延迟，专用缓存\n高带宽，适合批量操作\n\n\n典型用途\n矩阵、全局参数\n粒子系统、计算着色器、通用数据结构\n\n\nVulkan 标志\nVK_BUFFER_USAGE_UNIFORM_BUFFER_BIT\nVK_BUFFER_USAGE_STORAGE_BUFFER_BIT\n\n\n内存布局规则Uniform Buffer（std140）\n基础类型对齐：标量（如 float）按 4 字节对齐，向量按 4N 字节对齐（如 vec3 对齐到 16 字节\n\n）。\n\n结构体内存：成员按声明顺序对齐，整体大小填充为 16 的倍数。\n// C++ 结构体（需手动填充）struct UniformBufferObject &#123;    alignas(16) glm::mat4 model;  // 16 字节对齐    alignas(16) glm::mat4 view;    alignas(16) glm::mat4 proj;&#125;;\n\nStorage Buffer（std430）\n更宽松对齐：标量和向量按自然大小对齐（如 vec3 对齐到 12 字节）。\n\n数组支持：动态数组无需预定义大小（在着色器中声明为positions[]\n// C++ 结构体（无需严格填充）struct Particle &#123;    glm::vec4 position;  // 16 字节对齐    glm::vec4 velocity;  // 自然对齐&#125;;\n\nComputeShader属于计算管线的核心部分，它不处理顶点、片段或几何数据，而是通过工作组并行执行用户定义的计算任务。无固定输入输出，完全由开发者定义，通过工作组和线程手动划分并行任务，无需绑定RenderPass或FrameBuffer（独立于渲染管线）。\n一般用于预处理或后处理，可以与图形管线无缝协作。可以用于图片模糊、锐化、粒子系统、光线追踪、几何处理、科学计算等。\n渲染器双缓冲命令队列维护两个命令队列，一个队列用于接收新的渲染命令，另一个队列用于执行渲染命令，通过SwapQueues在两个队列之间切换。这种设计可以实现渲染命令的并行处理：当GPU执行一个队列命令时，CPU可以同时向另一个队列中提交新的命令。\nPlacement newPlacement new是C++中的一种特殊的new操作符，它允许我们在已分配的内存空间中构造对象。与普通的new操作符不同，placement new不分配内存，只在指定的内存位置上调用构造函数。\n可以在实时系统中避免动态内存分配。\n不需要使用delete，因为内存不是new分配的。\nvoid* memory = // 某个内存位置new (memory) Type(constructor_args...);\n\nvkDeviceWaitIdle该函数会阻塞 CPU 线程，直到设备关联的所有队列（图形、计算、传输等）全部完成当前提交的任务并进入空闲状态。\n\n\n\n函数\n作用范围\n使用场景\n\n\n\nvkQueueWaitIdle\n单个指定队列\n等待特定队列任务完成（如图形队列）\n\n\nvkDeviceWaitIdle\n设备所有队列\n全局同步或设备级资源管理\n\n\nvkFence\n异步信号通知\n非阻塞式等待特定任务完成\n\n\n渲染流程\n创建Instance对象\n通过Intance列举所有Physical Device\n从Physical Device中挑选一个使用，并创建其Device对象\n通过Device对象创建支持图形指令的Queue\n通过Device创建Pipeline\n创建Shader\n创建RenderPass\n创建Framebuffer\n创建对应的Image，分配内存\n\n\n\n\n通过Device创建CommandPool\n通过CommandPool分配CommandBuffer\n主循环\n使用渲染命令填充CommandBuffer\n将填充后的CommandBuffer和排他、同步对象封装到Submit中\n将Submit推入Queue\n\n\n回收资源\n\n渲染命令的提交这是一种封装，将所有与渲染相关的任务封装成一个函数（命令），提交到队列中，队列维护一个头指针和动指针，和一个buffer，此buffer中存储提交的函数指针。\n后面在渲染进程中执行的就是此buffer（队列）中的命令（指针所指的函数）。\n// 提交渲染命令，FuncT为函数类型，使用std::forward&lt;FuncT&gt;(func)，可以完美转发FuncT类型的函数// 所谓渲染命令，就是将FuncT类型的函数包装成一个命令，然后提交到队列中，渲染线程会执行这个命令// 提交可以分别提交，执行则是一次性执行所有命令template &lt;typename FuncT&gt; static void Submit(FuncT&amp;&amp; func)&#123;    // 编译时检查FuncT是否可调用    static_assert(std::is_invocable&lt;FuncT&gt;::value, &quot;Function must be invocable&quot;);    // 定义渲染命令执行函数，传入void*，执行FuncT类型的函数    // 这里只是包装FuncT类型的函数，并调用析构函数    auto renderCmd = [](void* ptr) &#123;        auto pFunc = (FuncT*)ptr;  // 将通用指针类型(void*)转换为具体类型(FuncT*)        (*pFunc)();                // 调用FuncT类型的函数        pFunc-&gt;~FuncT();           // 调用析构函数    &#125;;    // 在命令队列中分配空间    auto storageBuffer = GetRenderCommandQueue().Allocate(renderCmd, sizeof(func));    // 在分配的空间中初始化FuncT类型的函数，这里使用了placement    // new，不需要调用delete，因为空间并不是new出来的，而是命令队列在创建队列时new的，然后分配给renderCmd    new (storageBuffer) FuncT(std::forward&lt;FuncT&gt;(func));&#125;\n\n双缓冲渲染命令队列最开始是一个空渲染帧，最开始当然什么命令也没有，执行0个命令，然后开始主循环。\n循环最开始是先执行渲染队列0中已提交的命令，第一个主循环当然依然没有命令，此时主线程同时向渲染队列1中提交命令，渲染线程渲染完毕后等待，主线程提交命令后进入下一循环。\n之后的循环：主线程在渲染线程渲染完毕后开始进入下一帧，切换命令队列，唤醒渲染线程渲染上一个队列的命令，同时提交当前队列的命令；依然是渲染线程渲染完毕后阻塞等待，主线程提交完毕后进入下一循环。\n单线程模式下： 主线程提交命令与渲染线程执行命令不会同时进行，而是先将上一帧的渲染完成，然后再提交命令，如此往复。\n[11:14:20] [53480] [info] [MainThread] SwapQueues: 0[11:14:20] [53480] [trace] [MainThread] Kicking render thread (start rendering) ...[11:14:20] [53480] [trace] [MainThread] Waiting for render thread to complete rendering...[11:14:20] [49268] [trace] [RenderThread] RenderCommandQueue::Execute -- 0 commands, 0 bytes  # 第一个渲染帧[11:14:20] [49268] [trace] [RenderThread] Render complete[11:14:20] [49268] [trace] [RenderThread] Waiting for kick[11:14:20] [53480] [warning] ======== Begin Loop ========[11:14:20] [53480] [trace] [MainThread] Waiting for render thread to complete rendering...[11:14:20] [53480] [info] [MainThread] SwapQueues: 1[11:14:20] [53480] [trace] [MainThread] Kicking render thread (start rendering) ...[11:14:20] [53480] [info] [MainThread] RenderCommandQueue::Allocate -- 1 commands, 20 bytes\t  # 第而二个渲染帧[11:14:20] [49268] [trace] [RenderThread] RenderCommandQueue::Execute -- 0 commands, 0 bytes[11:14:20] [49268] [trace] [RenderThread] Render complete[11:14:20] [49268] [trace] [RenderThread] Waiting for kick[11:14:20] [53480] [warning] ======== End Loop ========[11:14:20] [53480] [warning] ======== Begin Loop ========[11:14:20] [53480] [trace] [MainThread] Waiting for render thread to complete rendering...[11:14:20] [53480] [info] [MainThread] SwapQueues: 0[11:14:20] [53480] [trace] [MainThread] Kicking render thread (start rendering) ...[11:14:20] [53480] [info] [MainThread] RenderCommandQueue::Allocate -- 1 commands, 20 bytes[11:14:20] [49268] [trace] [RenderThread] RenderCommandQueue::Execute -- 1 commands, 20 bytes[11:14:20] [53480] [warning] ======== End Loop ========[11:14:20] [53480] [warning] ======== Begin Loop ========[11:14:20] [53480] [trace] [MainThread] Waiting for render thread to complete rendering...[11:14:20] [49268] [trace] [RenderThread] Render complete[11:14:20] [49268] [trace] [RenderThread] Waiting for kick[11:14:20] [53480] [info] [MainThread] SwapQueues: 1[11:14:20] [53480] [trace] [MainThread] Kicking render thread (start rendering) ...[11:14:20] [53480] [info] [MainThread] RenderCommandQueue::Allocate -- 1 commands, 20 bytes[11:14:20] [49268] [trace] [RenderThread] RenderCommandQueue::Execute -- 1 commands, 20 bytes[11:14:20] [53480] [warning] ======== End Loop ========\n\n渲染线程的终止当程序终止，要妥善处理线程的终止，避免死锁导致渲染进程Join后无法退出的问题。\n对比以下个log：\n[14:16:22] [15200] [warning] ======== Begin Loop ========[14:16:22] [15200] [info] [MainThread] Waiting for render thread to complete rendering...[14:16:22] [2164] [trace] [RenderThread] Render complete, renderthread state: true[14:16:22] [2164] [trace] [RenderThread] &lt;RenderFunc&gt; Waiting for kick[14:16:22] [15200] [info] [MainThread] SwapQueues: 1[14:16:22] [15200] [info] [MainThread] Kicking render thread (start rendering) ...[14:16:22] [15200] [info] [MainThread] RenderCommandQueue::Allocate -- 1 commands, 20 bytes[14:16:22] [15200] [warning] ======== End Loop ========[14:16:22] [15200] [error] [RenderThread] Terminating render thread...[14:16:22] [15200] [error] [RenderThread] Renderfunc stoped before.[14:16:22] [15200] [error] [RenderThread] Renderfunc stoped.[14:16:22] [15200] [info] [MainThread] SwapQueues: 0[14:16:22] [15200] [info] [MainThread] Kicking render thread (start rendering) ...[14:16:22] [15200] [info] [MainThread] Waiting for render thread to complete rendering...[14:16:22] [2164] [trace] [RenderThread] RenderCommandQueue::Execute -- 1 commands, 20 bytes[14:16:22] [2164] [trace] [RenderThread] RenderCommandQueue::Execute -- 0 commands, 0 bytes[14:16:22] [2164] [trace] [RenderThread] Render complete, renderthread state: false[14:16:22] [2164] [error] [RenderThread] &lt;RenderFunc&gt; exit loop.[14:16:22] [15200] [error] [RenderThread] Terminated.[14:16:22] [15200] [trace] [RenderThread] RenderCommandQueue::Execute -- 0 commands, 0 bytes[14:16:22] [15200] [trace] [RenderThread] RenderCommandQueue::Execute -- 0 commands, 0 bytes[14:16:22] [15200] [trace] [RenderThread] RenderCommandQueue::Execute -- 0 commands, 0 bytes\n\n[14:17:54] [47488] [warning] ======== Begin Loop ========[14:17:54] [47488] [info] [MainThread] Waiting for render thread to complete rendering...[14:17:54] [44996] [trace] [RenderThread] RenderCommandQueue::Execute -- 0 commands, 0 bytes[14:17:54] [44996] [trace] [RenderThread] Render complete, renderthread state: true[14:17:54] [44996] [trace] [RenderThread] Render complete, renderthread state: true[14:17:54] [44996] [trace] [RenderThread] &lt;RenderFunc&gt; Waiting for kick[14:17:54] [47488] [info] [MainThread] SwapQueues: 1[14:17:54] [47488] [info] [MainThread] Kicking render thread (start rendering) ...[14:17:54] [47488] [info] [MainThread] RenderCommandQueue::Allocate -- 1 commands, 20 bytes[14:17:54] [47488] [warning] ======== End Loop ========[14:17:54] [44996] [trace] [RenderThread] RenderCommandQueue::Execute -- 1 commands, 20 bytes[14:17:54] [44996] [trace] [RenderThread] RenderCommandQueue::Execute -- 0 commands, 0 bytes[14:17:54] [47488] [error] [RenderThread] Terminating render thread...[14:17:54] [47488] [error] [RenderThread] Renderfunc stoped before.[14:17:54] [47488] [error] [RenderThread] Renderfunc stoped.[14:17:54] [44996] [trace] [RenderThread] Render complete, renderthread state: true[14:17:54] [47488] [info] [MainThread] SwapQueues: 0[14:17:54] [47488] [info] [MainThread] Kicking render thread (start rendering) ...[14:17:54] [47488] [info] [MainThread] Waiting for render thread to complete rendering...[14:17:54] [44996] [trace] [RenderThread] Render complete, renderthread state: false[14:17:54] [44996] [error] [RenderThread] &lt;RenderFunc&gt; exit loop.\n\n这里有一个潜在的问题，如果在m_IsRunning被设置为false之后，渲染线程先退出循环，这里再进行Pump，就会导致主线程无限等待渲染结束，而渲染线程则永远也无法结束（因为根本无法开始————循环已经结束了）\n解决方法是先等待渲染线程空闲，开启下一帧，Kick渲染使其开始渲染，此时立刻关闭循环，并入主线程，等待渲染线程的结束，主线程就可以顺利结束了\n三缓冲渲染(多帧并行)vkFence栅栏是一种同步原语，可用于将依赖项从队列插入到主机。栅栏有两种状态 - 已发出信号和未发出信号。栅栏可在执行队列提交命令时发出信号。可以使用 vkResetFences 在主机上取消栅栏信号。主机可以使用 vkWaitForFences 命令等待栅栏，并且可以使用 vkGetFenceStatus 查询当前状态。\nvkWaitForFencesVkResult vkWaitForFences(    VkDevice                                    device,   \t// 拥有此栏栅的设备    uint32_t                                    fenceCount, // 需要等待的栏栅数量    const VkFence*                              pFences,  \t// 指向栏栅句柄的指针    VkBool32                                    waitAll,\t// 是否等待所有栏栅    uint64_t                                    timeout); \t// 超时时间\n\n调用后CPU阻塞，直到GPU完成上一帧的工作并发出Fence信号或者达到超时时间。\n如果GPU处理速度跟不上CPU提交速度，会导致CPU等待，这可能会影响整体性能，通常通过使用多个”frame in flight”(多帧并行)来减少等待，使用多个交替的Fence来实现CPU与GPU的并行工作。\n// 等待上一帧完成vkWaitForFences(device, 1, &amp;m_WaitFences[m_CurrentFrameIndex], VK_TRUE, UINT64_MAX);// 获取新的图像fpAcquireNextImageKHR(..., m_ImageAvailableSemaphores[m_CurrentFrameIndex], ...);// 提交渲染命令vkQueueSubmit(..., m_RenderFinishedSemaphores[m_CurrentFrameIndex], ...);\n\n多帧并行// 每个frame都有独立的同步对象m_ImageAvailableSemaphores.resize(framesInFlight);m_RenderFinishedSemaphores.resize(framesInFlight);m_WaitFences.resize(framesInFlight);\n\n与双缓冲命令队列不同，命令队列只关注渲染命令的记录（CPU中）和执行（GPU中），而FramesInFlight要管理所有帧相关的资源。\nKHR后缀在Vulkan中，带有KHR后缀和不带KHR后缀的函数主要区别在于：\n\n扩展与核心功能：\n\nvkWaitSemaphoresKHR: 是KHR扩展的一部分，最初作为扩展功能引入\nvkWaitSemaphores: 是Vulkan核心功能的一部分，在后续版本中被纳入标准\n\n\n可用性：\n\nKHR版本需要检查设备是否支持该扩展\n非KHR版本在支持该版本的Vulkan实现中直接可用\n\n\n使用方式：\n// KHR扩展版本需要先启用扩展VkDeviceCreateInfo createInfo = &#123;&#125;;createInfo.ppEnabledExtensionNames = &#123; &quot;VK_KHR_timeline_semaphore&quot; &#125;;// 核心版本直接使用vkWaitSemaphores(device, ...);\n\n版本要求：\n\nKHR版本通常在较早的Vulkan版本中就可用\n非KHR版本需要更新的Vulkan版本\n\n\n\n一般建议：\n\n如果需要支持较老的Vulkan版本，使用KHR版本\n如果使用较新的Vulkan版本，优先使用非KHR版本\n有时可能需要根据运行时检测来决定使用哪个版本\n\n注意：这个规则适用于Vulkan中所有带KHR后缀和不带KHR后缀的函数对。KHR表示这个功能最初是由Khronos Group（Vulkan的开发组织）作为扩展引入的。\n描述符集描述符池，Vulkan中的描述符集不能直接创建，只能从特定的缓冲池中分配，这个缓冲池就是描述符池，在创建描述符池的时候需要分配描述符池的大小，里面各描述符集的数量。\n描述符集就是描述符的集合，Set 就是 DataSet 就是数据集。\n描述符用以关联用户的数据资源和着色器，如Uniform、Sampler、Texture等，为了让VulkanAPI识别资源，引入描述符和描述符集布局。描述符布局绑定就是定义绑定关系，如绑定到着色器layout(binding &#x3D; 0)上。描述符是一种通信协议，用于CPU与着色器通信。在系统内部，描述符提供了一种静默的机制，通过位置绑定的方式来关联资源内存与着色器。\nVulkan渲染管线共三种，ComputePipeline和GraphicsPipeline和Ray tracing pipeline。Pipeline中包含了PipelineLayout，PipelineLayout制定了管线使用的那些DescriptoSetLayout和PushConstant。\n计算管线(Compute Pipeline)是比较简单的一种，因为它所支持的都是只计算的程序(称为Computer Shader)。\nGraphicsPipeline要复杂得多如下图所示，因为它包含了所有的参数，如顶点、片段、几何、计算和曲面细分着色器(如果启用了该功能的话)，再加上像顶点属性、输入装配、图元结构、光栅化参数、深度&#x2F;模板测试参数、面剔除和Blend Const、视口(ViewPort)参数还有RenderPass等，Vulkan会将这些状态固定成一个大的、不可更改的对象。\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic"]},{"title":"Vulkan Shader","url":"/2025/02/21/note/Programming/CG/VulkanShader/","content":"Vulkan Shader 的资源绑定与OpenGL的对比。\n\n\nOpenGL的资源绑定系统在OpenGL中，资源绑定相对简单但不够灵活：\nUniform变量示例：\n// OpenGL着色器uniform mat4 modelMatrix;uniform vec4 color;\n\n对应的C++代码：\n// 获取uniform位置GLint modelMatrixLoc = glGetUniformLocation(program, &quot;modelMatrix&quot;);GLint colorLoc = glGetUniformLocation(program, &quot;color&quot;);// 设置uniform值glUseProgram(program);glUniformMatrix4fv(modelMatrixLoc, 1, GL_FALSE, &amp;modelMatrix[0][0]);glUniform4fv(colorLoc, 1, &amp;color[0]);\n\n纹理绑定示例：\n// OpenGL纹理绑定glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, textureId);glUniform1i(textureLoc, 0);  // 设置采样器uniform\n\nVulkan的资源绑定系统Vulkan使用更复杂但更灵活的描述符系统，我们来详细分析每种数据传递方式：\nPush Constants（推送常量）这是最直接和最快的数据传递方式，适合频繁更新的小数据。\n着色器代码：\n// Vulkan着色器layout(push_constant) uniform PushConstants &#123;    mat4 transform;    vec4 color;&#125; pushConstants;\n\nC++实现：\n// 定义推送常量数据结构struct PushConstants &#123;    glm::mat4 transform;    glm::vec4 color;&#125;;// 创建管线布局时声明推送常量范围VkPushConstantRange pushConstantRange = &#123;&#125;;pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;pushConstantRange.offset = 0;pushConstantRange.size = sizeof(PushConstants);// 在渲染时更新推送常量PushConstants constants = &#123; ... &#125;;vkCmdPushConstants(    commandBuffer,    pipelineLayout,    VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,    0,    sizeof(PushConstants),    &amp;constants);\n\n特点：\n\n数据大小通常限制在128-256字节\n无需描述符分配\n更新速度最快\n适合每次绘制调用都需要更改的小数据\n\nUniform Buffers（统一缓冲区）适合较大的、相对稳定的数据。\n着色器代码：\n// Vulkan着色器layout(std140, set = 0, binding = 0) uniform UniformBufferObject &#123;    mat4 model;    mat4 view;    mat4 proj;&#125; ubo;\n\nC++实现：\n// 创建统一缓冲区struct UniformBufferObject &#123;    glm::mat4 model;    glm::mat4 view;    glm::mat4 proj;&#125;;// 创建缓冲区VkBuffer uniformBuffer;VkDeviceMemory uniformBufferMemory;createBuffer(    sizeof(UniformBufferObject),    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,    uniformBuffer,    uniformBufferMemory);// 创建描述符集布局VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;uboLayoutBinding.binding = 0;uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;uboLayoutBinding.descriptorCount = 1;uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;// 分配和更新描述符集VkDescriptorBufferInfo bufferInfo = &#123;&#125;;bufferInfo.buffer = uniformBuffer;bufferInfo.offset = 0;bufferInfo.range = sizeof(UniformBufferObject);VkWriteDescriptorSet descriptorWrite = &#123;&#125;;descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;descriptorWrite.dstSet = descriptorSet;descriptorWrite.dstBinding = 0;descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;descriptorWrite.descriptorCount = 1;descriptorWrite.pBufferInfo = &amp;bufferInfo;vkUpdateDescriptorSets(device, 1, &amp;descriptorWrite, 0, nullptr);// 更新数据UniformBufferObject ubo = &#123;&#125;;void* data;vkMapMemory(device, uniformBufferMemory, 0, sizeof(ubo), 0, &amp;data);memcpy(data, &amp;ubo, sizeof(ubo));vkUnmapMemory(device, uniformBufferMemory);\n\n特点：\n\n支持较大数据块\n需要显式管理内存\n通过描述符集系统访问\n可以在多个着色器间共享\n更新频率适中\n\nStorage Buffers（存储缓冲区）适合需要读写访问的大量数据。\n着色器代码：\n// Vulkan着色器layout(std430, set = 0, binding = 1) buffer StorageBuffer &#123;    vec4 positions[];&#125; ssbo;\n\nC++实现：\n// 创建存储缓冲区VkBuffer storageBuffer;VkDeviceMemory storageBufferMemory;createBuffer(    bufferSize,    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,    storageBuffer,    storageBufferMemory);// 描述符设置类似于Uniform Buffer，但使用VK_DESCRIPTOR_TYPE_STORAGE_BUFFER\n\n特点：\n\n支持着色器读写访问\n可以存储动态大小的数据\n适合计算着色器的数据处理\n\nCombined Image Samplers（组合图像采样器）用于纹理采样。\n着色器代码：\n// Vulkan着色器layout(set = 1, binding = 0) uniform sampler2D texSampler;\n\nC++实现：\n// 创建图像和采样器VkImage textureImage;VkImageView textureImageView;VkSampler textureSampler;// 创建描述符集布局VkDescriptorSetLayoutBinding samplerLayoutBinding = &#123;&#125;;samplerLayoutBinding.binding = 0;samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;samplerLayoutBinding.descriptorCount = 1;samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;// 更新描述符集VkDescriptorImageInfo imageInfo = &#123;&#125;;imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;imageInfo.imageView = textureImageView;imageInfo.sampler = textureSampler;VkWriteDescriptorSet descriptorWrite = &#123;&#125;;descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;descriptorWrite.dstSet = descriptorSet;descriptorWrite.dstBinding = 0;descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;descriptorWrite.descriptorCount = 1;descriptorWrite.pImageInfo = &amp;imageInfo;vkUpdateDescriptorSets(device, 1, &amp;descriptorWrite, 0, nullptr);\n\n数据流转的关键区别\n描述符集的层次结构：\n\n\nVulkan使用set和binding两级结构\n可以在多个管线间共享描述符集\n支持描述符集的部分更新\n\n\n内存管理：\n\n\nVulkan需要显式管理内存分配和绑定\n支持多种内存类型和内存属性\n可以更精确地控制数据传输路径\n\n\n同步机制：\n\n\nVulkan需要显式管理资源访问同步\n使用内存屏障和事件等同步原语\n可以更精确地控制数据访问时序\n\n\n批量更新：\n\n\nVulkan支持批量更新描述符集\n可以一次性更新多个资源绑定\n减少API调用开销\n\n性能考虑\nPush Constants：\n\n\n最快的数据传输方式\n直接嵌入命令缓冲区\n适合高频更新的小数据\n\n\nUniform Buffers：\n\n\n中等访问速度\n适合较大但更新频率不高的数据\n可以使用动态偏移优化\n\n\nStorage Buffers：\n\n\n读写访问较慢\n适合大量数据的计算\n支持原子操作\n\n\n描述符集缓存：\n\n\n可以预先分配描述符集池\n重用描述符集减少开销\n支持描述符集更新模板\n\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic"]},{"title":"C Language","url":"/2022/05/25/note/Programming/Language/C/","content":"\n📚  学习c语言过程中的笔记和个人理解，用来查找和复习。\n\n\n\n\nIntroduction\nOur daily life has become inseparable from computers. Whether you are using computers or not, you are using computers consciously or unconsciously, or using the services that computers provide for you. When we are in the use of computer, we are all in the use of computer has some software, so we will go to find the APP, if you searched all the APPs on the market, is there no have the functionality of the APP you want, then you have to write their own one, if you want to do something special, you can’t find the right software, will still have to write their own one.Learning programming is not about writing software for yourself. It is about learning programming to understand how computers work, what they can or are good at doing, what they can’t or aren’t good at doing, and how computers solve problems.\n\n —— Weng Kai\n\nGet startedFramework#include &quot;stdio.h&quot;int main()&#123;    return 0;&#125;\n\nAny programs programed by C language must have this framework.\nOutput functionYou can understand it as function in math, which is a mapping relationship. But they are different.\nprintf is a function, whoes function is output a string by formating printf(&quot;......\\n&quot;) .\nFor example, the Hello, world! :\n#include &quot;stdio.h&quot;int main()&#123;    printf(&quot;Hello,world!\\n&quot;); // \\n make it wrapping    return 0;&#125;\n\nprintf  can print not only a string, but also the value of the variable, but you need to format the variable.\nVariables and constants\nThe computer carries on the computation, then participates in the computation is the number, participates in the computation in the C language the number is called the quantity, the quantity divides into the variable and the constant.Use decimal for expression of daily life, because is advantageous for the calculation of the human brain, a computer internal use binary, for convenience of computer calculation, and the computer expression, as a result of bytes in computer internal frequency is higher, if you can use a simple way to express its inner meaning accurately, Will bring us a lot of convenience, so often use hexadecimal expression.But the number itself remains the same no matter which way it is counted.\n\nConstantsAs the name implies, an invariant quantity that, once initialized, cannot be changed.\nVariablesAs the name implies, a variable quantity that, once defined, can be assigned any value to change its size.\nThe way of difination：\nint i;int j = 1;char k;float h = 1.2;double g = 2.0;\n\nFor example, i is the variable itself, int is an integer variable, whose value can only be an integer, while double is a double-precision floating point number, which can represent a decimal.\nDifferent variable types have different value types and value ranges.\nCharacter variables:\nUse to store character constants. A character variable can hold only one character constant. The type specifier is char.\n#include&lt;stdio.h&gt;int main()&#123;    char x,y,z;    x = &#x27;b&#x27;;    y = &#x27;o&#x27;;    z = &#x27;y&#x27;;    printf(&quot;%c%c%c\\n&quot;,x,y,z);return 0;&#125;\n\nThe result is:\nboy\n\nThe literal value of a character variable is independent of the character constant it holds, analogous to an integer variable.\nCharacter variables can also store integer data, which is universal. You can change %c to %d during input and output.\nOutput and input of a variableOutputAs mentioned above, printf can print a string, and can print the value of a variable, as shown in the following example:\n#include &quot;stdio.h&quot;int main()&#123;    int i = 1;    printf(&quot;i = %d\\n&quot;,i);    i = 2;    printf(&quot;After assignment，i = %d\\n&quot;,i);    return 0;&#125;\n\nNotice that printf prints the value of the variable with a %d inside the double quotes, which is the way the variable is formatted.\n %d indicates that the output variable is an integer.\n\n\n\nVariable Types\nFormatting Symbols\n\n\n\nint\n%d\n\n\nunsigned\n%u\n\n\nlong long\n%ld\n\n\nunsigned long long\n%lu\n\n\nfloat\n%f\n\n\ndouble\n%lf\n\n\nYou can use scientific notation when you output, and use %e for formatting symbol.\nprintf(&quot;%.nf&quot;,sum);\n\nThis line of code can preserve n decimal places.\nThe following are escape characters:\n\n\n\nSymbols\nWords\n中文含义\n\n\n\n\\b\nbackspace\n回退一格\n\n\n\\t\ntab\n下一个制表位\n\n\n\\n\nnew line\n换行\n\n\n\\r\nreturn\n回车\n\n\n\\f\nf\n换页\n\n\nInputSimilarly, the function scanf can read the input according to a certain format.\n#include &lt;stdio.h&gt;int main( ) &#123;   char str[100];   int i;   printf( &quot;Enter a value :&quot;);   scanf(&quot;%s %d&quot;, str, &amp;i);   printf( &quot;\\nYou entered: %s %d &quot;, str, i);   printf(&quot;\\n&quot;);   return 0;&#125;\n\nscanf() stops reading a string as soon as it encounters a space, so “this is test” is three strings for scanf().\nFloating point numbersIn mathematics, the numbers on the number line are continuous, and between any two different points, an infinite number can be found, but this is difficult to achieve in computers, so floating point numbers emerged.\nFloating point numbers are used to represent fractional numbers between whole numbers, but their accuracy is not infinite, nor is their expressability infinite, so a random decimal may not be able to be expressed by a computer.\nOperationOperator\n\n\nMathematics\nAdd\nSubstract\nMultiply\nDivide\nRemainder\n\n\n\nC Language\n+\n-\n*\n&#x2F;\n%\n\n\nRelational operator\n\n\nRelation\nEqual\nNot Equal\nGreater\nGreater or Equal\nLess-than\nLess-than or Equal\n\n\n\nOperator\n&#x3D;&#x3D;\n!&#x3D;\n&gt;\n&gt;&#x3D;\n&lt;\n&lt;&#x3D;\n\n\nThe relational operator evaluates only zeros and ones.\nSpecial operatorcount ++ and ++ count both mean to add one, but a = count ++; means to assign the value of count to a and then add one, whereas a = ++count; means to add one to the value of count and then assign the result to a. So you end up adding one to count in both cases, but the value of a differ by 1.\ncount -- and -- count in the same way.\n, is comma operator that generally has only one purpose: to add multiple conditions to an if statement.\nConditional operatorcount = (&lt;#condition#&gt;)? &lt;#yes#&gt;:&lt;#no#&gt;;\n\nIt is equivalent to an if statement.\n\nNesting is not recommended.\n\nLogical operator\n\n\nLogic\nand\nor\nnot\n\n\n\nSymbol\n&amp;&amp;\n||\n!\n\n\nThe result of logical operation is only 0 or 1.\nSeveral statementsifif (&lt;#condition#&gt;) &#123;      &lt;#statements#&gt;  &#125;\n\nTo judge and to act when the conditions are true.\n   if (&lt;#condition#&gt;) &#123;       &lt;#statements#&gt;   &#125;   else if (#condition#) &#123;       &lt;#statements#&gt;   &#125;else if (#condition#) &#123;       &lt;#statements#&gt;   &#125; ……   else &#123;       &lt;#statements#&gt;   &#125;\n\nWe can add else, so we can do something if the condition doesn’t work.\nThe else always matches the nearest if.\nwhilewhile (&lt;#condition#&gt;) &#123;    &lt;#statements#&gt;&#125;\n\nThe loop continues until the condition fails.\ndowhiledo &#123;    &lt;#statements#&gt;&#125; while (&lt;#condition#&gt;);\n\nThe loop continues until the condition fails.\nThe difference with a while loop is that a dowhile does something and then evaluates the condition, whereas a while evaluates the condition and then loops. While might not do a loop at all, if the condition is not satisfied in the first place.\nswitchswitch (&lt;#expression#&gt;) &#123;    case &lt;#constant#&gt;:        &lt;#statements#&gt;        break;   case &lt;#constant#&gt;:        &lt;#statements#&gt;        break;    ......    default:        break;&#125;\n\nswitch is judgment statement, the &lt;#expression#&gt;  is constant expression that must be a integral type or enum-type.\nThe essence of such a statement is the program evaluates this expression and then compares it to each case at a time. The action after the case is executed when equal.\nThere are an infinite number of cases, each followed by a value to be compared with and a colon.\nThe variables to be compared must be of the same type.\nWhen all the case is false, the program will do the action after default . So there can be nothing after defalut.\nFor example:\n#include &lt;stdio.h&gt;int main()&#123;    int a;    printf(&quot;Input integer number:&quot;);    scanf(&quot;%d&quot;,&amp;a);    switch(a)&#123;        case 1: printf(&quot;Monday\\n&quot;); break;        case 2: printf(&quot;Tuesday\\n&quot;); break;        case 3: printf(&quot;Wednesday\\n&quot;); break;        case 4: printf(&quot;Thursday\\n&quot;); break;        case 5: printf(&quot;Friday\\n&quot;); break;        case 6: printf(&quot;Saturday\\n&quot;); break;        case 7: printf(&quot;Sunday\\n&quot;); break;        default:printf(&quot;error\\n&quot;); break;    &#125;    return 0;&#125;\n\nforfor (&lt;#initialization#&gt;; &lt;#condition#&gt;; &lt;#increment#&gt;) &#123;    &lt;#statements#&gt;&#125;\n\nfor loop applies to loops with a defined number of cycles, such as traverse.\nThere are three sections in parenthesis, separated with semicolons, which are respectively initialization, conditions for loop to proceed and actions to be performed in each cycle.\nMiscellaneous\n\n\nKey words\nImplication\n\n\n\nInf\nInfinity\n\n\n-Inf\nNegative infinity\n\n\nnan\nInvalid number\n\n\nfabs(&lt;#expression#&gt;)\nAbsolute value\n\n\nbreak\nJump out of the loop\n\n\ncontinue\nEnd the cycle\n\n\nFunction and customizing functionAt the beginning of C language program, the implication of #include &lt;stdio.h&gt; is including a function library named stdio.h and then the program can call functions in the library. Both the printf and the scanf used in the previous paragraph are functions of the library.\nIn practice, we often encounter repeated operations, we can copy this code to complete the repeated action, but code copy is a poor quality of the program, because the maintenance may need to change too many places.\nYou can solve this problem by customizing functions:\n&lt;#type#&gt; (&lt;#type#&gt;,&lt;#type#&gt;,……)&#123;  &lt;#statement#&gt;  return 0; //Depends on the function type，Also visable as：return;&#125;\n\n\nA function can have multiple return  or none. However, multiple return are not recommended for easy modification.\n\nEach function has its own variable space, namely &#123;&#125; (block), which is independent of each other. Local variables are limited by the block they are in. If the inside of a block has the same name as the outside of a block, the inside of a block takes precedence.\n\nWhen a function is called, it can only pass values to functions, not variables to functions. That is, after passing a variable to a function, the function will read the value of the variable for operation, but will not change the value of the variable.\n\nThe first line of a function with a semicolon placed before the entire program code is called a function prototype declaration. The purpose is to tell the compiler what type the function is before it encounters it.\n\n\nArrayDefination\ntype of variables + character + [number of variables]\n\nFor example:\nint a[10];\n\nAn array is a container that, once created, cannot be resized, is internally ordered, and can appear on both sides of an assignment symbol.\nThe index of an array is counted from 0.\nYou can think of it as a sequence in mathematics.\nUseIntegration initialization is easy to use:\nint a[3] = &#123;1,3,5,&#125;;int a[13] = &#123;[0]=2,[3]=5,6,7,[9]=0,&#125;; //（C99 only）\n\nIf you don’t know how many cells there are in an array, you can use sizeof(a)/sizeof(a[0]) to represent the number of cells in the array, so that you don’t need to change the number of cells in the array.\nMultidimensional arrayA multidimensional array is actually a multidimensional matrix, and the footer increases accordingly.\nInitialization:\nint a[][5] = &#123; &#123;0,1,2,3,4&#125;, &#123;2,3,4,5,6&#125;,&#125;\n\nThe number of columns must be given and the number of rows can be counted by the compiler itself.\nPointerAddressEach variable has an address in the computer where it is stored. The value of a variable can change, but its address is constant. The following code can be used to view the address of a variable.\nint i = 1;printf(&quot;%d\\n&quot;,&amp;i);\n\n&amp; is the address to access the variable;\n* is the variable on the access address.\nDefinationA pointer is a variable, but it cannot be used independently. It must point to a variable. In this case, the value of the pointer variable is the address of the variable to which it points.\nUseint *p = &amp;i;\n\nIn this case, p is a pointer to the address of variable i. So the value of p is the address of i, and the value of i can be accessed (read and write) by *p.\nThe * at definition is not the same as the * at access, and the first is only used to distinguish whether a pointer variable or a normal variable is being defined.\nHere is an example of using a pointer to complete a call to exchange the values of two variables.\n#include &lt;stdio.h&gt;void exchange(int *a,int *b)&#123;    int i = *a;    *a = *b;    *b = i;&#125;int main()&#123;    int a = 5;    int b = 6;    exc(&amp;a, &amp;b);    printf(&quot;a = %d,b = %d\\n&quot;,a,b);    return 0;&#125;\n\nThis is a clever use of the function, we know that the function cannot input variable parameters, so this code defines the address of the pointer to the variable, the function input pointer variable is also the address of the variable, inside the function by adding a pointer to access the variable, and then achieve the purpose of the function to modify the variable.\n\nIn addition, pointers are often used when a function needs to return multiple values.\n\nArrays are special Pointers#include &lt;stdio.h&gt;int main()&#123;    int a[] = &#123;1,2,3,&#125;;    printf(&quot;%p\\n&quot;,a);    return 0;&#125;\n\nThe result of this code is:\n0x7ffcac420c3c\n\nWe can see that the array variable a is itself an address, so when we want to use a pointer to array a, we should write int *p = a, without &amp;. But the array unit is variable, therefore int *p = &amp;a[0], at the same time, a == &amp;a[0],&amp;a[x] == &amp;a[0] + 4x = a + 4x(when a is integer).\nAn array is a pointer to a constant and therefore cannot be assigned.\nPointer to a constant (const)int i;int const *p = &amp;i; // 1int *const p = &amp;i; // 2\n\nFor the above code, you can think of the following code:\nint i;int const (*p) = &amp;i; // 1int *(const p) = &amp;i; // 2\n\n1 indicates that the variable at the address pointed to by the pointer p cannot be modified by the pointer.\n2 indicates that the address (variable’s address certainly) pointed to by p cannot be changed.\n\nThe first whole to the right of const cannot be modified\n\nconst int a[] = &#123;1,2,3,&#125;;\n\nThe above code indicates that each cell is const, so it can be used to protect an array when a function argument is entered.\nAddress of a pointerint a[];int *p = a;\n\n*p = a = a[0],\n*(p+1) = a[1],\n*(p+2) = a[2],\n……,\n*(p+n) = a[n].\nAllocating Memory SpaceThe malloc function applies space in bytes from memory, returns void *, converts the desired type, and finally frees the memory. Format, such as:\nint a[n] = (int *)malloc(n * sizeof(int));\n\nIf the application fails, 0 or NULL is returned.\nWhen you no longer use the requested memory space, you should use the free function to free the memory space:\nfree(a[n]);\n\nStringOverviewChar word[] = &#123;&#x27;H&#x27;,&#x27;D&#x27;,&#x27;e&#x27;,&#x27;!&#x27;&#125;;\n\nSuch an array is an array of characters, but it is not a string, because it cannot be evaluated as a string.\nChar word[] = &#123;&#x27;H&#x27;,&#x27;D&#x27;,&#x27;e&#x27;,&#x27;!&#x27;,&#x27;\\0&#x27;&#125;;\n\nFollowed by \\0, then word is a string.\n0 &#x3D; &#39;\\0&#39; !&#x3D; &#39;0&#39;\n0 marks the end of the string, but this 0 is not part of the string.\nStrings exist as Arrays and are accessed as arrays or Pointers, but more often as Pointers.\nstring.h has a number of functions that handle strings.\nString variables:\nchar *str = &quot;hello&quot;;char word[] = &quot;hello&quot;;char line[10] = &quot;hello&quot;;\n\n\n“hello”\n\nThe compiler will turn this into an array of characters somewhere, and the length of the array is 6, because the compiler will put a 0 after it to make it a string.\nLiterals of strings can be used to initialize character arrays.\n#include &quot;stdio.h&quot;int main()&#123;    int i = 0;    char *s = &quot;hello world&quot;;//    s[0] = &#x27;B&#x27;;    char *s2= &quot;hello world&quot;;    char s3[] = &#123;&quot;hello world&quot;&#125;;//    s3[0] = &#x27;b&#x27;;    printf(&quot;&amp;i = %p\\n&quot;, &amp;i);    printf(&quot;s = %p\\n&quot;, s);    printf(&quot;s2 = %p\\n&quot;, s2);    printf(&quot;Here is s[0] = %c\\n&quot;, s[0]);    printf(&quot;Here is s3[0] = %c\\n&quot;,s3[0]);    return 0;&#125;\n\nThe above code runs as follows:\n&amp;i = 0x7fffa827bcf4s = 0x55c7d8f64004s2 = 0x55c7d8f64004Here is s[0] = hHere is s3[0] = h\n\nYou can see that the local variable i is far from where the pointer s is pointing. The address of the variable i is very far back, and the pointer is very far forward. Near the front are important parts of the computer that are not allowed to be modified, such as plus s[0] = &#39;B&#39; ‘, and the result is:\n1869 segmentation fault  ./a.out\n\nThe program attempted to reassign the initialized string s. The error “segmentation fault“ was reported, meaning that the program was attempting to rewrite the value at 0x55c7d8f64004, which posed a threat to the computer and was not allowed.\nIn fact, for char *s = &quot;hello world&quot;; pointer s is initialized to point to a string constant, which should actually be const char *s = &quot;hello world&quot;;, but for historical reasons, compilers accept writing without const, and try to modify the string to which s refers, with serious consequences.\ns3 is an array, and the strings inside are local variables that can be modified, plus S3[0] = &#39;b&#39;:\n&amp;i = 0x7fff28d5dd64s = 0x559da8ac6004s2 = 0x559da8ac6004Here is s[0] = hHere is s3[0] = b\n\nThere are two ways to define a string: pointer or array.\nArrays know the address of strings, Pointers don’t.\nA char * or int * is not necessarily a string. It is meant to be a pointer to a character or an array of characters.\n A char * or int * is a string only if the array of characters to which the pointer points has a zero at the end.\nchar *t = &quot;title&quot;;char *s;s = t;\n\nFor the above code, we have two Pointers, t and s. First, t points to the string “title”, and then we assign a value to s. The result is that s also points to the same string, instead of creating a new string.\nInput and output of stringFor printf and scanf, you can use %s to input and output strings.\nEach %s in scanf is read until a SPACE or ENTER, which is not safe because you do not know exactly how many characters to read, therefore, the following code is used:\nchar s[8];scanf(&quot;%7s&quot;,s);\n\nArray of stringschar a[][10];char *a[];\n\nThe first line refers to a as a two-dimensional array, and the second line refers to a as a pointer array. Each unit in the array is a pointer to a string.\nEach element of the character array holds one character, plus the 0 at the end. An array of length n can hold n-1 characters.\nMultiple loops are required to input and output all elements of multiple dimensions, whether string arrays or integer arrays.\nAn array is a matrix that can be used to store variables or character variables. All input and output need to be looped, but there are two types of input and output for character arrays.\nInput and output single characters in format %c#include &lt;stdio.h&gt;int main()&#123;    int x,i,j;    char a[][20] = &#123;        &quot;&quot;,        &quot;Monday&quot;,        &quot;Tuesday&quot;,        &quot;Wednesday&quot;,        &quot;Thursday&quot;,        &quot;Friday&quot;,        &quot;Saturday&quot;,        &quot;Sunday&quot;,    &#125;;    printf(&quot;Please input the month：\\n&quot;);    scanf(&quot;%d&quot;,&amp;x);    if (x &gt; 0 &amp;&amp; x &lt; 8) &#123;        for (i = x ; i &lt; x + 1; i ++) &#123;            for (j = 0; j &lt; 20; j ++) &#123;               printf(&quot;%c&quot;,a[i][j]);          &#125;       &#125;           &#125;    else printf(&quot;Error&quot;);    printf(&quot;\\n&quot;);    return 0;&#125;\n\nInput and output whole array with format %s#include &lt;stdio.h&gt;int main()&#123;    int x,i,j;    char a[][20] = &#123;        &quot;&quot;,        &quot;Monday&quot;,        &quot;Tuesday&quot;,        &quot;Wednesday&quot;,        &quot;Thursday&quot;,        &quot;Friday&quot;,        &quot;Saturday&quot;,        &quot;Sunday&quot;,    &#125;;    printf(&quot;Please input the month：\\n&quot;);    scanf(&quot;%d&quot;,&amp;x);    if (x &gt; 0 &amp;&amp; x &lt; 8) &#123;        printf(&quot;%s&quot;,a[x]);    &#125;    else printf(&quot;Error&quot;);    printf(&quot;\\n&quot;);    return 0;&#125;\n\n\nNote that input characters with %s that encounter a SPACE, RNTER, and TAB end the string input, so C provides the input function gets() and the output function puts() that are best for strings.\n\ngets(char *s[]) function is to enter a string from the keyboard that can contain Spaces and end with a ENTER newline character.\nputs(char *s[]) or puts(string s)function prints a string from the character array to the screen and converts the end-of-string flag to a newline character.\nIn addition, when %s prints a string, it keeps one dimension, and the compiler automatically inputs or outputs all strings in that dimension. Gets is the same as puts.\nInput and output of character dataPutchar(parameter)Paremeters can be numerical values, character constants, character variables, and arithmetic or character expressions, but the final output is a character.\ngetchar()Type a character from the keyboard.\nString functionstrlen#include&lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[])&#123;       char line[] = &quot;hello&quot;;    printf(&quot;%lu\\n&quot;, strlen(line));    printf(&quot;%lu\\n&quot;, sizeof(line));    return 0;&#125;\n\nThe running result is:\n56\n\nSo strlen is string Length, which returns the length of the string.\nstrcmpThe function is to compare the size of two strings, and the result of the comparison is expressed by the value returned. 0 means they are equal, 1 means the former greater, and -1 means the latter greater.\nstrcpyIt means string copy，the format is：\nchar *strcpy(char *restrict dst, const *restrict src);\n\nIts function is to copy the src string to dst.restrict means that src and dst cannot overlap.The source is in the back, and the copying destination is in the front.Return dst so that the function itself can be evaluated.General usage:\nchar *dst = (char)malloc(strlen(src)+1);strcpy (dst,src)\n\nstrcatThe function is to link one string to another string.\n\nAnother version:\nchar *strncpy(char *restrict dst, const *restrict src,size_t n);char *strncat(char *restrict s1, const *restrict s2,size_t n);int strncmp(const char *s1, const char *s2, size_t n);\n\nThe first two are to limit the length of the copied string, eliminating security issues that are neither out of bounds.\nThe last one is to compare the first n characters.\n\nstrchrTo find a character in a string.\n#include&lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123;    char s[] = &quot;hello,world!&quot;;    char *p = strchr(s,&#x27;l&#x27;);    printf(&quot;%s\\n&quot;,p);    char c = *p;    *p = &#x27;\\0&#x27;;    printf(&quot;%c\\n&quot;,c);    char *p3 = (void*)malloc(strlen(s)+1);    strcpy(p3, s);    printf(&quot;%s\\n&quot;,p3);    free(p3);    char *p1 = strchr((p+1), &#x27;l&#x27;);    char *p2 = strchr((p1+1), &#x27;l&#x27;);    printf(&quot;%s\\n&quot;,p1);    printf(&quot;%s\\n&quot;,p2);    return 0;&#125;\n\nThe running results are as follows:\nllo,world!lhelo,world!ld!\n\nEnumerationenum type &#123;num_0,num_1,num_2,……,num_n&#125;;\n\nYou can use the name in curly braces, where num_0 through num_n represents the constants 0 through n.\nFor instance:\nenum colors &#123;red,yellow,green&#125;;// Here，red == 0, yellow == 1, green == 2 \n\nenum type &#123;num_0,num_1,num_2,……,num_n, number of type&#125;;\n\nThat’s just right. The last number of type is exactly the number of type. It’s a little trick.\nData structure#include &lt;stdio.h&gt;struct date &#123;    int day;    int month;    int year;&#125;;//Structure type Declarationstruct date &#123; int day; int month; int year;&#125; today;//This is another formint main()&#123;    struct date today;    today.day = 25;    today.month = 3;    today.year = 2021;   today = (struct date)&#123;25,3,2021&#125;;    printf(&quot;Today is %i-%i-%i.\\n&quot;,           today.year,today.month,today.day);    return 0;&#125;\n\nThis means that you declare a data structure type, and when you use it, you define a variable that contains all the variables in the data structure.\nThe structure members of a data structure do not have to be of the same variable type, and an array can only be of one type.\nData structures can perform structure operations .\nAssigning values to or between structure variables is a one-to-one correspondence; the former requires curly braces.\nThe name of the structure variable is not the address of the structure variable, so you need to define the pointer using &amp;.\nA data structure can be entered as a function parameter, but unlike an array, the entire structure is passed into the function as the value of the parameter, creating a new structure variable inside the function and copying the value of the caller’s structure.\nYou can also return a struct.\nCustom data typesA typedef can give an alias to a data type.\ntypedef long int64_t;typedef struct ADate &#123; int month; int day; int year;&#125; Date;int64_t i = 100000000000;Date d = &#123;9, 1, 2005, &#125;;\n\nUnion带参数的宏一定要有括号，结尾不能加分号。\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","c"]},{"title":"JAVA","url":"/2022/05/25/note/Programming/Language/Java/","content":"\n\n\n📚  学习 Java 过程中的笔记和个人理解。\n\n\n\n包裹类型Java的系统类库中有一些包裹类型，其封装了一些比较好用的函数。\npackage com.company;//import javax.swing.*;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        final int SIZE = 3;        Integer a;        System.out.println(Integer.MIN_VALUE);        System.out.println(Integer.MAX_VALUE);        System.out.println(Character.isDigit(&#x27;a&#x27;));        System.out.println(Character.isDigit(&#x27;4&#x27;));        System.out.println(Character.toLowerCase(&#x27;I&#x27;));    &#125;&#125;\n\n输出结果为：\n-21474836482147483647falsetruei\n\nMath 类型abs\npackage com.company;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        System.out.println(Math.abs(-12));    &#125;&#125;\n\n输出结果为放入数字的绝对值：\n12\n\nround\npackage com.company;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        System.out.println(Math.round(10.349));    &#125;&#125;\n\n输出结果为将浮点数的小数部分四舍五入后得到的结果：\n10\n\nrandom\npackage com.company;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        System.out.println((int)(Math.random()*100));    &#125;&#125;\n\n这是随机产生一个范围为0到1的浮点数，可以通过以上代码得到随机范围内的整数。pow\npackage com.company;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        System.out.println(Math.pow(2, 20));    &#125;&#125;\n\npow是计算某个数的某次方，计算的类型是浮点数：\n1048576.0\n\n输入字符串in.next()：读入一个单词，结束的标志是空格（包括空格，tab，回车）。\nin.nextLine()：读入一整行。\n字符串操作比较两个字符串是否相等： s1.equals(s2)\n比较两个字符串的大小： s1.comnpareTo(s2) ，输出结果是数字，负数，正数，或者零。其本质是将两个字符串对应的Unicode码分别相加再将二者相减。\n访问字符串中的单个字符： s.charAt(index) ，返回在index上的单个字符，index的范围是0到length()-1，第一个字符的index是0,与数组相同。但是不能用for-each循环来遍历字符串。\n得到子串： s.substring(n) ，得到从n 号位置到末尾的全部内容；s.substring(b,e) 得到从b 号位置到e 号位置之前的内容。\n寻找字符： s.indexOf(c) ，找到字符c 所在的位置，-1 表示不存在；s.indexOf(c,n) ，从n号位置开始寻找c ；s.indexOf(t) ，找到字符串t 所在的位置；s.lastIndexOf(c) , s.lastIndexOf(c,n) , s.lastIndexOf(t) ，从&#x3D;&#x3D;右边&#x3D;&#x3D;开始找。返回值都是所找到的位置。\n当需要寻找的字符存在数量不止一个时，可用以下代码将其全部找出：\npackage com.company;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        String s = new String(&quot;12455323412198467182371263142867351923107241&quot;);        for (int i = -1; i &lt; s.length(); )        &#123;            i = s.indexOf(&#x27;2&#x27;, i+1);            if (i == -1)                break;            System.out.println(i);        &#125;    &#125;&#125;\n\n输出结果为：\n16101923283641\n\n成员函数与成员变量成员函数调用自身的成员函数时会自动带上this 。\nJava中本地变量未被赋予初始值则不能被使用。\n构造函数没有返回类型。\n构造函数可以重载。\npackage diyizhou;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        Fraction a = new Fraction(in.nextInt(), in.nextInt());        Fraction b = new Fraction(in.nextInt(),in.nextInt());        a.print();        b.print();        a.plus(b).print();        a.multiply(b).plus(new Fraction(5,6)).print();        a.print();        b.print();        System.out.println(a.toDouble());        in.close();    &#125;&#125;class Fraction &#123;    int denominator = 0;    int numberator = 0;    Fraction(int numberator, int denominator)    &#123;        if (denominator &gt; 0)&#123;            this.denominator = denominator;            this.numberator = numberator;        &#125;        else&#123;            System.out.println(&quot;分母必须为大于零的数！&quot;);            System.exit(0);        &#125;    &#125;    double toDouble()    &#123;        return numberator*1.0/denominator;    &#125;    Fraction plus(Fraction r)    &#123;        if (r.denominator != this.denominator)        &#123;            return new Fraction(this.numberator*r.denominator + this.denominator*r.numberator, this.denominator*r.denominator);        &#125;        else        &#123;            return new Fraction(this.numberator + r.numberator, this.denominator);        &#125;    &#125;    Fraction multiply(Fraction r)    &#123;        return new Fraction(this.numberator*r.numberator, this.denominator*r.denominator);    &#125;    void print() &#123;        int min;        if (this.denominator != 0 &amp;&amp; this.numberator == this.denominator) &#123;            System.out.println(&quot;1&quot;);            return;        &#125;        else if (numberator == 0)        &#123;            System.out.println(&quot;0&quot;);            return;        &#125;        else        &#123;            min = Math.min(this.numberator, this.denominator);        &#125;        if (min &gt; 1)&#123;            for (int i = 2; i &lt;= min; i++) &#123;                if (this.numberator % i == 0 &amp;&amp; this.denominator % i == 0)                &#123;                    this.numberator /= i;                    this.denominator /= i;                    i = 2;                &#125;            &#125;        &#125;        System.out.println(this.numberator + &quot;/&quot; + this.denominator);    &#125;&#125;\n\n对象的交互通过同一个类创建了两个对象，那么两个对象应该是相互独立的，为了使两个对象有交互作用，就必须有“第三只手”来操作，那便是使一个新的类包含这两个对象，也就是说在新类中创建两个需要使用的对象，通过新类来在操作两个对象的交互。\npackage clock;public class Display &#123;    private int value = 0;    private int limit = 0;    Display(int limit)&#123;        this.limit = limit;    &#125;    public void increase()    &#123;        value ++;        if (value == limit)        &#123;            value = 0;        &#125;    &#125;    public int getValue()&#123;        return value;    &#125;    public static void main(String[] args) &#123;     Display h = new Display(24);        for (;;)        &#123;            h.increase();            System.out.println(h.getValue());        &#125;    &#125;&#125;\n\npackage clock;public class Clock &#123;    private Display hour = new Display(24);    private Display minute = new Display(60);    public void start ()    &#123;        while (true)&#123;            minute.increase();            if ( minute.getValue() == 0)            &#123;                hour.increase();            &#125;            System.out.printf(&quot;%02d:%02d\\n&quot;, hour.getValue(), minute.getValue());        &#125;    &#125;    public static void main(String[] args)    &#123;        Clock clock = new Clock();        clock.start();    &#125;&#125;\n\n访问权限成员变量应当是私有的，用以保护成员变量不被外界随意的修改，让其按照类的设计者的意图运作。\nprivate：只类内可以访问，但同一个类的不同对象也能访问，类内指的是类的成员函数和定义初始化。\npublic： 随意访问。\nfriendly： 未加访问权限，则默认是friendly，意思是只允许在同一个包的其他类访问。\npublic的类可以在别的编译单元中使用。\npublic的类必须在自己的文件中，即文件名与类名必须相同。\n一个编译单元中只能有一个类是public，这是为了让每一个编译单元都有单一的公共接口，用public类来表现，该接口可以按要求包含众多支持包访问权限的类。\nStaticstatic：JAVA中的类变量与C++中的静态成员变量相似，类变量属于类而不属于任何一个单一的对象，同一个类的类变量改变之后，无论以那种方式访问类变量，其值都是一样的。\n\n函数前的static意为此函数不属于任何对象，而是属于这个类。static函数中可以直接调用或使用对象其他的static函数，但对于非static函数，只能通过对象调用。但是在static函数中调用的static函数里也不能直接访问非static成员。\n类函数中没有this, 因为this是用于标识究竟是哪个对象在调用或访问。\n\n继承与多态Java中的对象变量都是多态的，能保存不止一种类型的对象。比如声明类型的对象或者其子类的对象。事实上，多态的本质是为了解决类型嵌套的问题。\n向上造型： 当把子类的对象赋给父类的变量的时候，就发生了向上造型。\n造型子类的对象可以赋值给父类的变量，但父类的对象不能赋值给子类的变量。\n造型时并没有转换类型，而是指针重新指向另一个类型。\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","Java"]},{"title":"C Plus Plus - Basic","url":"/2022/05/25/note/Programming/Language/cpp-1/","content":"\n📚  学习c++过程中的一些笔记和个人想法，用以查找\n\n\n\n\n一、初识1.1 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码\n两种格式\n\n单行注释：// 描述信息\n通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明\n\n\n多行注释： /* 描述信息 */\n通常放在一段代码的上方，对该段代码做整体说明\n\n\n\n\n提示：编译器在编译代码时，会忽略注释的内容\n\n1.3 变量作用：给一段指定的内存空间起名，方便操作这段内存\n语法：数据类型 变量名 = 初始值;\n示例：\n#include&lt;iostream&gt;using namespace std;int main() &#123;    //变量的定义    //语法：数据类型  变量名 = 初始值    int a = 10;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n\n\n注意：cpp在创建变量时，必须给变量一个初始值，否则会报错\n\n1.4  常量作用 ：用于记录程序中不可更改的数据cpp定义常量两种方式\n\n#define 宏常量： #define 常量名 常量值\n通常在文件上方定义，表示一个常量\n\n\nconst 修饰的变量 const 数据类型 常量名 = 常量值\n通常在变量定义前加关键字const，修饰该变量为常量，不可修改示例：\n\n\n\n//1、宏常量#define day 7int main() &#123;    cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl;    //day = 8;  //报错，宏常量不可以修改    //2、const修饰变量    const int month = 12;    cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl;    //month = 24; //报错，常量是不可以修改的    return 0;&#125;\n\n1.5 关键字作用： 关键字是 cpp中预先保留的单词（标识符）\n\n在定义变量或者常量时候，不要用关键字\n\ncpp关键字如下：\n\n提示：在给变量或者常量起名称时候，不要用 cpp得关键字，否则会产生歧义\n\n1.6 标识符命名规则作用：cpp规定给标识符（变量、常量）命名时，有一套自己的规则\n\n标识符不能是关键字\n标识符只能由字母、数字、下划线组成\n第一个字符必须为字母或下划线\n标识符中字母区分大小写\n\n\n建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读\n\n二、数据类型cpp规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存\n2.1 整型作用：整型变量表示的是整数类型的数据cpp中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n\n\n\n数据类型\n占用空间\n取值范围\n\n\n\nshort(短整型)\n2字节\n(-2^15 ~ 2^15-1)\n\n\nint(整型)\n4字节\n(-2^31 ~ 2^31-1)\n\n\nlong(长整形)\nWindows为4字节，Linux为4字节(32位)，8字节(64位)\n(-2^31 ~ 2^31-1)\n\n\nlong long(长长整形)\n8字节\n(-2^63 ~ 2^63-1)\n\n\n2.2 sizeof关键字作用： 利用sizeof关键字可以统计数据类型所占内存大小\n语法： sizeof( 数据类型 / 变量)\n示例：\nint main() &#123;    cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;    cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;    cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;    cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;    return 0;&#125;\n\n\n结论：short &lt; int &lt;&#x3D; long &lt;&#x3D; long long\n\n2.3 实型（浮点型）作用：用于表示小数浮点型变量分为两种：\n\n单精度float\n\n双精度double两者的区别在于表示的有效数字范围不同。\n\n\n\n数据类型\n占用空间\n有效数字范围\n\n\n\nfloat\n4字节\n7位有效数字\n\n\ndouble\n8字节\n15～16位有效数字\n\n\n示例：\n\n\n\n\n\n\nint main() &#123;    float f1 = 3.14f;    double d1 = 3.14;    cout &lt;&lt; f1 &lt;&lt; endl;    cout &lt;&lt; d1&lt;&lt; endl;    cout &lt;&lt; &quot;float  sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl;    cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl;    //科学计数法    float f2 = 3e2; // 3 * 10 ^ 2    cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl;    float f3 = 3e-2;  // 3 * 0.1 ^ 2    cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl;    return 0;&#125;\n\n2.4 字符型作用： 字符型变量用于显示单个字符语法： char ch = &#39;a&#39;;\n\n注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号注意2：单引号内只能有一个字符，不可以是字符串\n\n\nc和cpp中字符型变量只占用1个字节。\n字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元示例：\n\nint main() &#123;    char ch = &#x27;a&#x27;;    cout &lt;&lt; ch &lt;&lt; endl;    cout &lt;&lt; sizeof(char) &lt;&lt; endl;    //ch = &quot;abcde&quot;; //错误，不可以用双引号    //ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符    cout &lt;&lt; (int)ch &lt;&lt; endl;  //查看字符a对应的ASCII码    ch = 97; //可以直接用ASCII给字符型变量赋值    cout &lt;&lt; ch &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;\n\nASCII码表格：\n\n\n\nASCII值\n控制字符\nASCII值\n字符\nASCII值\n字符\nASCII值\n字符\n\n\n\n0\nNUT\n32\n(space)\n64\n@\n96\n、\n\n\n1\nSOH\n33\n!\n65\nA\n97\na\n\n\n2\nSTX\n34\n“\n66\nB\n98\nb\n\n\n3\nETX\n35\n#\n67\nC\n99\nc\n\n\n4\nEOT\n36\n$\n68\nD\n100\nd\n\n\n5\nENQ\n37\n%\n69\nE\n101\ne\n\n\n6\nACK\n38\n&amp;\n70\nF\n102\nf\n\n\n7\nBEL\n39\n,\n71\nG\n103\ng\n\n\n8\nBS\n40\n(\n72\nH\n104\nh\n\n\n9\nHT\n41\n)\n73\nI\n105\ni\n\n\n10\nLF\n42\n*\n74\nJ\n106\nj\n\n\n11\nVT\n43\n+\n75\nK\n107\nk\n\n\n12\nFF\n44\n,\n76\nL\n108\nl\n\n\n13\nCR\n45\n-\n77\nM\n109\nm\n\n\n14\nSO\n46\n.\n78\nN\n110\nn\n\n\n15\nSI\n47\n&#x2F;\n79\nO\n111\no\n\n\n16\nDLE\n48\n0\n80\nP\n112\np\n\n\n17\nDCI\n49\n1\n81\nQ\n113\nq\n\n\n18\nDC2\n50\n2\n82\nR\n114\nr\n\n\n19\nDC3\n51\n3\n83\nS\n115\ns\n\n\n20\nDC4\n52\n4\n84\nT\n116\nt\n\n\n21\nNAK\n53\n5\n85\nU\n117\nu\n\n\n22\nSYN\n54\n6\n86\nV\n118\nv\n\n\n23\nTB\n55\n7\n87\nW\n119\nw\n\n\n24\nCAN\n56\n8\n88\nX\n120\nx\n\n\n25\nEM\n57\n9\n89\nY\n121\ny\n\n\n26\nSUB\n58\n:\n90\nZ\n122\nz\n\n\n27\nESC\n9\n;\n91\n[\n123\n{\n\n\nASCII 码大致由以下两部分组成：\n\nASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。\nASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。\n\n2.5 转义字符作用： 用于表示一些不能显示出来的ASCII字符现阶段我们常用的转义字符有：\\n  \\\\  \\t\n\n\n\n转义字符\n含义\nASCII码值（十进制）\n\n\n\n\\a\n警报\n007\n\n\n\\b\n退格(BS) ，将当前位置移到前一列\n008\n\n\n\\f\n换页(FF)，将当前位置移到下页开头\n012\n\n\n\\n\n换行(LF) ，将当前位置移到下一行开头\n010\n\n\n\\r\n回车(CR) ，将当前位置移到本行开头\n013\n\n\n\\t\n水平制表(HT)  （跳到下一个TAB位置）\n009\n\n\n\\v\n垂直制表(VT)\n011\n\n\n\\\\\n代表一个反斜线字符”&quot;\n092\n\n\n&#39;\n代表一个单引号（撇号）字符\n039\n\n\n&quot;\n代表一个双引号字符\n034\n\n\n?\n代表一个问号\n063\n\n\n\\0\n数字0\n000\n\n\n\\ddd\n8进制转义字符，d范围0~7\n3位8进制\n\n\n\\xhh\n16进制转义字符，h范围09，af，A~F\n3位16进制\n\n\n示例：\n\n\n\n\nint main() &#123;    cout &lt;&lt; &quot;\\\\&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\\tHello&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\\n&quot; &lt;&lt; endl;    return 0;&#125;\n\n2.6 字符串型作用：用于表示一串字符两种风格\n\nC风格字符串： char 变量名[] = &quot;字符串值&quot;示例：\n\nint main() &#123;    char str1[] = &quot;hello world&quot;;    cout &lt;&lt; str1 &lt;&lt; endl;    return 0;&#125;```    &gt; 注意：C风格的字符串要用双引号括起来    2. **cpp风格字符串**：  `string  变量名 = &quot;字符串值&quot;`    示例：    ```cpp    int main() &#123;    string str = &quot;hello world&quot;;    cout &lt;&lt; str &lt;&lt; endl;    return 0;&#125;\n\n\n注意：cpp风格字符串，需要加入头文件#include &lt;string&gt;\n\n2.7 布尔类型 bool作用： 布尔数据类型代表真或假的值bool类型只有两个值：\n\ntrue  — 真（本质是1）\nfalse — 假（本质是0）bool类型占1个字节大小示例：\n\nint main() &#123;    bool flag = true;    cout &lt;&lt; flag &lt;&lt; endl; // 1    flag = false;    cout &lt;&lt; flag &lt;&lt; endl; // 0    cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1    return 0;&#125;\n\n2.8 数据的输入作用：用于从键盘获取数据语法： cin &gt;&gt; 变量示例：\nint main()&#123;    //整型输入    int a = 0;    cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl;    cin &gt;&gt; a;    cout &lt;&lt; a &lt;&lt; endl;    //浮点型输入    double d = 0;    cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl;    cin &gt;&gt; d;    cout &lt;&lt; d &lt;&lt; endl;    //字符型输入    char ch = 0;    cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl;    cin &gt;&gt; ch;    cout &lt;&lt; ch &lt;&lt; endl;    //字符串型输入    string str;    cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl;    cin &gt;&gt; str;    cout &lt;&lt; str &lt;&lt; endl;    //布尔类型输入    bool flag = true;    cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl;    cin &gt;&gt; flag;    cout &lt;&lt; flag &lt;&lt; endl;    system(&quot;pause&quot;);    return EXIT_SUCCESS;&#125;\n\n三、运算符作用: 用于执行代码的运算本章我们主要讲解以下几类运算符：\n\n\n\n运算符类型\n作用\n\n\n\n算术运算符\n用于处理四则运算\n\n\n赋值运算符\n用于将表达式的值赋给变量\n\n\n比较运算符\n用于表达式的比较，并返回一个真值或假值\n\n\n逻辑运算符\n用于根据表达式的值返回真值或假值\n\n\n3.1 算术运算符作用： 用于处理四则运算算术运算符包括以下符号：\n\n\n\n运算符\n术语\n示例\n结果\n\n\n\n+\n正号\n+3\n3\n\n\n-\n负号\n-3\n-3\n\n\n+\n加\n10 + 5\n15\n\n\n-\n减\n10 - 5\n5\n\n\n*\n乘\n10 * 5\n50\n\n\n&#x2F;\n除\n10 &#x2F; 5\n2\n\n\n%\n取模(取余)\n10 % 3\n1\n\n\n++\n前置递增\na&#x3D;2; b&#x3D;++a;\na&#x3D;3; b&#x3D;3;\n\n\n++\n后置递增\na&#x3D;2; b&#x3D;a++;\na&#x3D;3; b&#x3D;2;\n\n\n–\n前置递减\na&#x3D;2; b&#x3D;–a;\na&#x3D;1; b&#x3D;1;\n\n\n–\n后置递减\na&#x3D;2; b&#x3D;a–;\na&#x3D;1; b&#x3D;2;\n\n\n示例1：\n\n\n\n\n\n//加减乘除int main() &#123;    int a1 = 10;    int b1 = 3;    cout &lt;&lt; a1 + b1 &lt;&lt; endl;    cout &lt;&lt; a1 - b1 &lt;&lt; endl;    cout &lt;&lt; a1 * b1 &lt;&lt; endl;    cout &lt;&lt; a1 / b1 &lt;&lt; endl;  //两个整数相除结果依然是整数    int a2 = 10;    int b2 = 20;    cout &lt;&lt; a2 / b2 &lt;&lt; endl;    int a3 = 10;    int b3 = 0;    //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0    //两个小数可以相除    double d1 = 0.5;    double d2 = 0.25;    cout &lt;&lt; d1 / d2 &lt;&lt; endl;    return 0;&#125;\n\n\n总结：在除法运算中，除数不能为0示例2：\n\n//取模int main() &#123;    int a1 = 10;    int b1 = 3;    cout &lt;&lt; 10 % 3 &lt;&lt; endl;    int a2 = 10;    int b2 = 20;    cout &lt;&lt; a2 % b2 &lt;&lt; endl;    int a3 = 10;    int b3 = 0;    //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0    //两个小数不可以取模    double d1 = 3.14;    double d2 = 1.1;    //cout &lt;&lt; d1 % d2 &lt;&lt; endl;    return 0;&#125;\n\n\n总结：只有整型变量可以进行取模运算示例3：\n\n//递增int main() &#123;    //后置递增    int a = 10;    a++; //等价于a = a + 1    cout &lt;&lt; a &lt;&lt; endl; // 11    //前置递增    int b = 10;    ++b;    cout &lt;&lt; b &lt;&lt; endl; // 11    //区别    //前置递增先对变量进行++，再计算表达式    int a2 = 10;    int b2 = ++a2 * 10;    cout &lt;&lt; b2 &lt;&lt; endl;    //后置递增先计算表达式，后对变量进行++    int a3 = 10;    int b3 = a3++ * 10;    cout &lt;&lt; b3 &lt;&lt; endl;    return 0;&#125;\n\n\n总结：前置递增先对变量进行++，再计算表达式，后置递增相反\n\n3.2 赋值运算符作用： 用于将表达式的值赋给变量赋值运算符包括以下几个符号：\n\n\n\n运算符\n术语\n示例\n结果\n\n\n\n&#x3D;\n赋值\na&#x3D;2; b&#x3D;3;\na&#x3D;2; b&#x3D;3;\n\n\n+&#x3D;\n加等于\na&#x3D;0; a+&#x3D;2;\na&#x3D;2;\n\n\n-&#x3D;\n减等于\na&#x3D;5; a-&#x3D;3;\na&#x3D;2;\n\n\n*&#x3D;\n乘等于\na&#x3D;2; a*&#x3D;2;\na&#x3D;4;\n\n\n&#x2F;&#x3D;\n除等于\na&#x3D;4; a&#x2F;&#x3D;2;\na&#x3D;2;\n\n\n%&#x3D;\n模等于\na&#x3D;3; a%2;\na&#x3D;1;\n\n\n示例：\n\n\n\n\n\nint main() &#123;    //赋值运算符    // =    int a = 10;    a = 100;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    // +=    a = 10;    a += 2; // a = a + 2;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    // -=    a = 10;    a -= 2; // a = a - 2    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    // *=    a = 10;    a *= 2; // a = a * 2    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    // /=    a = 10;    a /= 2;  // a = a / 2;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    // %=    a = 10;    a %= 2;  // a = a % 2;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n\n3.3 比较运算符作用：用于表达式的比较，并返回一个真值或假值比较运算符有以下符号：\n\n\n\n运算符\n术语\n示例\n结果\n\n\n\n***\n相等于\n4 *** 3\n0\n\n\n!&#x3D;\n不等于\n4 !&#x3D; 3\n1\n\n\n&lt;\n小于\n4 &lt; 3\n0\n\n\n&gt;\n大于\n4 &gt; 3\n1\n\n\n&lt;&#x3D;\n小于等于\n4 &lt;&#x3D; 3\n0\n\n\n&gt;&#x3D;\n大于等于\n4 &gt;&#x3D; 1\n1\n\n\n示例：\n\n\n\n\n\nint main() &#123;    int a = 10;    int b = 20;    cout &lt;&lt; (a *** b) &lt;&lt; endl; // 0    cout &lt;&lt; (a != b) &lt;&lt; endl; // 1    cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0    cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1    cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0    cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1    return 0;&#125;\n\n\n注意：C和cpp 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。\n\n3.4 逻辑运算符作用： 用于根据表达式的值返回真值或假值逻辑运算符有以下符号：\n\n\n\n运算符\n术语\n示例\n结果\n\n\n\n!\n非\n!a\n如果a为假，则!a为真；  如果a为真，则!a为假。\n\n\n&amp;&amp;\n与\na &amp;&amp; b\n如果a和b都为真，则结果为真，否则为假。\n\n\n\\\n\\\n\n或\n\n\n示例1： 逻辑非\n\n\n\n\n\n//逻辑运算符  --- 非int main() &#123;    int a = 10;    cout &lt;&lt; !a &lt;&lt; endl; // 0    cout &lt;&lt; !!a &lt;&lt; endl; // 1    return 0;&#125;\n\n\n非：真变假，假变真示例2： 逻辑与\n\n//逻辑运算符  --- 与int main() &#123;    int a = 10;    int b = 10;    cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1    a = 10;    b = 0;    cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0    a = 0;    b = 0;    cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0    return 0;&#125;\n\n\n与： 同时真则为真，否则皆为假示例3：逻辑或\n\n//逻辑运算符  --- 或int main() &#123;    int a = 10;    int b = 10;    cout &lt;&lt; (a || b) &lt;&lt; endl;// 1    a = 10;    b = 0;    cout &lt;&lt; (a || b) &lt;&lt; endl;// 1    a = 0;    b = 0;    cout &lt;&lt; (a || b) &lt;&lt; endl;// 0    return 0;&#125;\n\n\n或：同时为假则假，否则为真\n\n四、程序流程结构C&#x2F;cpp支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构\n\n顺序结构： 程序按顺序执行，不发生跳转\n选择结构： 依据条件是否满足，有选择的执行相应功能\n循环结构： 依据条件是否满足，循环多次执行某段代码\n\n4.1 选择结构4.1.1 if语句作用： 执行满足条件的语句if语句的三种形式\n\n单行格式if语句\n\n多行格式if语句\n\n多条件的if语句\n\n\n\n单行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125;示例：\nint main() &#123;    //选择结构-单行if语句    //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印    int score = 0;    cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl;    cin &gt;&gt; score;    cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl;    //if语句    //注意事项，在if判断语句后面，不要加分号    if (score &gt; 600)    &#123;        cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n注意：if条件表达式后不要加分号\n\n\n多行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;示例：\n\nint main() &#123;    int score = 0;    cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;    cin &gt;&gt; score;    if (score &gt; 600)    &#123;        cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n多条件的if语句：if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;示例：\n\nint main() &#123;    int score = 0;    cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;    cin &gt;&gt; score;    if (score &gt; 600)    &#123;        cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;    &#125;    else if (score &gt; 500)    &#123;        cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;    &#125;    else if (score &gt; 400)    &#123;        cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断案例需求：\n\n提示用户输入一个高考考试分数，根据分数做如下判断\n分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；\n在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。示例：\n\nint main() &#123;    int score = 0;    cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;    cin &gt;&gt; score;    if (score &gt; 600)    &#123;        cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;        if (score &gt; 700)        &#123;            cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl;        &#125;        else if (score &gt; 650)        &#123;            cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl;        &#125;    &#125;    else if (score &gt; 500)    &#123;        cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;    &#125;    else if (score &gt; 400)    &#123;        cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n练习案例： 三只小猪称体重有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？\n4.1.2 三目运算符作用： 通过三目运算符实现简单的判断语法：表达式1 ? 表达式2 ：表达式3解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果；如果表达式1的值为假，执行表达式3，并返回表达式3的结果。示例：\nint main() &#123;    int a = 10;    int b = 20;    int c = 0;    c = a &gt; b ? a : b;    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;    //cpp中三目运算符返回的是变量,可以继续赋值    (a &gt; b ? a : b) = 100;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;    return 0;&#125;\n\n\n总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰\n\n4.1.3 switch语句作用： 执行多条件分支语句语法：\nswitch(表达式)&#123;    case 结果1：执行语句;break;    case 结果2：执行语句;break;        ...            default:执行语句;break;&#125;\n\n示例：\nint main() &#123;    //请给电影评分    //10 ~ 9   经典    // 8 ~ 7   非常好    // 6 ~ 5   一般    // 5分以下 烂片    int score = 0;    cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl;    cin &gt;&gt; score;    switch (score)    &#123;        case 10:        case 9:            cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl;            break;        case 8:            cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl;            break;        case 7:        case 6:            cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;            break;        default:            cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl;            break;    &#125;    return 0;&#125;\n\n\n注意1：switch语句中表达式类型只能是整型或者字符型!注意2：case里如果没有break，那么程序会一直向下执行总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间\n\n4.2 循环结构4.2.1 while循环语句作用： 满足循环条件，执行循环语句语法： while(循环条件)&#123; 循环语句 &#125;解释： 只要循环条件的结果为真，就执行循环语句示例：\nint main() &#123;    int num = 0;    while (num &lt; 10)    &#123;        cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;        num++;    &#125;    return 0;&#125;\n\n\n注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环while循环练习案例： 猜数字案例描述： 系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。\n\n#include &quot;xr.cpp&quot;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;ostream&gt;#include &lt;random&gt;int main(int, char **) &#123;    srand(time(0));    auto answer = rand() % 100;    auto theNumber = 0;    while (std::cin &gt;&gt; theNumber) &#123;        if (theNumber &lt;= 0 || theNumber &gt;= 100) &#123;            std::cout &lt;&lt; &quot;Please input a number at 1 ~ 99!&quot; &lt;&lt; std::endl;        &#125; else &#123;            if (theNumber &gt; answer) &#123;                std::cout &lt;&lt; &quot;The number you input is too large!&quot; &lt;&lt; std::endl;            &#125; else if (theNumber &lt; answer) &#123;                std::cout &lt;&lt; &quot;The number you input is too small!&quot; &lt;&lt; std::endl;            &#125; else &#123;                std::cout &lt;&lt; &quot;Congratulation!&quot; &lt;&lt; std::endl;                return 0;            &#125;        &#125;    &#125;&#125;\n\n4.2.2 do…while循环语句作用： 满足循环条件，执行循环语句语法： do&#123; 循环语句 &#125; while(循环条件);注意： 与while的区别在于do…while会先执行一次循环语句，再判断循环条件示例：\nint main() &#123;    int num = 0;    do    &#123;        cout &lt;&lt; num &lt;&lt; endl;        num++;    &#125; while (num &lt; 10);    system(&quot;pause&quot;);    return 0;&#125;\n\n\n总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件\n\n\n练习案例：水仙花数案例描述： 水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身例如：1^3 + 5^3+ 3^3 &#x3D; 153请利用do…while语句，求出所有3位数中的水仙花数\n\n4.2.3 for循环语句作用： 满足循环条件，执行循环语句语法：for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;示例：\nint main() &#123;    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; i &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n注意：for循环中的表达式，要用分号进行分隔总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用练习案例：敲桌子案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。\n\n4.2.4 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题示例：\nint main() &#123;    //外层循环执行1次，内层循环执行1轮    for (int i = 0; i &lt; 10; i++)    &#123;        for (int j = 0; j &lt; 10; j++)        &#123;            cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    return 0;&#125;\n\n练习案例： 乘法口诀表\n4.3 跳转语句4.3.1 break语句作用: 用于跳出选择结构或者循环结构break使用的时机：\n\n出现在switch条件语句中，作用是终止case并跳出switch\n出现在循环语句中，作用是跳出当前的循环语句\n出现在嵌套循环中，跳出最近的内层循环语句示例1：\n\nint main() &#123;    //1、在switch 语句中使用break    cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl;    int num = 0;    cin &gt;&gt; num;    switch (num)    &#123;        case 1:            cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl;            break;        case 2:            cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl;            break;        case 3:            cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl;            break;    &#125;    return 0;&#125;\n\n示例2：\nint main() &#123;    //2、在循环语句中用break    for (int i = 0; i &lt; 10; i++)    &#123;        if (i *** 5)        &#123;            break; //跳出循环语句        &#125;        cout &lt;&lt; i &lt;&lt; endl;    &#125;    return 0;&#125;\n\n示例3：\nint main() &#123;    //在嵌套循环语句中使用break，退出内层循环    for (int i = 0; i &lt; 10; i++)    &#123;        for (int j = 0; j &lt; 10; j++)        &#123;            if (j *** 5)            &#123;                break;            &#125;            cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    return 0;&#125;\n\n4.3.2 continue语句作用： 在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环示例：\nint main() &#123;    for (int i = 0; i &lt; 100; i++)    &#123;        if (i % 2 *** 0)        &#123;            continue;        &#125;        cout &lt;&lt; i &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n注意：continue并没有使整个循环终止，而break会跳出循环\n\n4.3.3 goto语句作用： 可以无条件跳转语句语法：  goto 标记;解释： 如果标记的名称存在，执行到goto语句时，会跳转到标记的位置示例：\nint main() &#123;    cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;    goto FLAG;    cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;    FLAG:    cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;    return 0;&#125;\n\n\n注意：在程序中不建议使用goto语句，以免造成程序流程混乱\n\n五、数组5.1 概述所谓数组，就是一个集合，里面存放了相同类型的数据元素特点1： 数组中的每个数据元素都是相同的数据类型特点2： 数组是由连续的内存位置组成的\n5.2 一维数组5.2.1 一维数组定义方式一维数组定义的三种方式：\n\n数据类型  数组名[ 数组长度 ];\n数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;\n数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;示例：\n\nint main() &#123;    //定义方式1    //数据类型 数组名[元素个数];    int score[10];    //利用下标赋值    score[0] = 100;    score[1] = 99;    score[2] = 85;    //利用下标输出    cout &lt;&lt; score[0] &lt;&lt; endl;    cout &lt;&lt; score[1] &lt;&lt; endl;    cout &lt;&lt; score[2] &lt;&lt; endl;    //第二种定义方式    //数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;    //如果&#123;&#125;内不足10个数据，剩余数据用0补全    int score2[10] = &#123; 100, 90,80,70,60,50,40,30,20,10 &#125;;    //逐个输出    //cout &lt;&lt; score2[0] &lt;&lt; endl;    //cout &lt;&lt; score2[1] &lt;&lt; endl;    //一个一个输出太麻烦，因此可以利用循环进行输出    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; score2[i] &lt;&lt; endl;    &#125;    //定义方式3    //数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;    int score3[] = &#123; 100,90,80,70,60,50,40,30,20,10 &#125;;    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; score3[i] &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名总结2：数组中下标是从0开始索引\n\n5.2.2 一维数组数组名一维数组名称的用途：\n\n可以统计整个数组在内存中的长度\n可以获取数组在内存中的首地址示例：\n\nint main() &#123;    //数组名用途    //1、可以获取整个数组占用内存空间大小    int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;    cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;    cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;    cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;    //2、可以通过数组名获取到数组首地址    cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl;    cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;    cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;    //arr = 100; 错误，数组名是常量，因此不可以赋值    return 0;&#125;\n\n\n注意：数组名是常量，不可以赋值总结1：直接打印数组名，可以查看数组所占内存的首地址总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小\n\n练习案例1：五只小猪称体重案例描述：在一个数组中记录了五只小猪的体重，如：int arr[5] = &#123;300,350,200,400,250&#125;;找出并打印最重的小猪体重。练习案例2： 数组元素逆置案例描述： 请声明一个5个元素的数组，并且将元素逆置.(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);\n5.2.3 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序\n\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。\n重复以上的步骤，每次比较次数-1，直到不需要比较示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序\n\nint main() &#123;    int arr[9] = &#123; 4,2,8,0,5,7,1,3,9 &#125;;    for (int i = 0; i &lt; 9 - 1; i++)    &#123;        for (int j = 0; j &lt; 9 - 1 - i; j++)        &#123;            if (arr[j] &gt; arr[j + 1])            &#123;                int temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; 9; i++)    &#123;        cout &lt;&lt; arr[i] &lt;&lt; endl;    &#125;    return 0;&#125;\n\n5.3 二维数组二维数组就是在一维数组上，多加一个维度。\n5.3.1 二维数组定义方式二维数组定义的四种方式：\n\n数据类型  数组名[ 行数 ][ 列数 ];\n数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;\n数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;\n数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;\n\n\n建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性示例：\n\nint main() &#123;    //方式1    //数组类型 数组名 [行数][列数]    int arr[2][3];    arr[0][0] = 1;    arr[0][1] = 2;    arr[0][2] = 3;    arr[1][0] = 4;    arr[1][1] = 5;    arr[1][2] = 6;    for (int i = 0; i &lt; 2; i++)    &#123;        for (int j = 0; j &lt; 3; j++)        &#123;            cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    //方式2    //数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;    int arr2[2][3] =    &#123;        &#123;1,2,3&#125;,        &#123;4,5,6&#125;    &#125;;    //方式3    //数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;    int arr3[2][3] = &#123; 1,2,3,4,5,6 &#125;;    //方式4    //数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;    int arr4[][3] = &#123; 1,2,3,4,5,6 &#125;;    return 0;&#125;\n\n\n总结：在定义二维数组时，如果初始化了数据，可以省略行数\n\n5.3.2 二维数组数组名\n查看二维数组所占内存空间\n\n获取二维数组首地址示例：\n\n\nint main() &#123;    //二维数组数组名    int arr[2][3] =    &#123;        &#123;1,2,3&#125;,        &#123;4,5,6&#125;    &#125;;    cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;    cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;    cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;    cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;    cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;    //地址    cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;    cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;    cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;    cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;    cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;    return 0;&#125;\n\n\n总结1：二维数组名就是这个数组的首地址总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小\n\n5.3.3 二维数组应用案例考试成绩统计：案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩\n\n\n\n\n语文\n数学\n英语\n\n\n\n张三\n100\n100\n100\n\n\n李四\n90\n50\n100\n\n\n王五\n60\n70\n80\n\n\n参考答案：\n\n\n\n\n\nint main() &#123;    int scores[3][3] =    &#123;        &#123;100,100,100&#125;,        &#123;90,50,100&#125;,        &#123;60,70,80&#125;,    &#125;;    string names[3] = &#123; &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; &#125;;    for (int i = 0; i &lt; 3; i++)    &#123;        int sum = 0;        for (int j = 0; j &lt; 3; j++)        &#123;            sum += scores[i][j];        &#125;        cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl;    &#125;    return 0;&#125;\n\n六、函数6.1 概述作用： 将一段经常使用的代码封装起来，减少重复代码一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。\n6.2 函数的定义函数的定义一般主要有5个步骤：\n\n返回值类型\n函数名\n参数表列\n函数体语句\nreturn 表达式语法：\n\n返回值类型 函数名 （参数列表）&#123;       函数体语句       return表达式&#125;\n\n\n返回值类型 ：一个函数可以返回一个值。在函数定义中\n\n函数名：给函数起个名称\n\n参数列表：使用该函数时，传入的数据\n\n函数体语句：花括号内的代码，函数内需要执行的语句\n\nreturn表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据示例： 定义一个加法函数，实现两个数相加\n\n\n//函数定义int add(int num1, int num2)&#123;    int sum = num1 + num2;    return sum;&#125;\n\n6.3 函数的调用功能： 使用定义好的函数语法： 函数名（参数）示例：\n//函数定义int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参&#123;    int sum = num1 + num2;    return sum;&#125;int main() &#123;    int a = 10;    int b = 10;    //调用add函数    int sum = add(a, b);//调用时的a，b称为实际参数，简称实参    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;    a = 100;    b = 100;    sum = add(a, b);    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;    return 0;&#125;\n\n\n总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参\n\n6.4 值传递\n所谓值传递，就是函数调用时实参将数值传入给形参\n\n值传递时，如果形参发生，并不会影响实参示例：\n\n\nvoid swap(int num1, int num2)&#123;    cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;    cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;    int temp = num1;    num1 = num2;    num2 = temp;    cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;    cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;    //return ; 当函数声明时候，不需要返回值，可以不写return&#125;int main() &#123;    int a = 10;    int b = 20;    swap(a, b);    cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl;    return 0;&#125;\n\n\n总结： 值传递时，形参是修饰不了实参的\n\n6.5 函数的常见样式常见的函数样式有4种\n\n无参无返\n有参无返\n无参有返\n有参有返示例：\n\n//函数常见样式//1、 无参无返void test01()&#123;    //void a = 10; //无类型不可以创建变量,原因无法分配内存    cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl;    //test01(); 函数调用&#125;//2、 有参无返void test02(int a)&#123;    cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;&#125;//3、无参有返int test03()&#123;    cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl;    return 10;&#125;//4、有参有返int test04(int a, int b)&#123;    cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl;    int sum = a + b;    return sum;&#125;\n\n6.6 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n\n函数的声明可以多次，但是函数的定义只能有一次示例：\n\n//声明可以多次，定义只能一次//声明int max(int a, int b);int max(int a, int b);//定义int max(int a, int b)&#123;    return a &gt; b ? a : b;&#125;int main() &#123;    int a = 100;    int b = 200;    cout &lt;&lt; max(a, b) &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;\n\n6.7 函数的分文件编写作用： 让代码结构更加清晰函数分文件编写一般有4个步骤\n\n创建后缀名为.h的头文件\n创建后缀名为.cpp的源文件\n在头文件中写函数的声明\n在源文件中写函数的定义示例：\n\n//swap.h文件#include&lt;iostream&gt;using namespace std;//实现两个数字交换的函数声明void swap(int a, int b);\n\n//swap.cpp文件#include &quot;swap.h&quot;void swap(int a, int b)&#123;    int temp = a;    a = b;    b = temp;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;\n\n//main函数文件#include &quot;swap.h&quot;int main() &#123;    int a = 100;    int b = 200;    swap(a, b);    return 0;&#125;\n\n七、指针7.1 指针的基本概念指针的作用： 可以通过指针间接访问内存\n\n内存编号是从0开始记录的，一般用十六进制数字表示\n可以利用指针变量保存地址\n\n7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名；示例：\nint main() &#123;    //1、指针的定义    int a = 10; //定义整型变量a    //指针定义语法： 数据类型 * 变量名 ;    int * p;    //指针变量赋值    p = &amp;a; //指针指向变量a的地址    cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址    cout &lt;&lt; p &lt;&lt; endl;  //打印指针变量p    //2、指针的使用    //通过*操作指针变量指向的内存    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;    return 0;&#125;\n\n指针变量和普通变量的区别\n\n普通变量存放的是数据,指针变量存放的是地址\n指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用\n\n\n总结1： 我们可以通过 &amp; 符号 获取变量的地址总结2：利用指针可以记录地址总结3：对指针变量解引用，可以操作指针指向的内存\n\n7.3 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？示例：\nint main() &#123;    int a = 10;    int * p;    p = &amp;a; //指针指向数据a的地址    cout &lt;&lt; *p &lt;&lt; endl; //* 解引用    cout &lt;&lt; sizeof(p) &lt;&lt; endl;    cout &lt;&lt; sizeof(char *) &lt;&lt; endl;    cout &lt;&lt; sizeof(float *) &lt;&lt; endl;    cout &lt;&lt; sizeof(double *) &lt;&lt; endl;    return 0;&#125;\n\n\n总结：所有指针类型在32位操作系统下是4个字节\n\n7.4 空指针和野指针空指针：指针变量指向内存中编号为0的空间用途： 初始化指针变量注意： 空指针指向的内存是不可以访问的示例1：空指针\nint main() &#123;    //指针变量p指向内存地址编号为0的空间    int * p = NULL;    //访问空指针报错    //内存编号0 ~255为系统占用内存，不允许用户访问    cout &lt;&lt; *p &lt;&lt; endl;    return 0;&#125;\n\n野指针：指针变量指向非法的内存空间示例2：野指针\nint main() &#123;    //指针变量p指向内存地址编号为0x1100的空间    int * p = (int *)0x1100;    //访问野指针报错    cout &lt;&lt; *p &lt;&lt; endl;    return 0;&#125;\n\n\n总结：空指针和野指针都不是我们申请的空间，因此不要访问。\n\n7.5 const修饰指针const修饰指针有三种情况\n\nconst修饰指针   — 常量指针\nconst修饰常量   — 指针常量\nconst即修饰指针，又修饰常量示例：\n\nint main() &#123;    int a = 10;    int b = 10;    //const修饰的是指针，指针指向可以改，指针指向的值不可以更改    const int * p1 = &amp;a;    p1 = &amp;b; //正确    //*p1 = 100;  报错    //const修饰的是常量，指针指向不可以改，指针指向的值可以更改    int * const p2 = &amp;a;    //p2 = &amp;b; //错误    *p2 = 100; //正确    //const既修饰指针又修饰常量    const int * const p3 = &amp;a;    //p3 = &amp;b; //错误    //*p3 = 100; //错误    return 0;&#125;\n\n\n技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量\n\n7.6 指针和数组作用： 利用指针访问数组中元素示例：\nint main() &#123;    int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;    int * p = arr;  //指向数组的指针    cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl;    cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl;    for (int i = 0; i &lt; 10; i++)    &#123;        //利用指针遍历数组        cout &lt;&lt; *p &lt;&lt; endl;        p++;    &#125;    return 0;&#125;\n\n7.7 指针和函数作用： 利用指针作函数参数，可以修改实参的值示例：\n//值传递void swap1(int a ,int b)&#123;    int temp = a;    a = b;    b = temp;&#125;//地址传递void swap2(int * p1, int *p2)&#123;    int temp = *p1;    *p1 = *p2;    *p2 = temp;&#125;int main() &#123;    int a = 10;    int b = 20;    swap1(a, b); // 值传递不会改变实参    swap2(&amp;a, &amp;b); //地址传递会改变实参    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    return 0;&#125;\n\n\n总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递\n\n7.8 指针、数组、函数案例描述： 封装一个函数，利用冒泡排序，实现对整型数组的升序排序例如数组：int arr[10] = &#123; 4,3,6,9,1,2,10,8,7,5 &#125;;示例：\n//冒泡排序函数void bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]&#123;    for (int i = 0; i &lt; len - 1; i++)    &#123;        for (int j = 0; j &lt; len - 1 - i; j++)        &#123;            if (arr[j] &gt; arr[j + 1])            &#123;                int temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            &#125;        &#125;    &#125;&#125;//打印数组函数void printArray(int arr[], int len)&#123;    for (int i = 0; i &lt; len; i++)    &#123;        cout &lt;&lt; arr[i] &lt;&lt; endl;    &#125;&#125;int main() &#123;    int arr[10] = &#123; 4,3,6,9,1,2,10,8,7,5 &#125;;    int len = sizeof(arr) / sizeof(int);    bubbleSort(arr, len);    printArray(arr, len);    return 0;&#125;\n\n\n总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针\n\n八、结构体8.1 结构体基本概念结构体属于用户自定义的数据类型，允许用户存储不同的数据类型\n8.2 结构体定义和使用语法：struct 结构体名 &#123; 结构体成员列表 &#125;；通过结构体创建变量的方式有三种：\n\nstruct 结构体名 变量名\nstruct 结构体名 变量名 &#x3D; { 成员1值 ， 成员2值…}\n定义结构体时顺便创建变量示例：\n\n//结构体定义struct student&#123;    //成员列表    string name;  //姓名    int age;      //年龄    int score;    //分数&#125;stu3; //结构体变量创建方式3int main() &#123;    //结构体变量创建方式1    struct student stu1; //struct 关键字可以省略    stu1.name = &quot;张三&quot;;    stu1.age = 18;    stu1.score = 100;    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl;    //结构体变量创建方式2    struct student stu2 = &#123; &quot;李四&quot;,19,60 &#125;;    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl;    stu3.name = &quot;王五&quot;;    stu3.age = 18;    stu3.score = 80;    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl;    return 0;&#125;\n\n\n总结1：定义结构体时的关键字是struct，不可省略总结2：创建结构体变量时，关键字struct可以省略总结3：结构体变量利用操作符 ‘’.’’  访问成员\n\n8.3 结构体数组作用： 将自定义的结构体放入到数组中方便维护语法：struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;示例：\n//结构体定义struct student&#123;    //成员列表    string name;  //姓名    int age;      //年龄    int score;    //分数&#125;int main() &#123;    //结构体数组    struct student arr[3]=    &#123;        &#123;&quot;张三&quot;,18,80 &#125;,        &#123;&quot;李四&quot;,19,60 &#125;,        &#123;&quot;王五&quot;,20,70 &#125;    &#125;;    for (int i = 0; i &lt; 3; i++)    &#123;        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl;    &#125;    return 0;&#125;\n\n8.4 结构体指针作用： 通过指针访问结构体中的成员\n\n利用操作符 -&gt;可以通过结构体指针访问结构体属性示例：\n\n//结构体定义struct student&#123;    //成员列表    string name;  //姓名    int age;      //年龄    int score;    //分数&#125;;int main() &#123;    struct student stu = &#123; &quot;张三&quot;,18,100, &#125;;    struct student * p = &amp;stu;    p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;    return 0;&#125;\n\n\n总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员\n\n8.5 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体例如： 每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体示例：\n//学生结构体定义struct student&#123;    //成员列表    string name;  //姓名    int age;      //年龄    int score;    //分数&#125;;//教师结构体定义struct teacher&#123;    //成员列表    int id; //职工编号    string name;  //教师姓名    int age;   //教师年龄    struct student stu; //子结构体 学生&#125;;int main() &#123;    struct teacher t1;    t1.id = 10000;    t1.name = &quot;老王&quot;;    t1.age = 40;    t1.stu.name = &quot;张三&quot;;    t1.stu.age = 18;    t1.stu.score = 100;    cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;    cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;    return 0;&#125;\n\n在结构体中可以定义另一个结构体作为成员，用来解决实际问题\n8.6 结构体做函数参数作用： 将结构体作为参数向函数中传递传递方式有两种：\n\n值传递\n地址传递示例：\n\n//学生结构体定义struct student&#123;    //成员列表    string name;  //姓名    int age;      //年龄    int score;    //分数&#125;;//值传递void printStudent(student stu )&#123;    stu.age = 28;    cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;&#125;//地址传递void printStudent2(student *stu)&#123;    stu-&gt;age = 28;    cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123;    student stu = &#123; &quot;张三&quot;,18,100&#125;;    //值传递    printStudent(stu);    cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;    cout &lt;&lt; endl;    //地址传递    printStudent2(&amp;stu);    cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;    return 0;&#125;\n\n\n总结：如果不想修改主函数中的数据，用值传递，反之用地址传递\n\n8.7 结构体中 const 使用场景作用： 用const来防止误操作示例：\n//学生结构体定义struct student&#123;    //成员列表    string name;  //姓名    int age;      //年龄    int score;    //分数&#125;;//const使用场景void printStudent(const student *stu) //加const防止函数体中的误操作&#123;    //stu-&gt;age = 100; //操作失败，因为加了const修饰    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123;    student stu = &#123; &quot;张三&quot;,18,100 &#125;;    printStudent(&amp;stu);    return 0;&#125;\n\n8.8 结构体案例8.8.1 案例1案例描述：学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下：\n\n设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员\n学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值\n最终打印出老师数据以及老师所带的学生数据。示例：\n\nstruct Student&#123;    string name;    int score;&#125;;struct Teacher&#123;    string name;    Student sArray[5];&#125;;void allocateSpace(Teacher tArray[] , int len)&#123;    string tName = &quot;教师&quot;;    string sName = &quot;学生&quot;;    string nameSeed = &quot;ABCDE&quot;;    for (int i = 0; i &lt; len; i++)    &#123;        tArray[i].name = tName + nameSeed[i];        for (int j = 0; j &lt; 5; j++)        &#123;            tArray[i].sArray[j].name = sName + nameSeed[j];            tArray[i].sArray[j].score = rand() % 61 + 40;        &#125;    &#125;&#125;void printTeachers(Teacher tArray[], int len)&#123;    for (int i = 0; i &lt; len; i++)    &#123;        cout &lt;&lt; tArray[i].name &lt;&lt; endl;        for (int j = 0; j &lt; 5; j++)        &#123;            cout &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;        &#125;    &#125;&#125;int main() &#123;    srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt;    Teacher tArray[3]; //老师数组    int len = sizeof(tArray) / sizeof(Teacher);    allocateSpace(tArray, len); //创建数据    printTeachers(tArray, len); //打印数据    return 0;&#125;\n\n8.8.2 案例2案例描述：设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。五名英雄信息如下：\n&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;,\n\n示例：\n//英雄结构体struct hero&#123;    string name;    int age;    string sex;&#125;;//冒泡排序void bubbleSort(hero arr[] , int len)&#123;    for (int i = 0; i &lt; len - 1; i++)    &#123;        for (int j = 0; j &lt; len - 1 - i; j++)        &#123;            if (arr[j].age &gt; arr[j + 1].age)            &#123;                hero temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            &#125;        &#125;    &#125;&#125;//打印数组void printHeros(hero arr[], int len)&#123;    for (int i = 0; i &lt; len; i++)    &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl;    &#125;&#125;int main() &#123;    struct hero arr[5] =    &#123;        &#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,        &#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,        &#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,        &#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,        &#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;,    &#125;;    int len = sizeof(arr) / sizeof(hero); //获取数组元素个数    bubbleSort(arr, len); //排序    printHeros(arr, len); //打印    return 0;\n\n\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","cpp"]},{"title":"C Plus Plus - Core","url":"/2022/05/25/note/Programming/Language/cpp-2/","content":"本阶段主要针对cpp面向对象编程技术做详细讲解，探讨cpp中的核心和精髓。\n\n\n一、内存分区模型cpp程序在执行时，将内存大方向划分为4个区域\n\n代码区：存放函数体的二进制代码，由操作系统进行管理的\n全局区：存放全局变量和静态变量以及常量\n栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收内存四区意义：不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n\n1.1 程序运行前在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域代码区：\n\n存放 CPU 执行的机器指令\n代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令全局区：\n全局变量和静态变量存放在此\n全局区还包含了常量区, 字符串常量和其他常量也存放在此\n该区域的数据在程序结束后由操作系统释放.示例：\n\n//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() &#123;    //局部变量    int a = 10;    int b = 10;    //打印地址    cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;    cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;    cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;    cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;    //静态变量    static int s_a = 10;    static int s_b = 10;    cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;    cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;    cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;    cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;    const int c_l_a = 10;    const int c_l_b = 10;    cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;    cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;    return 0;&#125;\n\n\n\ncpp中在程序运行前分为全局区和代码区\n\n代码区特点是共享和只读\n\n全局区中存放全局变量、静态变量、常量\n\n常量区中存放 const修饰的全局常量  和 字符串常量\n\n\n1.2 程序运行后栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放示例：\nint * func()&#123;    int a = 10;    return &amp;a;&#125;int main() &#123;    int *p = func();    cout &lt;&lt; *p &lt;&lt; endl;    cout &lt;&lt; *p &lt;&lt; endl;    return 0;&#125;\n\n堆区：由程序员分配释放,若程序员不释放,程序结束时由操作系统回收在cpp中主要利用new在堆区开辟内存示例：\nint* func()&#123;    int* a = new int(10);    return a;&#125;int main() &#123;    int *p = func();    cout &lt;&lt; *p &lt;&lt; endl;    cout &lt;&lt; *p &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;\n\n总结：堆区数据由程序员管理开辟和释放堆区数据利用new关键字进行开辟内存\n1.3 new操作符cpp中利用new操作符在堆区开辟数据堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete语法：new 数据类型利用new创建的数据，会返回该数据对应的类型的指针示例1： 基本语法\nint* func()&#123;    int* a = new int(10);    return a;&#125;int main() &#123;    int *p = func();    cout &lt;&lt; *p &lt;&lt; endl;    cout &lt;&lt; *p &lt;&lt; endl;    //利用delete释放堆区数据    delete p;    //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问    return 0;&#125;\n\n示例2：开辟数组\n//堆区开辟数组int main() &#123;    int* arr = new int[10];    for (int i = 0; i &lt; 10; i++)    &#123;        arr[i] = i + 100;    &#125;    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; arr[i] &lt;&lt; endl;    &#125;    //释放数组 delete 后加 []    delete[] arr;    return 0;&#125;\n\n二、引用2.1 引用的基本使用作用： 给变量起别名语法： 数据类型 &amp;别名 = 原名示例：\nint main() &#123;    int a = 10;    int &amp;b = a;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    b = 100;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    return 0;&#125;\n\n2.2 引用注意事项\n引用必须初始化\n\n引用在初始化后，不可以改变示例：\n\n\nint main() &#123;    int a = 10;    int b = 20;    //int &amp;c; //错误，引用必须初始化    int &amp;c = a; //一旦初始化后，就不可以更改    c = b; //这是赋值操作，不是更改引用    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;    return 0;&#125;\n\n2.3 引用做函数参数作用： 函数传参时，可以利用引用的技术让形参修饰实参优点： 可以简化指针修改实参示例：\n//1. 值传递void mySwap01(int a, int b) &#123;    int temp = a;    a = b;    b = temp;&#125;//2. 地址传递void mySwap02(int* a, int* b) &#123;    int temp = *a;    *a = *b;    *b = temp;&#125;//3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123;    int temp = a;    a = b;    b = temp;&#125;int main() &#123;    int a = 10;    int b = 20;    mySwap01(a, b);    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;    mySwap02(&amp;a, &amp;b);    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;    mySwap03(a, b);    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;    return 0;&#125;\n\n\n总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n\n2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的注意：不要返回局部变量引用用法：函数调用作为左值示例：\n//返回局部变量引用int&amp; test01() &#123;    int a = 10; //局部变量    return a;&#125;//返回静态变量引用int&amp; test02() &#123;    static int a = 20;    return a;&#125;int main() &#123;    //不能返回局部变量的引用    int&amp; ref = test01();    cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;    cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;    //如果函数做左值，那么必须返回引用    int&amp; ref2 = test02();    cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;    cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;    test02() = 1000;    cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;    cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;    return 0;&#125;\n\n2.5 引用的本质本质：引用的本质在cpp内部实现是一个指针常量.讲解示例：\n//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123; ref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123; int a = 10;    //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a); return 0;&#125;\n\n结论：cpp推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n2.6 常量引用作用： 常量引用主要用来修饰形参，防止误操作在函数形参列表中，可以加const修饰形参，防止形参改变实参示例：\n//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123; //v += 10; cout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123; //int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp; const int&amp; ref = 10; //ref = 100;  //加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); return 0;&#125;\n\n三、函数提高3.1 函数默认参数在cpp中，函数的形参列表中的形参是可以有默认值的。语法：返回值类型  函数名 （参数= 默认值）&#123;&#125;示例：\nint func(int a, int b = 10, int c = 10) &#123; return a + b + c;&#125;//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) &#123; return a + b;&#125;int main() &#123; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl; return 0;&#125;\n\n3.2 函数占位参数cpp中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置语法： 返回值类型 函数名 (数据类型)&#123;&#125;在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术示例：\n//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) &#123; cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;&#125;int main() &#123; func(10,10); //占位参数必须填补 return 0;&#125;\n\n3.3 函数重载3.3.1 函数重载概述作用： 函数名可以相同，提高复用性函数重载满足条件：\n\n同一个作用域下\n函数名称相同\n函数参数类型不同  或者 个数不同 或者 顺序不同注意:  函数的返回值不可以作为函数重载的条件示例：\n\n//函数重载需要函数都在同一个作用域下void func()&#123; cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a)&#123; cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;&#125;void func(int a ,double b)&#123; cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a ,int b)&#123; cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;&#125;//函数返回值不可以作为函数重载条件//int func(double a, int b)//&#123;// cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;//&#125;int main() &#123; func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); return 0;&#125;\n\n3.3.2 函数重载注意事项\n引用作为重载条件\n\n函数重载碰到函数默认参数示例：\n\n\n//函数重载注意事项//1、引用作为重载条件void func(int &amp;a)&#123; cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;void func(const int &amp;a)&#123; cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;//2、函数重载碰到函数默认参数void func2(int a, int b = 10)&#123; cout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl;&#125;void func2(int a)&#123; cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;&#125;int main() &#123; int a = 10; func(a); //调用无const func(10);//调用有const //func2(10); //碰到默认参数产生歧义，需要避免 return 0;&#125;\n\n四、类和对象cpp面向对象的三大特性为：封装、继承、多态cpp认为万事万物都皆为对象，对象上有其属性和行为\n4.1 封装4.1.1  封装的意义封装是cpp面向对象三大特性之一封装的意义：\n\n将属性和行为作为一个整体，表现生活中的事物\n将属性和行为加以权限控制封装意义一：在设计类的时候，属性和行为写在一起，表现事物语法： class 类名&#123;   访问权限： 属性  / 行为  &#125;;示例1： 设计一个圆类，求圆的周长示例代码：\n\n//圆周率const double PI = 3.14;//1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物//封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle&#123;public:  //访问权限  公共的权限 //属性 int m_r;//半径 //行为 //获取到圆的周长 double calculateZC() &#123;  //2 * pi  * r  //获取圆的周长  return  2 * PI * m_r; &#125;&#125;;int main() &#123; //通过圆类，创建圆的对象 // c1就是一个具体的圆 Circle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作 //2 * pi * 10 = = 62.8 cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl; return 0;&#125;\n\n示例2： 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号示例2代码：\n//学生类class Student &#123;public: void setName(string name) &#123;  m_name = name; &#125; void setID(int id) &#123;  m_id = id; &#125; void showStudent() &#123;  cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl; &#125;public: string m_name; int m_id;&#125;;int main() &#123; Student stu; stu.setName(&quot;德玛西亚&quot;); stu.setID(250); stu.showStudent(); return 0;&#125;\n\n封装意义二：类在设计时，可以把属性和行为放在不同的权限下，加以控制访问权限有三种：\n\npublic        公共权限\nprotected 保护权限\nprivate      私有权限示例：\n\n//三种权限//公共权限  public     类内可以访问  类外可以访问//保护权限  protected  类内可以访问  类外不可以访问//私有权限  private    类内可以访问  类外不可以访问class Person&#123; //姓名  公共权限public: string m_Name; //汽车  保护权限protected: string m_Car; //银行卡密码  私有权限private: int m_Password;public: void func() &#123;  m_Name = &quot;张三&quot;;  m_Car = &quot;拖拉机&quot;;  m_Password = 123456; &#125;&#125;;int main() &#123; Person p; p.m_Name = &quot;李四&quot;; //p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到 //p.m_Password = 123; //私有权限类外访问不到 return 0;&#125;\n\n4.1.2 struct和class区别在cpp中 struct和class唯一的区别就在于 默认的访问权限不同区别：\n\nstruct 默认权限为公共\nclass   默认权限为私有\n\nclass C1&#123; int  m_A; //默认是私有权限&#125;;struct C2&#123; int m_A;  //默认是公共权限&#125;;int main() &#123; C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 return 0;&#125;\n\n4.1.3 成员属性设置为私有优点1： 将所有成员属性设置为私有，可以自己控制读写权限优点2： 对于写权限，我们可以检测数据的有效性示例：\nclass Person &#123;public: //姓名设置可读可写 void setName(string name) &#123;  m_Name = name; &#125; string getName() &#123;  return m_Name; &#125; //获取年龄 int getAge() &#123;  return m_Age; &#125; //设置年龄 void setAge(int age) &#123;  if (age &lt; 0 || age &gt; 150) &#123;   cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;   return;  &#125;  m_Age = age; &#125; //情人设置为只写 void setLover(string lover) &#123;  m_Lover = lover; &#125;private: string m_Name; //可读可写  姓名 int m_Age; //只读  年龄 string m_Lover; //只写  情人&#125;;int main() &#123; Person p; //姓名设置 p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl; //年龄设置 p.setAge(50); cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl; //情人设置 p.setLover(&quot;苍井&quot;); //cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取 return 0;&#125;\n\n练习案例1：设计立方体类设计立方体类(Cube)求出立方体的面积和体积分别用全局函数和成员函数判断两个立方体是否相等练习案例2：点和圆的关系设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系\n4.2 对象的初始化和清理\n生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\n\ncpp中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\n\n\n4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题\n一个对象或者变量没有初始状态，对其使用后果是未知\n同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\ncpp利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。\n\n构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。构造函数语法：类名()&#123;&#125;\n\n\n构造函数，没有返回值也不写void\n函数名称与类名相同\n构造函数可以有参数，因此可以发生重载\n程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次析构函数语法： ~类名()&#123;&#125;\n析构函数，没有返回值也不写void\n函数名称与类名相同,在名称前加上符号  ~\n析构函数不可以有参数，因此不可以发生重载\n程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\nclass Person&#123;public: //构造函数 Person() &#123;  cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123;  cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; Person p;&#125;int main() &#123; test01(); return 0;&#125;\n\n4.2.2 构造函数的分类及调用两种分类方式：\n\n按参数分为： 有参构造和无参构造\n按类型分为： 普通构造和拷贝构造三种调用方式：\n括号法\n显示法\n隐式转换法示例：\n\n//1、构造函数分类// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public: //无参（默认）构造函数 Person() &#123;  cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123;  age = a;  cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123;  age = p.age;  cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123;  cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int age;&#125;;//2、构造函数的调用//调用无参构造函数void test01() &#123; Person p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123; //2.1  括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象  当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4);&#125;int main() &#123; test01(); //test02(); return 0;&#125;\n\n4.2.3 拷贝构造函数调用时机cpp中拷贝构造函数调用时机通常有三种情况\n\n使用一个已经创建完毕的对象来初始化一个新对象\n值传递的方式给函数参数传值\n以值方式返回局部对象示例：\n\nclass Person &#123;public: Person() &#123;  cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;  mAge = 0; &#125; Person(int age) &#123;  cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;  mAge = age; &#125; Person(const Person&amp; p) &#123;  cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;  mAge = p.mAge; &#125; //析构函数在释放内存之前调用 ~Person() &#123;  cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int mAge;&#125;;//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123; Person man(100); //p对象已经创建完毕 Person newman(man); //调用拷贝构造函数 Person newman2 = man; //拷贝构造 //Person newman3; //newman3 = man; //不是调用拷贝构造函数，赋值操作&#125;//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) &#123;&#125;void test02() &#123; Person p; //无参构造函数 doWork(p);&#125;//3. 以值方式返回局部对象Person doWork2()&#123; Person p1; cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1;&#125;void test03()&#123; Person p = doWork2(); cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123; //test01(); //test02(); test03(); return 0;&#125;\n\n4.2.4 构造函数调用规则默认情况下，cpp编译器至少给一个类添加3个函数\n\n默认构造函数(无参，函数体为空)\n\n默认析构函数(无参，函数体为空)\n\n默认拷贝构造函数，对属性进行值拷贝构造函数调用规则如下：\n\n\n\n如果用户定义有参构造函数，cpp不在提供默认无参构造，但是会提供默认拷贝构造\n\n如果用户定义拷贝构造函数，cpp不会再提供其他构造函数示例：\n\n\nclass Person &#123;public: //无参（默认）构造函数 Person() &#123;  cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123;  age = a;  cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123;  age = p.age;  cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123;  cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int age;&#125;;void test01()&#123; Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123; //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; //此时如果用户自己没有提供默认构造，会出错 Person p2(10); //用户提供的有参 Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 //如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; //此时如果用户自己没有提供默认构造，会出错 Person p5(10); //此时如果用户自己没有提供有参，会出错 Person p6(p5); //用户自己提供拷贝构造&#125;int main() &#123; test01(); return 0;&#125;\n\n4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑浅拷贝： 简单的赋值拷贝操作深拷贝： 在堆区重新申请空间，进行拷贝操作示例：\nclass Person &#123;public: //无参（默认）构造函数 Person() &#123;  cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int age ,int height) &#123;  cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;  m_age = age;  m_height = new int(height); &#125; //拷贝构造函数 Person(const Person&amp; p) &#123;  cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;  //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题  m_age = p.m_age;  m_height = new int(*p.m_height); &#125; //析构函数 ~Person() &#123;  cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;  if (m_height != NULL)  &#123;   delete m_height;  &#125; &#125;public: int m_age; int* m_height;&#125;;void test01()&#123; Person p1(18, 180); Person p2(p1); cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n\n4.2.6 初始化列表作用： cpp提供了初始化列表语法，用来初始化属性语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125;示例：\nclass Person &#123;public: ////传统方式初始化 //Person(int a, int b, int c) &#123; // m_A = a; // m_B = b; // m_C = c; //&#125; //初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125; void PrintPerson() &#123;  cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;  cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;  cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl; &#125;private: int m_A; int m_B; int m_C;&#125;;int main() &#123; Person p(1, 2, 3); p.PrintPerson(); return 0;&#125;\n\n4.2.7 类对象作为类成员cpp类中的成员可以是另一个类的对象，我们称该成员为 对象成员例如：\nclass A &#123;&#125;class B&#123;    A a；&#125;\n\nB类中有对象A作为成员，A为对象成员；那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？示例：\nclass Phone&#123;public: Phone(string name) &#123;  m_PhoneName = name;  cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl; &#125; ~Phone() &#123;  cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl; &#125; string m_PhoneName;&#125;;class Person&#123;public: //初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123;  cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl; &#125; ~Person() &#123;  cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl; &#125; void playGame() &#123;  cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl; &#125; string m_Name; Phone m_Phone;&#125;;void test01()&#123; //当类中成员是其他类对象时，我们称该成员为 对象成员 //构造的顺序是 ：先调用对象成员的构造，再调用本类构造 //析构顺序与构造相反 Person p(&quot;张三&quot; , &quot;苹果X&quot;); p.playGame();&#125;int main() &#123; test01(); return 0;&#125;\n\n4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员静态成员分为：\n\n静态成员变量\n所有对象共享同一份数据\n在编译阶段分配内存\n类内声明，类外初始化\n\n\n静态成员函数\n所有对象共享同一个函数\n静态成员函数只能访问静态成员变量示例1 ： 静态成员变量\n\n\n\nclass Person&#123;public: static int m_A; //静态成员变量 //静态成员变量特点： //1 在编译阶段分配内存 //2 类内声明，类外初始化 //3 所有对象共享同一份数据private: static int m_B; //静态成员变量也是有访问权限的&#125;;int Person::m_A = 10;int Person::m_B = 10;void test01()&#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.m_A = 100; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; Person p2; p2.m_A = 200; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据 cout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl; //2、通过类名 cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl; //cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到&#125;int main() &#123; test01(); return 0;&#125;\n\n示例2： 静态成员函数\nclass Person&#123;public: //静态成员函数特点： //1 程序共享一个函数 //2 静态成员函数只能访问静态成员变量 static void func() &#123;  cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;  m_A = 100;  //m_B = 100; //错误，不可以访问非静态成员变量 &#125; static int m_A; //静态成员变量 int m_B; //private: //静态成员函数也是有访问权限的 static void func2() &#123;  cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl; &#125;&#125;;int Person::m_A = 10;void test01()&#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.func(); //2、通过类名 Person::func(); //Person::func2(); //私有权限访问不到&#125;int main() &#123; test01(); return 0;&#125;\n\n4.3 cpp对象模型和this指针4.3.1 成员变量和成员函数分开存储在cpp中，类内的成员变量和成员函数分开存储只有非静态成员变量才属于类的对象上\nclass Person &#123;public: Person() &#123;  mA = 0; &#125; //非静态成员变量占对象空间 int mA; //静态成员变量不占对象空间 static int mB; //函数也不占对象空间，所有函数共享一个函数实例 void func() &#123;  cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl; &#125; //静态成员函数也不占对象空间 static void sfunc() &#123; &#125;&#125;;int main() &#123; cout &lt;&lt; sizeof(Person) &lt;&lt; endl; return 0;&#125;\n\n4.3.2 this指针概念通过4.3.1我们知道在cpp中成员变量和成员函数是分开存储的每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码那么问题是：这一块代码是如何区分那个对象调用自己的呢？cpp通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象this指针是隐含每一个非静态成员函数内的一种指针this指针不需要定义，直接使用即可this指针的用途：\n\n当形参和成员变量同名时，可用this指针来区分\n在类的非静态成员函数中返回对象本身，可使用return *this\n\nclass Person&#123;public: Person(int age) &#123;  //1、当形参和成员变量同名时，可用this指针来区分  this-&gt;age = age; &#125; Person&amp; PersonAddPerson(Person p) &#123;  this-&gt;age += p.age;  //返回对象本身  return *this; &#125; int age;&#125;;void test01()&#123; Person p1(10); cout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n4.3.3 空指针访问成员函数cpp中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针如果用到this指针，需要加以判断保证代码的健壮性示例：\n//空指针访问成员函数class Person &#123;public: void ShowClassName() &#123;  cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl; &#125; void ShowPerson() &#123;  if (this *** NULL) &#123;   return;  &#125;  cout &lt;&lt; mAge &lt;&lt; endl; &#125;public: int mAge;&#125;;void test01()&#123; Person * p = NULL; p-&gt;ShowClassName(); //空指针，可以调用成员函数 p-&gt;ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123; test01(); return 0;&#125;\n\n4.3.4 const修饰成员函数常函数：\n\n成员函数后加const后我们称为这个函数为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable后，在常函数中依然可以修改常对象：\n声明对象前加const称该对象为常对象\n常对象只能调用常函数示例：\n\nclass Person &#123;public: Person() &#123;  m_A = 0;  m_B = 0; &#125; //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const &#123;  //const Type* const pointer;  //this = NULL; //不能修改指针的指向 Person* const this;  //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的  //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量  this-&gt;m_B = 100; &#125; void MyFunc() const &#123;  //mA = 10000; &#125;public: int m_A; mutable int m_B; //可修改 可变的&#125;;//const修饰对象  常对象void test01() &#123; const Person person; //常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 person.m_B = 100; //但是常对象可以修改mutable修饰成员变量 //常对象访问成员函数 person.MyFunc(); //常对象不能调用const的函数&#125;int main() &#123; test01(); return 0;&#125;\n\n4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private)客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去但是呢，你也可以允许你的好闺蜜好基友进去。在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术友元的目的就是让一个函数或者类 访问另一个类中私有成员友元的关键字为  friend友元的三种实现\n\n全局函数做友元\n类做友元\n成员函数做友元\n\n4.4.1 全局函数做友元class Building&#123; //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building);public: Building() &#123;  this-&gt;m_SittingRoom = &quot;客厅&quot;;  this-&gt;m_BedRoom = &quot;卧室&quot;; &#125;public: string m_SittingRoom; //客厅private: string m_BedRoom; //卧室&#125;;void goodGay(Building * building)&#123; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; Building b; goodGay(&amp;b);&#125;int main()&#123; test01(); return 0;&#125;\n\n4.4.2 类做友元class Building;class goodGay&#123;public: goodGay(); void visit();private: Building *building;&#125;;class Building&#123; //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay;public: Building();public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123; building = new Building;&#125;void goodGay::visit()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; goodGay gg; gg.visit();&#125;int main()&#123; test01(); return 0;&#125;\n\n4.4.3 成员函数做友元class Building;class goodGay&#123;public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 void visit2();private: Building *building;&#125;;class Building&#123; //告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit();public: Building();public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123; building = new Building;&#125;void goodGay::visit()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; goodGay  gg; gg.visit();&#125;int main()&#123; test01(); return 0;&#125;\n\n4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算\nclass Person &#123;public: Person() &#123;&#125;; Person(int a, int b) &#123;  this-&gt;m_A = a;  this-&gt;m_B = b; &#125; //成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) &#123;  Person temp;  temp.m_A = this-&gt;m_A + p.m_A;  temp.m_B = this-&gt;m_B + p.m_B;  return temp; &#125;public: int m_A; int m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;// Person temp(0, 0);// temp.m_A = p1.m_A + p2.m_A;// temp.m_B = p1.m_B + p2.m_B;// return temp;//&#125;//运算符重载 可以发生函数重载Person operator+(const Person&amp; p2, int val)&#123; Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp;&#125;void test() &#123; Person p1(10, 10); Person p2(20, 20); //成员函数方式 Person p3 = p2 + p1;  //相当于 p2.operaor+(p1) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123; test(); return 0;&#125;\n\n\n总结1：对于内置的数据类型的表达式的的运算符是不可能改变的总结2：不要滥用运算符重载\n\n4.5.2 左移运算符重载作用：可以输出自定义数据类型\nclass Person &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public: Person(int a, int b) &#123;  this-&gt;m_A = a;  this-&gt;m_B = b; &#125; //成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p)&#123; //&#125;private: int m_A; int m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B; return out;&#125;void test() &#123; Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123; test(); return 0;&#125;\n\n\n重载左移运算符配合友元可以实现输出自定义数据类型\n\n4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据\nclass MyInteger &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public: MyInteger() &#123;  m_Num = 0; &#125; //前置++ MyInteger&amp; operator++() &#123;  //先++  m_Num++;  //再返回  return *this; &#125; //后置++ MyInteger operator++(int) &#123;  //先返回  MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；  m_Num++;  return temp; &#125;private: int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123; out &lt;&lt; myint.m_Num; return out;&#125;//前置++ 先++ 再返回void test01() &#123; MyInteger myInt; cout &lt;&lt; ++myInt &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;&#125;//后置++ 先返回 再++void test02() &#123; MyInteger myInt; cout &lt;&lt; myInt++ &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123; test01(); //test02(); return 0;&#125;\n\n\n前置递增返回引用，后置递增返回值\n\n4.5.4 赋值运算符重载cpp编译器至少给一个类添加4个函数\n\n默认构造函数(无参，函数体为空)\n默认析构函数(无参，函数体为空)\n默认拷贝构造函数，对属性进行值拷贝\n赋值运算符 operator&#x3D;, 对属性进行值拷贝如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题示例：\n\nclass Person&#123;public: Person(int age) &#123;  //将年龄数据开辟到堆区  m_Age = new int(age); &#125; //重载赋值运算符 Person&amp; operator=(Person &amp;p) &#123;  if (m_Age != NULL)  &#123;   delete m_Age;   m_Age = NULL;  &#125;  //编译器提供的代码是浅拷贝  //m_Age = p.m_Age;  //提供深拷贝 解决浅拷贝的问题  m_Age = new int(*p.m_Age);  //返回自身  return *this; &#125; ~Person() &#123;  if (m_Age != NULL)  &#123;   delete m_Age;   m_Age = NULL;  &#125; &#125; //年龄的指针 int *m_Age;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作 cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); //int a = 10; //int b = 20; //int c = 30; //c = b = a; //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; return 0;&#125;\n\n4.5.5 关系运算符重载作用： 重载关系运算符，可以让两个自定义类型对象进行对比操作示例：\nclass Person&#123;public: Person(string name, int age) &#123;  this-&gt;m_Name = name;  this-&gt;m_Age = age; &#125;; bool operator***(Person &amp; p) &#123;  if (this-&gt;m_Name *** p.m_Name &amp;&amp; this-&gt;m_Age *** p.m_Age)  &#123;   return true;  &#125;  else  &#123;   return false;  &#125; &#125; bool operator!=(Person &amp; p) &#123;  if (this-&gt;m_Name *** p.m_Name &amp;&amp; this-&gt;m_Age *** p.m_Age)  &#123;   return false;  &#125;  else  &#123;   return true;  &#125; &#125; string m_Name; int m_Age;&#125;;void test01()&#123; //int a = 0; //int b = 0; Person a(&quot;孙悟空&quot;, 18); Person b(&quot;孙悟空&quot;, 18); if (a *** b) &#123;  cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; if (a != b) &#123;  cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); return 0;&#125;\n\n4.5.6 函数调用运算符重载\n函数调用运算符 ()  也可以重载\n\n由于重载后使用的方式非常像函数的调用，因此称为仿函数\n\n仿函数没有固定写法，非常灵活示例：\n\n\nclass MyPrint&#123;public: void operator()(string text) &#123;  cout &lt;&lt; text &lt;&lt; endl; &#125;&#125;;void test01()&#123; //重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(&quot;hello world&quot;);&#125;class MyAdd&#123;public: int operator()(int v1, int v2) &#123;  return v1 + v2; &#125;&#125;;void test02()&#123; MyAdd add; int ret = add(10, 10); cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl; //匿名对象调用 cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); return 0;&#125;\n\n4.6  继承继承是面向对象三大特性之一我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。这个时候我们就可以考虑利用继承的技术，减少重复代码\n4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处普通实现：\n//Java页面class Java&#123;public: void header() &#123;  cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123;  cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123;  cout &lt;&lt; &quot;Java,Python,cpp...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123;  cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python&#123;public: void header() &#123;  cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123;  cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123;  cout &lt;&lt; &quot;Java,Python,cpp...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123;  cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//cpp页面class CPP&#123;public: void header() &#123;  cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123;  cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123;  cout &lt;&lt; &quot;Java,Python,cpp...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123;  cout &lt;&lt; &quot;cpp学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //cpp页面 cout &lt;&lt; &quot;cpp下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content();&#125;int main() &#123; test01(); return 0;&#125;\n\n继承实现：\n//公共页面class BasePage&#123;public: void header() &#123;  cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123;  cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123;  cout &lt;&lt; &quot;Java,Python,cpp...(公共分类列表)&quot; &lt;&lt; endl; &#125;&#125;;//Java页面class Java : public BasePage&#123;public: void content() &#123;  cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python : public BasePage&#123;public: void content() &#123;  cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//cpp页面class CPP : public BasePage&#123;public: void content() &#123;  cout &lt;&lt; &quot;cpp学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //cpp页面 cout &lt;&lt; &quot;cpp下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content();&#125;int main() &#123; test01(); return 0;&#125;\n\n继承的好处：可以减少重复的代码class A : public B;A 类称为子类 或 派生类B 类称为父类 或 基类派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员。从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n4.6.2 继承方式继承的语法：class 子类 : 继承方式  父类继承方式一共有三种：\n\n公共继承\n保护继承\n私有继承示例：\n\nclass Base1&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;//公共继承class Son1 :public Base1&#123;public: void func() &#123;  m_A; //可访问 public权限  m_B; //可访问 protected权限  //m_C; //不可访问 &#125;&#125;;void myClass()&#123; Son1 s1; s1.m_A; //其他类只能访问到公共权限&#125;//保护继承class Base2&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son2:protected Base2&#123;public: void func() &#123;  m_A; //可访问 protected权限  m_B; //可访问 protected权限  //m_C; //不可访问 &#125;&#125;;void myClass2()&#123; Son2 s; //s.m_A; //不可访问&#125;//私有继承class Base3&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son3:private Base3&#123;public: void func() &#123;  m_A; //可访问 private权限  m_B; //可访问 private权限  //m_C; //不可访问 &#125;&#125;;class GrandSon3 :public Son3&#123;public: void func() &#123;  //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到  //m_A;  //m_B;  //m_C; &#125;&#125;;\n\n4.6.3 继承中的对象模型问题： 从父类继承过来的成员，哪些属于子类对象中？示例：\nclass Base&#123;public: int m_A;protected: int m_B;private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去&#125;;//公共继承class Son :public Base&#123;public: int m_D;&#125;;void test01()&#123; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n\n4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数问题：父类和子类的构造和析构顺序是谁先谁后？示例：\nclass Base&#123;public: Base() &#123;  cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl; &#125; ~Base() &#123;  cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl; &#125;&#125;;class Son : public Base&#123;public: Son() &#123;  cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl; &#125; ~Son() &#123;  cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\n4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n访问子类同名成员   直接访问即可\n访问父类同名成员   需要加作用域示例：\n\nclass Base &#123;public: Base() &#123;  m_A = 100; &#125; void func() &#123;  cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl; &#125; void func(int a) &#123;  cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl; &#125;public: int m_A;&#125;;class Son : public Base &#123;public: Son() &#123;  m_A = 200; &#125; //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() &#123;  cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl; &#125;public: int m_A;&#125;;void test01()&#123; Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; s.func(); s.Base::func(); s.Base::func(10);&#125;int main() &#123; test01(); return EXIT_SUCCESS;&#125;\n\n总结：\n\n子类对象可以直接访问到子类中同名成员\n子类对象加作用域可以访问到父类同名成员\n当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？静态成员和非静态成员出现同名，处理方式一致\n\n访问子类同名成员   直接访问即可\n访问父类同名成员   需要加作用域示例：\n\nclass Base &#123;public: static void func() &#123;  cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl; &#125; static void func(int a) &#123;  cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl; &#125; static int m_A;&#125;;int Base::m_A = 100;class Son : public Base &#123;public: static void func() &#123;  cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl; &#125; static int m_A;&#125;;int Son::m_A = 200;//同名成员属性void test01()&#123; //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; //通过类名访问 cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;//同名成员函数void test02()&#123; //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100);&#125;int main() &#123; //test01(); test02(); return 0;&#125;\n\n\n同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n\n4.6.7 多继承语法cpp允许一个类继承多个类语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2...多继承可能会引发父类中有同名成员出现，需要加作用域区分cpp实际开发中不建议用多继承示例：\nclass Base1 &#123;public: Base1() &#123;  m_A = 100; &#125;public: int m_A;&#125;;class Base2 &#123;public: Base2() &#123;  m_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确 &#125;public: int m_A;&#125;;//语法：class 子类：继承方式 父类1 ，继承方式 父类2class Son : public Base2, public Base1&#123;public: Son() &#123;  m_C = 300;  m_D = 400; &#125;public: int m_C; int m_D;&#125;;//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123; Son s; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n\n4.6.8 菱形继承菱形继承概念：两个派生类继承同一个基类又有某个类同时继承者两个派生类这种继承被称为菱形继承，或者钻石继承菱形继承问题：\n\n羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。示例：\n\nclass Animal&#123;public: int m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo   : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n\n利用虚继承可以解决菱形继承问题\n\n\n4.7  多态4.7.1 多态的基本概念多态是cpp面向对象三大特性之一多态分为两类\n\n静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n动态多态: 派生类和虚函数实现运行时多态静态多态和动态多态区别：\n静态多态的函数地址早绑定  -  编译阶段确定函数地址\n动态多态的函数地址晚绑定  -  运行阶段确定函数地址下面通过案例进行讲解多态\n\nclass Animal&#123;public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() &#123;  cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125;&#125;;class Cat :public Animal&#123;public: void speak() &#123;  cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123;  cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; &#125;&#125;;//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123; animal.speak();&#125;////多态满足条件：//1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01()&#123; Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog);&#125;int main() &#123; test01(); return 0;&#125;\n\n多态满足条件\n\n有继承关系\n子类重写父类中的虚函数多态使用条件\n父类指针或引用指向子类对象重写：函数返回值类型  函数名 参数列表 完全一致称为重写\n\n4.7.2 多态案例一-计算器类案例描述：分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类多态的优点：\n\n代码组织结构清晰\n可读性强\n利于前期和后期的扩展以及维护示例：\n\n//普通实现class Calculator &#123;public: int getResult(string oper) &#123;  if (oper *** &quot;+&quot;) &#123;   return m_Num1 + m_Num2;  &#125;  else if (oper *** &quot;-&quot;) &#123;   return m_Num1 - m_Num2;  &#125;  else if (oper *** &quot;*&quot;) &#123;   return m_Num1 * m_Num2;  &#125;  //如果要提供新的运算，需要修改源码 &#125;public: int m_Num1; int m_Num2;&#125;;void test01()&#123; //普通实现测试 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public : virtual int getResult() &#123;  return 0; &#125; int m_Num1; int m_Num2;&#125;;//加法计算器class AddCalculator :public AbstractCalculator&#123;public: int getResult() &#123;  return m_Num1 + m_Num2; &#125;&#125;;//减法计算器class SubCalculator :public AbstractCalculator&#123;public: int getResult() &#123;  return m_Num1 - m_Num2; &#125;&#125;;//乘法计算器class MulCalculator :public AbstractCalculator&#123;public: int getResult() &#123;  return m_Num1 * m_Num2; &#125;&#125;;void test02()&#123; //创建加法计算器 AbstractCalculator *abc = new AddCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc;  //用完了记得销毁 //创建减法计算器 abc = new SubCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //创建乘法计算器 abc = new MulCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc;&#125;int main() &#123; //test01(); test02(); return 0;&#125;\n\n\ncpp开发提倡利用多态设计程序架构，因为多态优点很多\n\n4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容因此可以将虚函数改为纯虚函数纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;当类中有了纯虚函数，这个类也称为抽象类抽象类特点：\n\n无法实例化对象\n子类必须重写抽象类中的纯虚函数，否则也属于抽象类示例：\n\nclass Base&#123;public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123;public: virtual void func() &#123;  cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; &#125;;&#125;;void test01()&#123; Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 base = new Son; base-&gt;func(); delete base;//记得销毁&#125;int main() &#123; test01(); return 0;&#125;\n\n4.7.4 多态案例二-制作饮品案例描述：制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料示例：\n//抽象制作饮品class AbstractDrinking &#123;public: //烧水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //规定流程 void MakeDrink() &#123;  Boil();  Brew();  PourInCup();  PutSomething(); &#125;&#125;;//制作咖啡class Coffee : public AbstractDrinking &#123;public: //烧水 virtual void Boil() &#123;  cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123;  cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123;  cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123;  cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl; &#125;&#125;;//制作茶水class Tea : public AbstractDrinking &#123;public: //烧水 virtual void Boil() &#123;  cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123;  cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123;  cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123;  cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl; &#125;&#125;;//业务函数void DoWork(AbstractDrinking* drink) &#123; drink-&gt;MakeDrink(); delete drink;&#125;void test01() &#123; DoWork(new Coffee); cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl; DoWork(new Tea);&#125;int main() &#123; test01(); return 0;&#125;\n\n4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码解决方式：将父类中的析构函数改为虚析构或者纯虚析构虚析构和纯虚析构共性：\n\n可以解决父类指针释放子类对象\n都需要有具体的函数实现虚析构和纯虚析构区别：\n如果是纯虚析构，该类属于抽象类，无法实例化对象虚析构语法：virtual ~类名()&#123;&#125;纯虚析构语法：virtual ~类名() = 0;类名::~类名()&#123;&#125;示例：\n\nclass Animal &#123;public: Animal() &#123;  cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl; &#125; virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //&#123; // cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl; //&#125; virtual ~Animal() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public: Cat(string name) &#123;  cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;  m_Name = new string(name); &#125; virtual void Speak() &#123;  cout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl; &#125; ~Cat() &#123;  cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;  if (this-&gt;m_Name != NULL) &#123;   delete m_Name;   m_Name = NULL;  &#125; &#125;public: string *m_Name;&#125;;void test01()&#123; Animal *animal = new Cat(&quot;Tom&quot;); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n拥有纯虚析构函数的类也属于抽象类\n\n4.7.6 多态案例三-电脑组装案例描述：电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口测试时组装三台不同的电脑进行工作示例：\n#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public: //抽象的计算函数 virtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public: //抽象的显示函数 virtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public: //抽象的存储函数 virtual void storage() = 0;&#125;;//电脑类class Computer&#123;public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) &#123;  m_cpu = cpu;  m_vc = vc;  m_mem = mem; &#125; //提供工作的函数 void work() &#123;  //让零件工作起来，调用接口  m_cpu-&gt;calculate();  m_vc-&gt;display();  m_mem-&gt;storage(); &#125; //提供析构函数 释放3个电脑零件 ~Computer() &#123;  //释放CPU零件  if (m_cpu != NULL)  &#123;   delete m_cpu;   m_cpu = NULL;  &#125;  //释放显卡零件  if (m_vc != NULL)  &#123;   delete m_vc;   m_vc = NULL;  &#125;  //释放内存条零件  if (m_mem != NULL)  &#123;   delete m_mem;   m_mem = NULL;  &#125; &#125;private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public: virtual void calculate() &#123;  cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123;  cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123;  cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public: virtual void calculate() &#123;  cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public: virtual void display() &#123;  cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class LenovoMemory :public Memory&#123;public: virtual void storage() &#123;  cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3;&#125;\n\n五、文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放通过文件可以将数据持久化cpp中对文件操作需要包含头文件 fstream文件类型分为两种：\n\n文本文件    -  文件以文本的ASCII码形式存储在计算机中\n二进制文件 -  文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们操作文件的三大类:\nofstream：写操作\nifstream： 读操作\nfstream ： 读写操作\n\n5.1文本文件5.1.1写文件写文件步骤如下：\n\n包含头文件  \\#include &lt;fstream\\&gt;\n\n创建流对象ofstream ofs;\n\n打开文件ofs.open(&quot;文件路径&quot;,打开方式);\n\n写数据ofs &lt;&lt; &quot;写入的数据&quot;;\n\n关闭文件ofs.close();文件打开方式：\n\n\n\n打开方式\n解释\n\n\n\nios::in\n为读文件而打开文件\n\n\nios::out\n为写文件而打开文件\n\n\nios::ate\n初始位置：文件尾\n\n\nios::app\n追加方式写文件\n\n\nios::trunc\n如果文件存在先删除，再创建\n\n\nios::binary\n二进制方式\n\n\n注意： 文件打开方式可以配合使用，利用\n操作符\n\n\n例如： 用二进制方式写文件 &#96;ios::binary\nios:: out&#96;\n\n\n示例：\n\n\n\n\n\n#include &lt;fstream&gt;void test01()&#123; ofstream ofs; ofs.open(&quot;test.txt&quot;, ios::out); ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; ofs.close();&#125;int main() &#123; test01(); return 0;&#125;\n\n\n文件操作必须包含头文件 fstream\n\n读文件可以利用 ofstream  ，或者fstream类\n\n打开文件时候需要指定操作文件的路径，以及打开方式\n\n利用&lt;&lt;可以向文件中写数据\n\n操作完毕，要关闭文件\n\n\n5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多读文件步骤如下：\n\n包含头文件  #include &lt;fstream&gt;\n创建流对象ifstream ifs;\n打开文件并判断文件是否打开成功ifs.open(&quot;文件路径&quot;,打开方式);\n读数据四种方式读取\n关闭文件ifs.close(); 示例：\n\n#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123; ifstream ifs; ifs.open(&quot;test.txt&quot;, ios::in); if (!ifs.is_open()) &#123;  cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;  return; &#125; //第一种方式 //char buf[1024] = &#123; 0 &#125;; //while (ifs &gt;&gt; buf) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第二种 //char buf[1024] = &#123; 0 &#125;; //while (ifs.getline(buf,sizeof(buf))) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第三种 //string buf; //while (getline(ifs, buf)) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; char c; while ((c = ifs.get()) != EOF) &#123;  cout &lt;&lt; c; &#125; ifs.close();&#125;int main() &#123; test01(); return 0;&#125;\n\n\n读文件可以利用 ifstream  ，或者fstream类\n利用is_open函数可以判断文件是否打开成功\nclose 关闭文件\n\n5.2 二进制文件以二进制的方式对文件进行读写操作打开方式要指定为 ios::binary\n5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write函数原型 ：ostream&amp; write(const char * buffer,int len);参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数示例：\n#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public: char m_Name[64]; int m_Age;&#125;;//二进制文件  写文件void test01()&#123; //1、包含头文件 //2、创建输出流对象 ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary); //3、打开文件 //ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); Person p = &#123;&quot;张三&quot;  , 18&#125;; //4、写文件 ofs.write((const char *)&amp;p, sizeof(p)); //5、关闭文件 ofs.close();&#125;int main() &#123; test01(); return 0;&#125;\n\n\n文件输出流对象 可以通过write函数，以二进制方式写数据\n\n5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read函数原型：istream&amp; read(char *buffer,int len);参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数示例：\n#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public: char m_Name[64]; int m_Age;&#125;;void test01()&#123; ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) &#123;  cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; &#125; Person p; ifs.read((char *)&amp;p, sizeof(p)); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n文件输入流对象 可以通过read函数，以二进制方式读数据\n\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","cpp"]},{"title":"C Plus Plus - Enhancement","url":"/2022/05/25/note/Programming/Language/cpp-3/","content":"本阶段主要针对cpp泛型编程和STL技术做详细讲解，探讨cpp更深层的使用\n\n\n一、模板1.1 模板的概念模板就是建立通用的模具，大大提高复用性模板的特点：\n\n模板不可以直接使用，它只是一个框架\n模板的通用并不是万能的\n\n1.2 函数模板\ncpp另一种编程思想称为 泛型编程 ，主要利用的技术就是模板\n\ncpp提供两种模板机制:函数模板和类模板\n\n\n1.2.1 函数模板语法函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。语法：\ntemplate&lt;typename T&gt;函数声明或定义\n\n解释：template  —  声明创建模板typename  — 表面其后面的符号是一种数据类型，可以用class代替T    —   通用的数据类型，名称可以替换，通常为大写字母示例：\n//交换整型函数void swapInt(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp;&#125;//交换浮点型函数void swapDouble(double&amp; a, double&amp; b) &#123; double temp = a; a = b; b = temp;&#125;//利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void test01()&#123; int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n函数模板利用关键字 template\n\n使用函数模板有两种方式：自动类型推导、显示指定类型\n\n模板的目的是为了提高复用性，将类型参数化\n\n\n1.2.2 函数模板注意事项注意事项：\n\n自动类型推导，必须推导出一致的数据类型T,才可以使用\n模板必须要确定出T的数据类型，才可以使用示例：\n\n//利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; mySwap(a, b); // 正确，可以推导出一致的T //mySwap(a, c); // 错误，推导不出一致的T类型&#125;// 2、模板必须要确定出T的数据类型，才可以使用template&lt;class T&gt;void func()&#123; cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;&#125;void test02()&#123; //func(); //错误，模板不能独立使用，必须确定出T的类型 func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板&#125;int main() &#123; test01(); test02(); return 0;&#125;\n\n\n使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型\n\n1.2.3 函数模板案例案例描述：\n\n利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序\n排序规则从大到小，排序算法为选择排序\n分别利用char数组和int数组进行测试示例：\n\n//交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;class T&gt; // 也可以替换成typename//利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123;  int max = i; //最大数的下标  for (int j = i + 1; j &lt; len; j++)  &#123;   if (arr[max] &lt; arr[j])   &#123;    max = j;   &#125;  &#125;  if (max != i) //如果最大数的下标不是i，交换两者  &#123;   mySwap(arr[max], arr[i]);  &#125; &#125;&#125;template&lt;typename T&gt;void printArray(T arr[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123;  cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //测试char数组 char charArr[] = &quot;bdcfeagh&quot;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num);&#125;void test02()&#123; //测试int数组 int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num);&#125;int main() &#123; test01(); test02(); return 0;&#125;\n\n模板可以提高代码复用，需要熟练掌握\n1.2.4 普通函数与函数模板的区别普通函数与函数模板区别：\n\n普通函数调用时可以发生自动类型转换（隐式类型转换）\n函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换\n如果利用显示指定类型的方式，可以发生隐式类型转换示例：\n\n//普通函数int myAdd01(int a, int b)&#123; return a + b;&#125;//函数模板template&lt;class T&gt;T myAdd02(T a, T b)&#123; return a + b;&#125;//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99 //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125;\n\n建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T\n1.2.5 普通函数与函数模板的调用规则调用规则如下：\n\n如果函数模板和普通函数都可以实现，优先调用普通函数\n可以通过空模板参数列表来强制调用函数模板\n函数模板也可以发生重载\n如果函数模板可以产生更好的匹配,优先调用函数模板示例：\n\n//普通函数与函数模板调用规则void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b, T c)&#123; cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl;&#125;void test01()&#123; //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint&lt;&gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = &#x27;a&#x27;; char c2 = &#x27;b&#x27;; myPrint(c1, c2); //调用函数模板&#125;int main() &#123; test01(); return 0;&#125;\n\n既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n1.2.6 模板的局限性局限性：\n\n模板的通用性并不是万能的例如：\n\ntemplate&lt;class T&gt;void f(T a, T b)&#123;    a = b;   &#125;\n\n在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了再例如：\ntemplate&lt;class T&gt;void f(T a, T b)&#123;    if(a &gt; b) &#123; ... &#125;   &#125;\n\n在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行因此cpp为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板示例：\n#include&lt;iostream&gt;using namespace std;#include &lt;string&gt;class Person&#123;public: Person(string name, int age) &#123;  this-&gt;m_Name = name;  this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;//普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123; if (a *** b) &#123;  return true; &#125; else &#123;  return false; &#125;&#125;//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型//具体化优先于常规模板template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123; if ( p1.m_Name  *** p2.m_Name &amp;&amp; p1.m_Age *** p2.m_Age) &#123;  return true; &#125; else &#123;  return false; &#125;&#125;void test01()&#123; int a = 10; int b = 20; //内置数据类型可以直接使用通用的函数模板 bool ret = myCompare(a, b); if (ret) &#123;  cout &lt;&lt; &quot;a *** b &quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl; &#125;&#125;void test02()&#123; Person p1(&quot;Tom&quot;, 10); Person p2(&quot;Tom&quot;, 10); //自定义数据类型，不会调用普通的函数模板 //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 bool ret = myCompare(p1, p2); if (ret) &#123;  cout &lt;&lt; &quot;p1 *** p2 &quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); test02(); return 0;&#125;\n\n\n利用具体化的模板，可以解决自定义类型的通用化\n\n学习模板并不是为了写模板，而是在STL能够运用系统提供的模板\n\n\n1.3 类模板1.3.1 类模板语法类模板作用：\n\n建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。语法：\n\ntemplate&lt;typename T&gt;类\n\n解释：template  —  声明创建模板typename  — 表面其后面的符号是一种数据类型，可以用class代替T    —   通用的数据类型，名称可以替换，通常为大写字母示例：\n#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123;  this-&gt;mName = name;  this-&gt;mAge = age; &#125; void showPerson() &#123;  cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;void test01()&#123; // 指定NameType 为string类型，AgeType 为 int类型 Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999); P1.showPerson();&#125;int main() &#123; test01(); return 0;&#125;\n\n类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板\n1.3.2 类模板与函数模板区别类模板与函数模板区别主要有两点：\n\n类模板没有自动类型推导的使用方式\n类模板在模板参数列表中可以有默认参数示例：\n\n#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123;  this-&gt;mName = name;  this-&gt;mAge = age; &#125; void showPerson() &#123;  cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;//1、类模板没有自动类型推导的使用方式void test01()&#123; // Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson();&#125;//2、类模板在模板参数列表中可以有默认参数void test02()&#123; Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson();&#125;int main() &#123; test01(); test02(); return 0;&#125;\n\n\n类模板使用只能用显示指定类型方式\n\n类模板中的模板参数列表可以有默认参数\n\n\n1.3.3 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的：\n\n普通类中的成员函数一开始就可以创建\n类模板中的成员函数在调用时才创建示例：\n\nclass Person1&#123;public: void showPerson1() &#123;  cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl; &#125;&#125;;class Person2&#123;public: void showPerson2() &#123;  cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl; &#125;&#125;;template&lt;class T&gt;class MyClass&#123;public: T obj; //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成 void fun1() &#123; obj.showPerson1(); &#125; void fun2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123; MyClass&lt;Person1&gt; m; m.fun1(); //m.fun2();//编译会出错，说明函数调用才会去创建成员函数&#125;int main() &#123; test01(); return 0;&#125;\n\n类模板中的成员函数并不是一开始就创建的，在调用时才去创建\n1.3.4 类模板对象做函数参数学习目标：\n\n类模板实例化出的对象，向函数传参的方式一共有三种传入方式：\n\n\n指定传入的类型   — 直接显示对象的数据类型\n参数模板化           — 将对象中的参数变为模板进行传递\n整个类模板化       — 将这个对象类型 模板化进行传递示例：\n\n#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123;  this-&gt;mName = name;  this-&gt;mAge = age; &#125; void showPerson() &#123;  cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;//1、指定传入的类型void printPerson1(Person&lt;string, int&gt; &amp;p)&#123; p.showPerson();&#125;void test01()&#123; Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100); printPerson1(p);&#125;//2、参数模板化template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123; p.showPerson(); cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123; Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90); printPerson2(p);&#125;//3、整个类模板化template&lt;class T&gt;void printPerson3(T &amp; p)&#123; cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl; p.showPerson();&#125;void test03()&#123; Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30); printPerson3(p);&#125;int main() &#123; test01(); test02(); test03(); return 0;&#125;\n\n\n通过类模板创建的对象，可以有三种方式向函数中进行传参\n\n使用比较广泛是第一种：指定传入的类型\n\n\n1.3.5 类模板与继承当类模板碰到继承时，需要注意一下几点：\n\n当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型\n如果不指定，编译器无法给子类分配内存\n如果想灵活指定出父类中T的类型，子类也需变为类模板示例：\n\ntemplate&lt;class T&gt;class Base&#123; T m;&#125;;//class Son:public Base  //错误，cpp编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承class Son :public Base&lt;int&gt; //必须指定一个类型&#123;&#125;;void test01()&#123; Son c;&#125;//类模板继承类模板 ,可以用T2指定父类中的T类型template&lt;class T1, class T2&gt;class Son2 :public Base&lt;T2&gt;&#123;public: Son2() &#123;  cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;  cout &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125;&#125;;void test02()&#123; Son2&lt;int, char&gt; child1;&#125;int main() &#123; test01(); test02(); return 0;&#125;\n\n如果父类是类模板，子类需要指定出父类中T的数据类型\n1.3.6 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数类外实现示例：\n#include &lt;string&gt;//类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person &#123;public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson();public: T1 m_Name; T2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123; Person&lt;string, int&gt; p(&quot;Tom&quot;, 20); p.showPerson();&#125;int main() &#123; test01(); return 0;&#125;\n\n类模板中成员函数类外实现时，需要加上模板参数列表\n1.3.7 类模板分文件编写学习目标：\n\n掌握类模板成员函数分文件编写产生的问题以及解决方式问题：\n类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到解决：\n解决方式1：直接包含.cpp源文件\n解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制示例：person.hpp中代码：\n\n#pragma once#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;template&lt;class T1, class T2&gt;class Person &#123;public: Person(T1 name, T2 age); void showPerson();public: T1 m_Name; T2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;\n\n类模板分文件编写.cpp中代码\n#include&lt;iostream&gt;using namespace std;//#include &quot;person.h&quot;#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp#include &quot;person.hpp&quot;void test01()&#123; Person&lt;string, int&gt; p(&quot;Tom&quot;, 10); p.showPerson();&#125;int main() &#123; test01(); return 0;&#125;\n\n主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp\n1.3.8 类模板与友元学习目标：\n\n掌握类模板配合友元函数的类内和类外实现全局函数类内实现 - 直接在类内声明友元即可全局函数类外实现 - 需要提前让编译器知道全局函数的存在示例：\n\n#include &lt;string&gt;//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元template&lt;class T1, class T2&gt; class Person;//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p);template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt; &amp; p)&#123; cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1, class T2&gt;class Person&#123; //1、全局函数配合友元   类内实现 friend void printPerson(Person&lt;T1, T2&gt; &amp; p) &#123;  cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; //全局函数配合友元  类外实现 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);public: Person(T1 name, T2 age) &#123;  this-&gt;m_Name = name;  this-&gt;m_Age = age; &#125;private: T1 m_Name; T2 m_Age;&#125;;//1、全局函数在类内实现void test01()&#123; Person &lt;string, int &gt;p(&quot;Tom&quot;, 20); printPerson(p);&#125;//2、全局函数在类外实现void test02()&#123; Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30); printPerson2(p);&#125;int main() &#123; //test01(); test02(); return 0;&#125;\n\n建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n1.3.9 类模板案例案例描述:  实现一个通用的数组类，要求如下：\n\n可以对内置数据类型以及自定义数据类型的数据进行存储\n将数组中的数据存储到堆区\n构造函数中可以传入数组的容量\n提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题\n提供尾插法和尾删法对数组中的数据进行增加和删除\n可以通过下标的方式访问数组中的元素\n可以获取数组中当前元素个数和数组的容量示例：myArray.hpp中代码\n\n#pragma once#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class MyArray&#123;public: //构造函数 MyArray(int capacity) &#123;  this-&gt;m_Capacity = capacity;  this-&gt;m_Size = 0;  pAddress = new T[this-&gt;m_Capacity]; &#125; //拷贝构造 MyArray(const MyArray &amp; arr) &#123;  this-&gt;m_Capacity = arr.m_Capacity;  this-&gt;m_Size = arr.m_Size;  this-&gt;pAddress = new T[this-&gt;m_Capacity];  for (int i = 0; i &lt; this-&gt;m_Size; i++)  &#123;   //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，   // 普通类型可以直接= 但是指针类型需要深拷贝   this-&gt;pAddress[i] = arr.pAddress[i];  &#125; &#125; //重载= 操作符  防止浅拷贝问题 MyArray&amp; operator=(const MyArray&amp; myarray) &#123;  if (this-&gt;pAddress != NULL) &#123;   delete[] this-&gt;pAddress;   this-&gt;m_Capacity = 0;   this-&gt;m_Size = 0;  &#125;  this-&gt;m_Capacity = myarray.m_Capacity;  this-&gt;m_Size = myarray.m_Size;  this-&gt;pAddress = new T[this-&gt;m_Capacity];  for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123;   this-&gt;pAddress[i] = myarray[i];  &#125;  return *this; &#125; //重载[] 操作符  arr[0] T&amp; operator [](int index) &#123;  return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理 &#125; //尾插法 void Push_back(const T &amp; val) &#123;  if (this-&gt;m_Capacity *** this-&gt;m_Size)  &#123;   return;  &#125;  this-&gt;pAddress[this-&gt;m_Size] = val;  this-&gt;m_Size++; &#125; //尾删法 void Pop_back() &#123;  if (this-&gt;m_Size *** 0)  &#123;   return;  &#125;  this-&gt;m_Size--; &#125; //获取数组容量 int getCapacity() &#123;  return this-&gt;m_Capacity; &#125; //获取数组大小 int getSize() &#123;  return this-&gt;m_Size; &#125; //析构 ~MyArray() &#123;  if (this-&gt;pAddress != NULL)  &#123;   delete[] this-&gt;pAddress;   this-&gt;pAddress = NULL;   this-&gt;m_Capacity = 0;   this-&gt;m_Size = 0;  &#125; &#125;private: T * pAddress;  //指向一个堆空间，这个空间存储真正的数据 int m_Capacity; //容量 int m_Size;   // 大小&#125;;\n\n类模板案例—数组类封装.cpp中\n#include &quot;myArray.hpp&quot;#include &lt;string&gt;void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123;  cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//测试内置数据类型void test01()&#123; MyArray&lt;int&gt; array1(10); for (int i = 0; i &lt; 10; i++) &#123;  array1.Push_back(i); &#125; cout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl; printIntArray(array1); cout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; MyArray&lt;int&gt; array2(array1); array2.Pop_back(); cout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl; printIntArray(array2); cout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;&#125;//测试自定义数据类型class Person &#123;public: Person() &#123;&#125;  Person(string name, int age) &#123;  this-&gt;m_Name = name;  this-&gt;m_Age = age; &#125;public: string m_Name; int m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)&#123; for (int i = 0; i &lt; personArr.getSize(); i++) &#123;  cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl; &#125;&#125;void test02()&#123; //创建数组 MyArray&lt;Person&gt; pArray(10); Person p1(&quot;孙悟空&quot;, 30); Person p2(&quot;韩信&quot;, 20); Person p3(&quot;妲己&quot;, 18); Person p4(&quot;王昭君&quot;, 15); Person p5(&quot;赵云&quot;, 24); //插入数据 pArray.Push_back(p1); pArray.Push_back(p2); pArray.Push_back(p3); pArray.Push_back(p4); pArray.Push_back(p5); printPersonArray(pArray); cout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); return 0;&#125;\n\n能够利用所学知识点实现通用的数组\n二、STL初识容器vector&lt;int&gt; v;  // 创建容器v.push_back(10);//向容器中放数据v.begin() //返回第一个元素v.end()  //返回最后一个元素/* 遍历 *///1.for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl;&#125;//2.for (auto it = v.begin(); it != v.end(); it ++)&#123;    cout &lt;&lt; *it &lt;&lt; endl;&#125;//3.#include &lt;algorithm&gt;void MyPrint(int val)&#123; cout &lt;&lt; val &lt;&lt; endl;&#125;for_each(v.begin(), v.end(), MyPrint);\n\n\n存放自定义数据的时候，初始化容器数据是要使用数据类型的构造函数。访问时使用(*it).member\n\n存放对象指针：vector&lt;class *&gt; v ，放入数据时要放入地址：v.push_back(&amp;Object)\n\n容器嵌套容器：vector&lt;vector&lt;int&gt;&gt; v，遍历时要用嵌套for循环。迭代器种类：\n\n\n\n种类\n功能\n支持运算\n\n\n\n输入迭代器\n对数据的只读访问\n只读，支持++、***、!=\n\n\n输出迭代器\n对数据的只写访问\n只写，支持++\n\n\n前向迭代器\n读写操作，并能向前推进迭代器\n读写，支持++、***、!=\n\n\n双向迭代器\n读写操作，并能向前和向后操作\n读写，支持++、--，\n\n\n随机访问迭代器\n读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器\n读写，支持++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=\n\n\n常用的容器中迭代器种类为双向迭代器，和随机访问迭代器\n\n\n\n\n\n\nstring本质上是一个类char *是一个指针，而string是一个类，内部封装了char *，来管理这个字符串，所以string是一个char *型的容器\n\n\n\n方法\n作用\n\n\n\nfind\n查找\n\n\ncopy\n拷贝\n\n\ndelete\n删除\n\n\nreplace\n替换\n\n\ninsert\n插入\n\n\n构造函数string();//创建一个空的字符串 例如: string str;string(const char* s);//使用字符串s初始化string(const string&amp; str);//使用一个string对象初始化另一个string对象string(int n, char c);//使用n个字符c初始化\n\n赋值string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串string&amp; operator=(char c);//字符赋值给当前的字符串string&amp; assign(const char *s);//把字符串s赋给当前的字符串string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串string&amp; assign(int n, char c);//用n个字符c赋给当前字符串\n\n带operator&#x3D;的是等号运算符重载，即可以用另一个数据和=给其赋值，assingn则是成员函数，需要调用函数才能赋值\n字符串拼接string&amp; operator+=(const char* str);//重载+=操作符string&amp; operator+=(const char c);//重载+=操作符string&amp; operator+=(const string&amp; str);//重载+=操作符string&amp; append(const char *s);//把字符串s连接到当前字符串结尾string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾string&amp; append(const string &amp;s);//同operator+=(const string&amp; str)string&amp; append(const string &amp;s, int pos, int n); //字符串s中从pos开始的n个字符连接到字符串结尾\n\n查找替换int find(const string&amp; str, int pos = 0) const;//查找str第一次出现位置,从pos开始查找int find(const char* s, int pos = 0) const;//查找s第一次出现位置,从pos开始查找int find(const char* s, int pos, int n) const;//从pos位置查找s的前n个字符第一次位置int find(const char c, int pos = 0) const;//查找字符c第一次出现位置int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置int rfind(const char c, int pos = 0) const;//查找字符c最后一次出现位置string&amp; replace(int pos, int n, const string&amp; str);//替换从pos开始n个字符为字符串strstring&amp; replace(int pos, int n,const char* s);//替换从pos开始的n个字符为字符串s\n\nﬁnd查找是从左往后，rﬁnd从右往左ﬁnd找到字符串后返回查找的第一个字符位置，找不到返回-1replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串\n字符串的比较int compare(const string &amp;s) const;//与字符串s比较int compare(const char *s) const;//与字符串s比较//比较ASCII码//= 返回0//&gt; 返回1//&lt; 返回-1\n\n单个字符存取char&amp; operator[](int n);//通过[]方式取字符char&amp; at(int n);//通过at方法获取字符\n\n插入和删除string&amp; insert(int pos, const char* s);//插入字符串string&amp; insert(int pos, const string&amp; str);//插入字符串string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符cstring&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符\n\n字符串子串string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串\n\nvector单端数组，可以动态扩展，但扩展时不是直接接上，而是寻找更大的空间拷贝过去，释放原来的空间\n构造函数vector&lt;T&gt; v;//采用模板实现类实现，默认构造函数vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。vector(n, element);//构造函数将n个elem拷贝给本身。vector(const vector &amp;vec);//拷贝构造函数。\n\n赋值vector&amp; operator=(const vector &amp;vec); //重载等号操作符assign(begin, end);//将[begin, end)区间中的数据拷贝赋值给本身。assign(n, element);//将n个elem拷贝赋值给本身。\n\n容量和大小empty(); //判断容器是否为空capacity(); //容器的容量size(); //返回容器中元素的个数resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除\n\n插入和删除push_back(ele);//尾部插入元素elepop_back();//删除最后一个元素insert(const_iterator pos, ele);//迭代器指向位置pos插入元素eleinsert(const_iterator pos, int count,ele); //迭代器指向位置pos插入count个元素eleerase(const_iterator pos);//删除迭代器指向的元素erase(const_iterator start, const_iterator end); //删除迭代器从start到end之间的元素clear();//删除容器中所有元素\n\n数据存取at(int idx);//返回索引idx所指的数据operator[];//返回索引idx所指的数据front();//返回容器中第一个数据元素back();//返回容器中最后一个数据元素\n\n两个容器交换swap(vec);// 将vec与本身的元素互换\n\n预留空间reserve(int len); //容器预留len个元素长度，预留位置不初始化，元素不可访问。\n\n目的是减少动态扩展时的扩展次数\ndeque双端数组，头尾均可插入或删除，头部插入比vector快，但访问元素的速度没有vector快deque是一片连续的内存空间\n构造函数deque&lt;T&gt; deqT;//默认构造形式deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。deque(n, elem);//构造函数将n个elem拷贝给本身。deque(const deque &amp;deq);//拷贝构造函数\n\n赋值deque&amp; operator=(const deque &amp;deq);//重载等号操作符assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。\n\n容量和大小deque.empty(); //判断容器是否为空deque.size(); //返回容器中元素的个数deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。\n\n插入和删除push_back(elem);//在容器尾部添加一个数据push_front(elem);//在容器头部插入一个数据pop_back();//删除容器最后一个数据pop_front();//删除容器第一个数据insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。clear(); //清空容器的所有数据erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos); //删除pos位置的数据，返回下一个数据的位置。\n\n数据存取：\nat(int idx);//返回索引idx所指的数据operator[];//返回索引idx所指的数据front();//返回容器中第一个数据元素back();//返回容器中最后一个数据元素\n\n排序sort(iterator beg, iterator end)//对beg和end区间内元素进行排序\n\nstack先进后出，只有顶部的元素才可以使用，因此无法遍历，push入栈，pop出栈\n常用接口//构造函数：stack&lt;T&gt; stk;//stack采用模板类实现， stack对象的默认构造形式stack(const stack &amp;stk);//拷贝构造函数//赋值操作：stack&amp; operator=(const stack &amp;stk);//数据存取：push(elem);//向栈顶添加元素pop();//从栈顶移除第一个元素top();//返回栈顶元素//大小操作：empty();//判断堆栈是否为空size();//返回栈的大小\n\nqueue先进先出，一端进一端出，只有头尾可以被使用，因此也不能遍历\n常用接口//构造函数：queue&lt;T&gt; que;//queue采用模板类实现，queue对象的默认构造形式queue(const queue &amp;que);//拷贝构造函数//赋值操作：queue&amp; operator=(const queue &amp;que);//重载等号操作符//数据存取：push(elem);//往队尾添加元素pop();//从队头移除第一个元素back();//返回最后一个元素front();//返回第一个元素//大小操作：empty();//判断堆栈是否为空size();//返回栈的大小\n\nlist链表，一系列指针链组成，是一个双向循环链表，储存不是连续的内存空间，list的迭代器只支持前移和后移，属于双向迭代器采用动态储存分配，不会造成内存浪费或溢出，插入删除只需要修改指针，灵活，但空间和时间消耗大重要性质： 插入和删除都不会造成原有的迭代器失效，vector是不可以的另外list和vector是最常用的两个容器，各有优缺点\n常用接口//构造函数list&lt;T&gt; lst;//list采用采用模板类实现,对象的默认构造形式：list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。list(n,elem);//构造函数将n个elem拷贝给本身。list(const list &amp;lst);//拷贝构造函数。//赋值和交换assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。list&amp; operator=(const list &amp;lst);swap(lst);//重载等号操作符//将lst与本身的元素互换。//大小size(); //返回容器中元素的个数empty(); //判断容器是否为空resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。//插入和删除push_back(elem);//在容器尾部加入一个元素pop_back();//删除容器中最后一个元素push_front(elem);//在容器开头插入一个元素pop_front();//从容器开头移除第一个元素insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos);//删除pos位置的数据，返回下一个数据的位置。remove(elem);//删除容器中所有与elem值匹配的元素。//存取front();//返回第一个元素。back();//返回最后一个元素。//反转和排序reverse();//反转链表sort();//链表排序\n\nset和multiset所有元素在插入时就被自动排列属关联式容器，底层结构是二叉树实现的set不允许有重复的元素，multiset可以有重复的元素；set插入数据后会返回结果，表示是否插入成功，而multiset一定可以成功，所以不会检测数据\n常用接口//构造：set&lt;T&gt; st;//默认构造函数：set(const set &amp;st);//拷贝构造函数//赋值：set&amp; operator=(const set &amp;st);//重载等号操作符//大小和交换size();//返回容器中元素的数目empty();//判断容器是否为空swap(st);//交换两个集合容器//插入和删除insert(elem);//在容器中插入元素。clear();//清除所有元素erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(elem);//删除容器中值为elem的元素。//查找和统计find(key);//查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();count(key);//统计key的元素个数\n\nset的默认排序规则为从小到大，利用仿函数可以改变规则\n#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;class myCompare&#123;public:bool operator()(int v1, int v2)&#123; return v1 &gt; v2;&#125;&#125;;void test()&#123; set&lt;int&gt; set_1; set_1.insert(1); set_1.insert(2); set_1.insert(3); set_1.insert(4); set_1.insert(5); set_1.insert(6); for (auto it = set_1.begin(); it != set_1.end(); it++)&#123;  std::cout &lt;&lt; *it &lt;&lt; &quot; &quot; &lt;&lt; &quot;\\n&quot; ; &#125; set&lt;int, myCompare&gt; set_2; set_2.insert(2); set_2.insert(3); set_2.insert(1); set_2.insert(5); set_2.insert(4); set_2.insert(6); for (auto it = set_2.begin(); it != set_2.end(); it++)&#123;  std::cout &lt;&lt; *it &lt;&lt; &quot; &quot; &lt;&lt; &quot;\\n&quot; ; &#125;&#125;int main(int argc, char const *argv[])&#123;    test(); return 0;&#125;\n\n当使用自定义数据类型时，set必须指定排序规则才可以插入数据\npair成对出现的数据可以使用pair\n常用接口//创建方式pair&lt;type, type&gt; p ( value1, value2 );pair&lt;type, type&gt; p = make_pair( value1, value2 );\n\nmap和multimap所有的元素都是pair，其中第一个元素是key，第二个是value，所有元素都会根据元素的key进行自动排序属于关联式容器，底层结构是用二叉树实现可以通过key值快速找到valuemap不能有重复的key，multimap可以有重复的key\n常用接口//构造：map&lt;T1, T2&gt; mp;//map默认构造函数:map(const map &amp;mp);//拷贝构造函数//赋值：map&amp; operator=(const map &amp;mp);//大小和交换size();//返回容器中元素的数目empty();//判断容器是否为空swap(st);//交换两个集合容器//插入和删除insert(elem);//在容器中插入元素。clear();//清除所有元素erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(key);//删除容器中值为key的元素。//查找和统计find(key);//查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();count(key);//统计key的元素个数\n\n也可以利用仿函数指定排序规则\n函数对象重载函数调用操作符的类，其对象称为函数对象函数对象使用重载时，行为类似函数调用，所以也叫仿函数是一个类而非函数函数对象可以有参数也可以有返回值但函数对象超出普通函数的概念，有自己的状态函数对象可以作为参数进行传递\n#include &lt;iostream&gt;using namespace std;class add&#123;public:    add()&#123;        count = 0;    &#125;    int operator()(int v1, int v2)&#123;        count ++;        return v1 + v2;    &#125;    int count = 0;&#125;;void test()&#123;    add add;    add.operator()(1,2);    add.operator()(1,3);    add.operator()(1,2);    add.operator()(1,2);    cout &lt;&lt; add.count &lt;&lt; endl;&#125;int main()&#123;    test();    return 0;&#125;\n\nThe keys of cpp comparing to c language is Object-oriented and Generic programming.\ncount类似于find,可查找字符串中某个字符出现的次数。\nstring s = &quot;abcdefgaaadsasafas&quot;;int numOfA = s.count(&#x27;a&#x27;);\n\n当map类的数据使用count的时候，传入的参数应是key而非value。\n三、函数对象4.1 函数对象4.1.1 函数对象概念概念：\n\n重载函数调用操作符的类，其对象常称为函数对象\n函数对象使用重载的()时，行为类似函数调用，也叫仿函数本质：函数对象(仿函数)是一个类，不是一个函数\n\n4.1.2  函数对象使用特点：\n\n函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值\n函数对象超出普通函数的概念，函数对象可以有自己的状态\n函数对象可以作为参数传递示例:\n\n#include &lt;string&gt;//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值class MyAdd&#123;public : int operator()(int v1,int v2) &#123;  return v1 + v2; &#125;&#125;;void test01()&#123; MyAdd myAdd; cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;&#125;//2、函数对象可以有自己的状态class MyPrint&#123;public: MyPrint() &#123;  count = 0; &#125; void operator()(string test) &#123;  cout &lt;&lt; test &lt;&lt; endl;  count++; //统计使用次数 &#125; int count; //内部自己的状态&#125;;void test02()&#123; MyPrint myPrint; myPrint(&quot;hello world&quot;); myPrint(&quot;hello world&quot;); myPrint(&quot;hello world&quot;); cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl;&#125;//3、函数对象可以作为参数传递void doPrint(MyPrint &amp;mp , string test)&#123; mp(test);&#125;void test03()&#123; MyPrint myPrint; doPrint(myPrint, &quot;Hello cpp&quot;);&#125;int main() &#123; //test01(); //test02(); test03(); return 0;&#125;\n\n总结：\n\n仿函数写法非常灵活，可以作为参数进行传递。\n\n4.2  谓词4.2.1 谓词概念概念：\n\n返回bool类型的仿函数称为谓词\n如果operator()接受一个参数，那么叫做一元谓词\n如果operator()接受两个参数，那么叫做二元谓词\n\n4.2.2 一元谓词示例：\n#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123; bool operator()(int val) &#123;  return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123;  v.push_back(i); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it *** v.end()) &#123;  cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n参数只有一个的谓词，称为一元谓词\n\n4.2.3 二元谓词示例：\n#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public: bool operator()(int num1, int num2) &#123;  return num1 &gt; num2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;  cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;  cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n参数只有两个的谓词，称为二元谓词\n\n4.3 内建函数对象4.3.1 内建函数对象意义概念：\n\nSTL内建了一些函数对象分类:\n算术仿函数\n关系仿函数\n逻辑仿函数用法：\n这些仿函数所产生的对象，用法和一般函数完全相同\n使用内建函数对象，需要引入头文件 #include &lt;functional&gt;\n\n4.3.2 算术仿函数功能描述：\n\n实现四则运算\n其中negate是一元运算，其他都是二元运算仿函数原型：\ntemplate&lt;class T&gt; T plus&lt;T&gt;                &#x2F;&#x2F;加法仿函数\ntemplate&lt;class T&gt; T minus&lt;T&gt;              &#x2F;&#x2F;减法仿函数\ntemplate&lt;class T&gt; T multiplies&lt;T&gt;    &#x2F;&#x2F;乘法仿函数\ntemplate&lt;class T&gt; T divides&lt;T&gt;         &#x2F;&#x2F;除法仿函数\ntemplate&lt;class T&gt; T modulus&lt;T&gt;         &#x2F;&#x2F;取模仿函数\ntemplate&lt;class T&gt; T negate&lt;T&gt;           &#x2F;&#x2F;取反仿函数示例：\n\n#include &lt;functional&gt;//negatevoid test01()&#123; negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl;&#125;//plusvoid test02()&#123; plus&lt;int&gt; p; cout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125;\n\n\n使用内建函数对象时，需要引入头文件 #include &lt;functional&gt;\n\n4.3.3 关系仿函数功能描述：\n\n实现关系对比仿函数原型：\n\ntemplate&lt;class T&gt; bool equal_to&lt;T&gt;                    &#x2F;&#x2F;等于\n\ntemplate&lt;class T&gt; bool not_equal_to&lt;T&gt;            &#x2F;&#x2F;不等于\n\ntemplate&lt;class T&gt; bool greater&lt;T&gt;                      &#x2F;&#x2F;大于\n\ntemplate&lt;class T&gt; bool greater_equal&lt;T&gt;          &#x2F;&#x2F;大于等于\n\ntemplate&lt;class T&gt; bool less&lt;T&gt;                           &#x2F;&#x2F;小于\n\ntemplate&lt;class T&gt; bool less_equal&lt;T&gt;               &#x2F;&#x2F;小于等于示例：\n\n\n#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public: bool operator()(int v1,int v2) &#123;  return v1 &gt; v2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;  cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数  大于仿函数 sort(v.begin(), v.end(), greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;  cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n关系仿函数中最常用的就是greater&lt;&gt;大于\n4.3.4 逻辑仿函数功能描述：\n\n实现逻辑运算函数原型：\n\ntemplate&lt;class T&gt; bool logical_and&lt;T&gt;              &#x2F;&#x2F;逻辑与\n\ntemplate&lt;class T&gt; bool logical_or&lt;T&gt;                &#x2F;&#x2F;逻辑或\n\ntemplate&lt;class T&gt; bool logical_not&lt;T&gt;              &#x2F;&#x2F;逻辑非示例：\n\n\n#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123; vector&lt;bool&gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++) &#123;  cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //逻辑非  将v容器搬运到v2中，并执行逻辑非运算 vector&lt;bool&gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;bool&gt;()); for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++) &#123;  cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n逻辑仿函数实际应用较少，了解即可\n\n四、STL常用算法Algorithm概述:\n\n算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。\n&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等\n&lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数\n&lt;functional&gt;定义了一些模板类,用以声明函数对象。\n\n5.1 常用遍历算法学习目标：\n\n掌握常用的遍历算法算法简介：\nfor_each     &#x2F;&#x2F;遍历容器\ntransform   &#x2F;&#x2F;搬运容器到另一个容器中\n\n5.1.1 for_each功能描述：\n\n实现遍历容器函数原型：\nfor_each(iterator beg, iterator end, _func);&#x2F;&#x2F; 遍历算法 遍历容器元素&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; _func 函数或者函数对象示例：\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;//函数对象class print02&#123; public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;//for_each算法基本用法void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123;  v.push_back(i); &#125; //遍历算法 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\nfor_each在实际开发中是最常用遍历算法，需要熟练掌握\n\n5.1.2 transform功能描述：\n\n搬运容器到另一个容器中函数原型：\ntransform(iterator beg1, iterator end1, iterator beg2, _func);&#x2F;&#x2F;beg1 源容器开始迭代器&#x2F;&#x2F;end1 源容器结束迭代器&#x2F;&#x2F;beg2 目标容器开始迭代器&#x2F;&#x2F;_func 函数或者函数对象示例：\n\n#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法  搬运 transformclass TransForm&#123;public: int operator()(int val) &#123;  return val; &#125;&#125;;class MyPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123;  v.push_back(i); &#125; vector&lt;int&gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123; test01(); return 0;&#125;\n\n\n搬运的目标容器必须要提前开辟空间，否则无法正常搬运也可以用来转换大小写：\n\ntransform(str.begin(),str.end(),str.begin(),::tolower); transform(str.begin(),str.end(),str.begin(),::toupper);\n\n5.2 常用查找算法学习目标：\n\n掌握常用的查找算法算法简介：\nfind                     &#x2F;&#x2F;查找元素\nfind_if               &#x2F;&#x2F;按条件查找元素\nadjacent_find    &#x2F;&#x2F;查找相邻重复元素\nbinary_search    &#x2F;&#x2F;二分查找法\ncount                   &#x2F;&#x2F;统计元素个数\ncount_if             &#x2F;&#x2F;按条件统计元素个数\n\n5.2.1 find功能描述：\n\n查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()函数原型：\n\nfind(iterator beg, iterator end, value);&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; value 查找的元素示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123;  v.push_back(i + 1); &#125; //查找容器中是否有 5 这个元素 vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5); if (it *** v.end()) &#123;  cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;class Person &#123;public: Person(string name, int age) &#123;  this-&gt;m_Name = name;  this-&gt;m_Age = age; &#125; //重载*** bool operator***(const Person&amp; p) &#123;  if (this-&gt;m_Name *** p.m_Name &amp;&amp; this-&gt;m_Age *** p.m_Age)  &#123;   return true;  &#125;  return false; &#125;public: string m_Name; int m_Age;&#125;;void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2); if (it *** v.end()) &#123;  cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125;\n\n\n利用find可以在容器中找指定的元素，返回值是迭代器\n\n5.2.2 find_if功能描述：\n\n按条件查找元素函数原型：\n\nfind_if(iterator beg, iterator end, _Pred);&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public: bool operator()(int val) &#123;  return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123;  v.push_back(i + 1); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it *** v.end()) &#123;  cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;//自定义数据类型class Person &#123;public: Person(string name, int age) &#123;  this-&gt;m_Name = name;  this-&gt;m_Age = age; &#125;public: string m_Name; int m_Age;&#125;;class Greater20&#123;public: bool operator()(Person &amp;p) &#123;  return p.m_Age &gt; 20; &#125;&#125;;void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it *** v.end()) &#123;  cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125;int main() &#123; //test01(); test02(); return 0;&#125;\n\n\nfind_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略\n\n5.2.3 adjacent_find功能描述：\n\n查找相邻重复元素函数原型：\n\nadjacent_find(iterator beg, iterator end);&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it *** v.end()) &#123;  cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;\n\n\n面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法\n\n5.2.4 binary_search功能描述：\n\n查找指定元素是否存在函数原型：\n\nbool binary_search(iterator beg, iterator end, value);&#x2F;&#x2F; 查找指定的元素，查到 返回true  否则false&#x2F;&#x2F; 注意: 在无序序列中不可用&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; value 查找的元素示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123;  v.push_back(i); &#125; //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) &#123;  cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl; &#125; else &#123;  cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); return 0;&#125;\n\n总结： 二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列\n5.2.5 count功能描述：\n\n统计元素个数函数原型：\n\ncount(iterator beg, iterator end, value);&#x2F;&#x2F; 统计元素出现次数&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; value 统计的元素示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public: Person(string name, int age) &#123;  this-&gt;m_Name = name;  this-&gt;m_Age = age; &#125; bool operator***(const Person &amp; p) &#123;  if (this-&gt;m_Age *** p.m_Age)  &#123;   return true;  &#125;  else  &#123;   return false;  &#125; &#125; string m_Name; int m_Age;&#125;;void test02()&#123; vector&lt;Person&gt; v; Person p1(&quot;刘备&quot;, 35); Person p2(&quot;关羽&quot;, 35); Person p3(&quot;张飞&quot;, 35); Person p4(&quot;赵云&quot;, 30); Person p5(&quot;曹操&quot;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5);    Person p(&quot;诸葛亮&quot;,35); int num = count(v.begin(), v.end(), p); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); return 0;&#125;\n\n\n统计自定义数据类型时候，需要配合重载 operator***\n\n5.2.6 count_if功能描述：\n\n按条件统计元素个数函数原型：\n\ncount_if(iterator beg, iterator end, _Pred);&#x2F;&#x2F; 按条件统计元素出现次数&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; _Pred 谓词示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public: bool operator()(int val) &#123;  return val &gt;= 4; &#125;&#125;;//内置数据类型void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public: Person(string name, int age) &#123;  this-&gt;m_Name = name;  this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;class AgeLess35&#123;public: bool operator()(const Person &amp;p) &#123;  return p.m_Age &lt; 35; &#125;&#125;;void test02()&#123; vector&lt;Person&gt; v; Person p1(&quot;刘备&quot;, 35); Person p2(&quot;关羽&quot;, 35); Person p3(&quot;张飞&quot;, 35); Person p4(&quot;赵云&quot;, 30); Person p5(&quot;曹操&quot;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); return 0;&#125;\n\n\n按值统计用count，按条件统计用count_if\n\n5.3 常用排序算法学习目标：\n\n掌握常用的排序算法算法简介：\nsort             &#x2F;&#x2F;对容器内元素进行排序\nrandom_shuffle   &#x2F;&#x2F;洗牌   指定范围内的元素随机调整次序\nmerge           &#x2F;&#x2F; 容器元素合并，并存储到另一容器中\nreverse       &#x2F;&#x2F; 反转指定范围的元素\n\n5.3.1 sort功能描述：\n\n对容器内元素进行排序函数原型：\n\nsort(iterator beg, iterator end, _Pred);&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置&#x2F;&#x2F;  beg    开始迭代器&#x2F;&#x2F;  end    结束迭代器&#x2F;&#x2F; _Pred  谓词示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01() &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\nsort属于开发中最常用的算法之一，需熟练掌握\n\n5.3.2 random_shuffle功能描述：\n\n洗牌   指定范围内的元素随机调整次序函数原型：\n\nrandom_shuffle(iterator beg, iterator end);&#x2F;&#x2F; 指定范围内的元素随机调整次序&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; srand((unsigned int)time(NULL)); vector&lt;int&gt; v; for(int i = 0 ; i &lt; 10;i++) &#123;  v.push_back(i); &#125; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //打乱顺序 random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\nrandom_shuffle洗牌算法比较实用，使用时记得加随机数种子\n\n5.3.3 merge功能描述：\n\n两个容器元素合并，并存储到另一容器中函数原型：\n\nmerge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);&#x2F;&#x2F; 容器元素合并，并存储到另一容器中&#x2F;&#x2F; 注意: 两个容器必须是有序的&#x2F;&#x2F; beg1   容器1开始迭代器&#x2F;&#x2F; end1   容器1结束迭代器&#x2F;&#x2F; beg2   容器2开始迭代器&#x2F;&#x2F; end2   容器2结束迭代器&#x2F;&#x2F; dest    目标容器开始迭代器示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10 ; i++)    &#123;  v1.push_back(i);  v2.push_back(i + 1); &#125; vector&lt;int&gt; vtarget; //目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并  需要两个有序序列 merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\nmerge合并的两个容器必须的有序序列\n\n5.3.4 reverse功能描述：\n\n将容器内元素进行反转函数原型：\n\nreverse(iterator beg, iterator end);&#x2F;&#x2F; 反转指定范围的元素&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\nreverse反转区间内元素，面试题可能涉及到\n\n5.4 常用拷贝和替换算法学习目标：\n\n掌握常用的拷贝和替换算法算法简介：\ncopy                      &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中\nreplace                &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素\nreplace_if          &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素\nswap                     &#x2F;&#x2F; 互换两个容器的元素\n\n5.4.1 copy功能描述：\n\n容器内指定范围的元素拷贝到另一容器中函数原型：\n\ncopy(iterator beg, iterator end, iterator dest);&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置&#x2F;&#x2F; beg  开始迭代器&#x2F;&#x2F; end  结束迭代器&#x2F;&#x2F; dest 目标起始迭代器示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123;  v1.push_back(i + 1); &#125; vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;int main() &#123; test01(); return 0;&#125;\n\n\n利用copy算法在拷贝时，目标容器记得提前开辟空间\n\n5.4.2 replace功能描述：\n\n将容器内指定范围的旧元素修改为新元素函数原型：\n\nreplace(iterator beg, iterator end, oldvalue, newvalue);&#x2F;&#x2F; 将区间内旧元素 替换成 新元素&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; oldvalue 旧元素&#x2F;&#x2F; newvalue 新元素示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中的20 替换成 2000 cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\nreplace会替换区间内满足条件的元素\n\n5.4.3 replace_if功能描述:\n\n将区间内满足条件的元素，替换成指定元素函数原型：\n\nreplace_if(iterator beg, iterator end, _pred, newvalue);&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; _pred 谓词&#x2F;&#x2F; newvalue 替换的新元素示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;class ReplaceGreater30&#123;public: bool operator()(int val) &#123;  return val &gt;= 30; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中大于等于的30 替换成 3000 cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\nreplace_if按条件查找，可以利用仿函数灵活筛选满足的条件\n\n5.4.4 swap功能描述：\n\n互换两个容器的元素函数原型：\n\nswap(container c1, container c2);&#x2F;&#x2F; 互换两个容器的元素&#x2F;&#x2F; c1容器1&#x2F;&#x2F; c2容器2示例：\n\n\n#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123;  v1.push_back(i);  v2.push_back(i+100); &#125; cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\nswap交换容器时，注意交换的容器要同种类型\n\n5.5 常用算术生成算法学习目标：\n\n掌握常用的算术生成算法注意：\n\n算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt;算法简介：\n\naccumulate      &#x2F;&#x2F; 计算容器元素累计总和\n\nfill                 &#x2F;&#x2F; 向容器中添加元素\n\n\n5.5.1 accumulate功能描述：\n\n计算区间内 容器元素累计总和函数原型：\n\naccumulate(iterator beg, iterator end, value);&#x2F;&#x2F; 计算容器元素累计总和&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; value 起始值示例：\n\n\n#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt;= 100; i++) &#123;  v.push_back(i); &#125; int total = accumulate(v.begin(), v.end(), 0); cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\naccumulate使用时头文件注意是 numeric，这个算法很实用\n\n5.5.2 fill功能描述：\n\n向容器中填充指定的元素函数原型：\n\nfill(iterator beg, iterator end, value);&#x2F;&#x2F; 向容器中填充元素&#x2F;&#x2F; beg 开始迭代器&#x2F;&#x2F; end 结束迭代器&#x2F;&#x2F; value 填充的值示例：\n\n\n#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.resize(10); //填充 fill(v.begin(), v.end(), 100); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n利用fill可以将容器区间内元素填充为指定的值\n\n5.6 常用集合算法学习目标：\n\n掌握常用的集合算法算法简介：\nset_intersection          &#x2F;&#x2F; 求两个容器的交集\nset_union                       &#x2F;&#x2F; 求两个容器的并集\nset_difference              &#x2F;&#x2F; 求两个容器的差集\n\n5.6.1 set_intersection功能描述：\n\n求两个容器的交集函数原型：\n\nset_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);&#x2F;&#x2F; 求两个集合的交集&#x2F;&#x2F; 注意：两个集合必须是有序序列&#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器示例：\n\n\n#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++)    &#123;  v1.push_back(i);  v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd =        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n总结：\n\n求交集的两个集合必须的有序序列\n目标容器开辟空间需要从两个容器中取小值\nset_intersection返回值既是交集中最后一个元素的位置\n\n5.6.2 set_union功能描述：\n\n求两个集合的并集函数原型：\n\nset_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);&#x2F;&#x2F; 求两个集合的并集&#x2F;&#x2F; 注意:两个集合必须是有序序列&#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器示例：\n\n\n#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123;  v1.push_back(i);  v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个容器的和给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd =        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n总结：\n\n求并集的两个集合必须的有序序列\n目标容器开辟空间需要两个容器相加\nset_union返回值既是并集中最后一个元素的位置\n\n5.6.3  set_difference功能描述：\n\n求两个集合的差集函数原型：\n\nset_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);&#x2F;&#x2F; 求两个集合的差集&#x2F;&#x2F; 注意:两个集合必须是有序序列&#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器示例：\n\n\n#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123;  v1.push_back(i);  v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个里面较大的值给目标容器开辟空间 vTarget.resize( max(v1.size() , v2.size())); //返回目标容器的最后一个元素的迭代器地址 cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl; vector&lt;int&gt;::iterator itEnd =        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125;\n\n\n求差集的两个集合必须的有序序列\n目标容器开辟空间需要从两个容器取较大值\nset_difference返回值既是差集中最后一个元素的位置\n\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","cpp"]},{"title":"C Plus Plus - Skill","url":"/2022/05/25/note/Programming/Language/cpp-4/","content":"C++ 技巧1\n\n\nvirtual函数虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型。\n静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰。\n构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。\n多态本质上是，利用继承和虚函数实现多种不同的类调用同一个函数，此函数在不同的子类中有不同的实现，但函数名一样。\n模板模板函数提供一种操作，但支持多种数据类型，可有效减少代码量，适用于多种数据进行同类型操作\ntemplate &lt;typename T&gt;void swap(T &amp;a, T &amp;b)&#123;    T temp = a;    a = b;    b = temp;&#125;int a = 10;int b = 20;swap(a, b); //自动推导数据类型swap&lt;int&gt;(a, b);  //指定数据类型\n\n声明中typename与class没有差别自动推导数据类型时，必须推导出一致的数据类型才能使用在没有确定类型参数的情况下，模板无法自动推导，此时模板没有确定的数据类型，那么模板无法使用，必须手动指定数据类型普通函数调用时可以发生自动类型转换（隐式类型转换），但模板函数自动推导类型时无法隐式类型转换，只有指定类型后才可以从某种程度上说，函数模板在指定类型后，与普通函数相差不大\n对用规则函数模板与普通函数都可以实现的情况下，优先使用普通函数可以通过空模板参数来强制调用函数模板函数模板可以重载\n具体化函数模板函数模板不能直接传入自定义类型或数组，可以通过具体化函数模板来解决\nclass person&#123;    int age;    double height;&#125;template&lt;class T&gt;bool compare(T &amp;a, T &amp;b)&#123;    if (a *** b) return true;    return false;&#125;template&lt;&gt; bool compare(person &amp;a, person &amp;b)&#123;    if (a.age *** b.age &amp;&amp; a.height *** b.height) return true;    return false;&#125;person a;person b;a.age = 10;a.height = 175;b.age = 24;b.height = 168;compare(a, b);\n\n“学习模板不是为了写模板，而是为了熟练运用STL提供的模板”\n类模板创建一个数据类模板，此模板可以使用多个未定的数据类型，给其赋值时需要指定数据类型\ntemplate&lt;class NameType, class AgeType = int&gt;class Person&#123;public:    Person(NameType name, AgeType age)&#123;    this-&gt;mName = name;    this-&gt;mAge = age;&#125;void showPerson()&#123;    cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;&#125;public:    NameType mName;    AgeType mAge;&#125;;\n\n类模板无法自动推导类型，但可以有默认参数（即默认的数据类型）类模板中的成员函数在调用时才生成当类模板的对象作为函数的参数时，可以指定传入对象的数据类型，也可以将参数模板化，或将整个类模板化\n类模板与继承当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型如果不指定，编译器无法给子类分配内存如果想灵活指定出父类中T的类型，子类也需变为类模板\n文件读写正常读取：\n#include &lt;fstream&gt; //包含头文件ifstream ifs;//创建输入文件流ifs.open(&lt;File path&gt;, ios::in);//指定文件路径和读取方式if (!ifs.is_open())&#123; //判断文件是否成功打开    &lt;expression&gt;    ifs.close()//关闭打开的文件&#125; else&#123;    // 以下为读取文件的例子，依次读取即可，只是中间空格不知去哪里了    int id;    string name;    int departmentId;    int index = 0;    while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; departmentId) &#123;        worker *worker = NULL;        if (departmentId *** 1) &#123;            worker = new employee(id, name, departmentId);        &#125; else if (departmentId *** 2) &#123;            worker = new manager(id, name, departmentId);        &#125; else &#123;            worker = new boss(id, name, departmentId);        &#125;        this-&gt;pWorkerArray[index] = worker;        index++;&#125;\n\n判断文件是否为空：\n#include &lt;fstream&gt; //包含头文件ifstream ifs;//创建输入文件流char ch;ifs &gt;&gt; ch;if (ifs.eof()) &#123; //判断ifs是否为文件的结尾，如果是，说明文件为空，如果不是说名文件不为空    cout &lt;&lt; &quot;File is empty&quot; &lt;&lt; endl; &lt;expression&gt;    ifs.close(); return;&#125;\n\n写入文件：\n#include &lt;fstream&gt; //包含头文件ofstream ofs;ofs.open(FILENAME, ios::out);for (int i = 0; i &lt; this-&gt;workerNum; ++i) &#123;    ofs &lt;&lt; this-&gt;pWorkerArray[i]-&gt;id &lt;&lt; &quot; &quot;        &lt;&lt; this-&gt;pWorkerArray[i]-&gt;name &lt;&lt; &quot; &quot;        &lt;&lt; this-&gt;pWorkerArray[i]-&gt;departmentId &lt;&lt; endl;&#125;ofs.close();\n\n退出程序接口exit(0)\n\nlinux下的“按任意键继续”This is a library conio.h for linux. Just copy file and paste file conio.h on /usr/include/ but don’t forget before you want copy paste on /usr/include/ you must open folder as ADMINISTRATOR first !!\ngit clone https://github.com/zoelabbb/conio.h.gitcd conio.hsudo make install\n\n重启IDE\n#include &lt;conio.h&gt;void toContinue() &#123;    cout &lt;&lt; &quot;Press any key to continue ...&quot; &lt;&lt; endl;    getch();&#125; //如果在while循环中，可能要用两个getch()才能正常工作\n\nstring一个用法（把字符串当做字符数组）void speechManager::createPlayer() &#123;    string nameSeed;    nameSeed = &quot;ABCDEFGHIJKL&quot;;    for (int i = 0; i &lt; nameSeed.size(); i++) &#123;        string name = &quot;Player - &quot;;        name += nameSeed[i];        player tempPlayer;        tempPlayer.name = name;        for (double &amp;j: tempPlayer.score) j = 0; //看上去高级，可读性降低        this-&gt;v1.push_back(i + 10001);        this-&gt;players.insert(make_pair(i + 10001, tempPlayer));    &#125;&#125;\n\n遍历容器(使用auto)for (auto it = vector.begin(); it != vector.end(); it ++)&#123; &lt;expression&gt;&#125;\n\n特性usingThe modern cpp use more using to define aliases of variables.\nusing byte = unsigned char;using array_t = double[10]; // &quot;array_t&quot; is an array with &quot;double&quot; type and length is tenarray_t a;a[0] = 1;                   // It can be used as a common arrayusing func_t = double(double);func_t* f = sin;std::cout &lt;&lt; f(3.1415926 / 4);  // Calculate sin(PI/4)\n\nnamespaceWhen a project was completed by many coders, naming conflicts in so many identifiers may be occurs.Key word namespace can define a namespace with a name or not. The same indentifiers can exist in different namespaces.Using :: access to a namespace.Don’t use ; at the end of namespace.\nIncrement and Decrementint i = 1;a = i++; // a = 1, i = 2int i = 1;a = ++i; // a = 2, i = 2\n\n\nBoth i++ and ++i will make i plus 1, but when using them in a class, ++i is more efficienct.\n\nBuilt-in operation function#include &lt;functional&gt;#include &lt;iostream&gt;int main(int, char **) &#123;  std::cout &lt;&lt; std::plus&lt;int&gt;()(5, 8) &lt;&lt; std::endl;  std::cout &lt;&lt; std::minus&lt;int&gt;()(8, 5) &lt;&lt; std::endl;  std::cout &lt;&lt; std::multiplies&lt;int&gt;()(5, 8) &lt;&lt; std::endl;  std::cout &lt;&lt; std::divides&lt;int&gt;()(8, 2) &lt;&lt; std::endl;  std::cout &lt;&lt; std::modulus&lt;int&gt;()(8, 6) &lt;&lt; std::endl;  std::cout &lt;&lt; std::negate&lt;int&gt;()(5) &lt;&lt; std::endl;  return 0;&#125;\n\nType convertionThere are three ways to convert:\n(DestinationType)sourceData;DestinationType(sourceData);static_cast&lt;DestinationType&gt;(sourceData);\n\nif &#x2F; switch with initialization\nLimit the scope of variables as much as possible.cpp 17 introduced if &#x2F; switch statements that allow variable initialization.\n\nif (auto x&#123; std::cin.get() &#125;; x &gt;= 48 &amp;&amp; x &lt;= 57)&#123;    std::cout &lt;&lt; x &lt;&lt; &quot; is a digit.&quot; &lt;&lt; std::endl;&#125; else&#123;    std::cout &lt;&lt; x &lt;&lt; &quot; is not a digit.&quot; &lt;&lt; std::endl;&#125;\n\nRange-based forint a[]&#123;    1, 2, 3, 4, 5, 6,&#125;;for (auto &amp;i : a)   // Write by reference    i *= 10;for (auto i : a)    // Read by value    std::cout &lt;&lt; i &lt;&lt; &quot;\\t&quot;;std::cout &lt;&lt; std::endl;for (auto i : &#123;12, 25, 67, 43, 89, 54&#125;) // Access the list directly    std::cout &lt;&lt; i &lt;&lt; &quot;\\t&quot;;std::cout &lt;&lt; std::endl;\n\nFunction and ReferenceFunctiondouble my_sqrt(double x) &#123;    std::cout &lt;&lt; &quot;entering &quot; &lt;&lt; __func__ &lt;&lt; std::endl;    double xnew, xold&#123;x / 2.0&#125;;    for (;;) &#123;        xnew = (xold + x / xold) / 2.0;        if (fabs(xnew - xold) &lt; 1e-8) &#123;            break;        &#125;        xold = xnew;    &#125;    return xnew;&#125;;\n\nResult:\nentering mainentering my_sqrt1.414213\n\n\nTo iterate is human, to recurse divine.To recieve multiple data, using initializer_list to send parameters to function.e.g.\n\ndouble sum(std::initializer_list&lt;double&gt; ld) &#123;    double s&#123;0&#125;;    for (auto i : ld)        s += i;    return s;&#125;//in main function    std::cout &lt;&lt; sum(&#123;1, 2, 3, 4&#125;) &lt;&lt; std::endl;    std::cout &lt;&lt; sum(&#123;1, 2, 3, 4, 5&#125;) &lt;&lt; std::endl;\n\nThe result:\n1015\n\nInline functionInsert the inline keyword in front of the function defination, which is recommanded.When the resouces of codes in a function are less than calling the function, using inline function can increase spending saving.Inlining is at the cost of code bloat(copying), and only saves the overhead of function calls, thereby improving the execution efficiency of functions.Inline should not be used in the following situation:\n\nIf the code in the function body is relatively long, making inlining will lead to higher memory consumption costs.\nIf there is a loop int the function body, the time to execute the code in the function body is greater than the overhead of the function call.\n\nDefault parameterProvide the default parameters.When calling the function, it can automatically use the default parameters without your actual parameters.\nFunction TemplateFunction templates implement parameterization of data types.It can use unknown data types as parameters. As long as the type of data meets the requirements defined by the function template, the function template can be called with these types of data as arguments.\ntemplate &lt;typename T&gt; T my_min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template &lt;typename T&gt; T my_max(T a, T b) &#123; return a &lt; b ? b : a; &#125;double sum(std::initializer_list&lt;double&gt; ld) &#123;    double s&#123;0&#125;;    for (auto i : ld)        s += i;    return s;&#125;template &lt;typename T&gt; std::pair&lt;T, T&gt; my_min_max(T a, T b) &#123;    T t_min = my_min(a, b);    T t_max = my_max(a, b);    return std::make_pair(t_min, t_max);&#125;template &lt;typename T&gt; void print(std::pair&lt;T, T&gt; p) &#123;    std::cout &lt;&lt; typeid(T).name() &lt;&lt; &quot;: \\t&quot;;    std::cout &lt;&lt; &quot;(min: &quot; &lt;&lt; p.first &lt;&lt; &quot;, max: &quot; &lt;&lt; p.second &lt;&lt; &quot;)\\n&quot;;&#125;int main(int, char **) &#123;    print(my_min_max(&#x27;a&#x27;, &#x27;b&#x27;));    print(my_min_max(20, 10));    print(my_min_max(1.5, 2.5));    return 0;    &#125;\n\nLambda Functionint add(int x, int y) &#123; return x + y; &#125;//in main function    int a&#123;1&#125;, b&#123;2&#125;;    std::cout &lt;&lt; add(a, b) &lt;&lt; std::endl;    auto f&#123;[](int x, int y) &#123; return x + y; &#125;&#125;;    std::cout &lt;&lt; f(a, b) &lt;&lt; std::endl;    auto f2&#123;[=]() &#123; return a + b; &#125;&#125;;    std::cout &lt;&lt; f2() &lt;&lt; std::endl;    auto f3&#123;[&amp;](int x) &#123;        a *= x;        b *= x;    &#125;&#125;;    f3(10);    std::cout &lt;&lt; a &lt;&lt; std::endl &lt;&lt; b &lt;&lt; std::endl;\n\nLambda function is a function that can capture the variables in a scope autometically.[] means the capture list.There are several commonly used forms of capture lists:\n\n\n\nForms\nMeaning\n\n\n\n[x]\nCapture the variable x by value passing\n\n\n[=]\nCapture all variables in the parent scope by value passing\n\n\n[&amp;x]\nCapture the variable x by reference passsing\n\n\n[&amp;]\nCapture all variables in the parent scope by reference passing\n\n\n[=,&amp;x,&amp;y]\nCapture the variables x and y by reference passing and  the rest by value passing\n\n\n[&amp;,x]\nCapture the variable x by value passing and the rest by reference passing\n\n\n\nLambda function can have the real parameters.\n\nReferenceLeft-valued reference\nThe reference is a key point and difficulty.A reference is an alias of the referenced object. The two are essentially the same object, but they are displayed as different names and types.\n\nT&amp; r = t;\n\nWhere T is a data type, &amp; is an operator, r is reference name and t is a variable of type T.\n\nt cannot be constant or right value expression.\nr must be initialized when defined.This is excatly where the reference is diferent from the pointer, that is, there is no empty reference.References cannot exist independently, but must be attached to the referenced variable, so it does not take up memory space.If the reference is a named variable, such a reference is called left-valued reference (in cpp98).\n\nint a = 2;int *p = &amp;a;int &amp;r = a;std::cout &lt;&lt; &quot;a:\\t&quot; &lt;&lt; a &lt;&lt; std::endl;std::cout &lt;&lt; &quot;*p:\\t&quot; &lt;&lt; *p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;r:\\t&quot; &lt;&lt; r &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The value of p:   \\t&quot; &lt;&lt; p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The address of p:\\t&quot; &lt;&lt; &amp;p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The address of a:\\t&quot; &lt;&lt; &amp;a &lt;&lt; std::endl          &lt;&lt; &quot;The address of r:\\t&quot; &lt;&lt; &amp;r &lt;&lt; std::endl;a = 3;std::cout &lt;&lt; &quot;a:\\t&quot; &lt;&lt; a &lt;&lt; std::endl;std::cout &lt;&lt; &quot;*p:\\t&quot; &lt;&lt; *p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;r:\\t&quot; &lt;&lt; r &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The value of p:   \\t&quot; &lt;&lt; p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The address of p:\\t&quot; &lt;&lt; &amp;p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The address of a:\\t&quot; &lt;&lt; &amp;a &lt;&lt; std::endl          &lt;&lt; &quot;The address of r:\\t&quot; &lt;&lt; &amp;r &lt;&lt; std::endl;r = 4;std::cout &lt;&lt; &quot;a:\\t&quot; &lt;&lt; a &lt;&lt; std::endl;std::cout &lt;&lt; &quot;*p:\\t&quot; &lt;&lt; *p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;r:\\t&quot; &lt;&lt; r &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The value of p:   \\t&quot; &lt;&lt; p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The address of p:\\t&quot; &lt;&lt; &amp;p &lt;&lt; std::endl;std::cout &lt;&lt; &quot;The address of a:\\t&quot; &lt;&lt; &amp;a &lt;&lt; std::endl          &lt;&lt; &quot;The address of r:\\t&quot; &lt;&lt; &amp;r &lt;&lt; std::endl;\n\nThe result:\na:      2*p:     2r:      2The value of p:         0x7fff945b3184The address of p:       0x7fff945b3178The address of a:       0x7fff945b3184The address of r:       0x7fff945b3184a:      3*p:     3r:      3The value of p:         0x7fff945b3184The address of p:       0x7fff945b3178The address of a:       0x7fff945b3184The address of r:       0x7fff945b3184a:      4*p:     4r:      4The value of p:         0x7fff945b3184The address of p:       0x7fff945b3178The address of a:       0x7fff945b3184The address of r:       0x7fff945b3184\n\nIt can be seen that the left value reference is only an alias of the variable, so all operations on the lvalue reference are equivalent to the operation on the variable itself.Supplementary explanation:\n\nAny variable can be reference, such as pointer.\n\nint m = 3;int* p = &amp;m;int*&amp; rp = p;\n\nReference is not variable, so you cannot reference a reference! And at the same time, pointers cannot point to a reference.\n\nPointers can be nullptr or void type, but references cannot.\n\nint m = 3;void* p = &amp;m;p = nullptr;void&amp; r = m;        // error!int&amp;r = nullptr;    // error!\n\n\nCannot build an array of reference.\nConstant lvalue reference can be initialized by lvalue, constant lvalue and rvalue.\n\nint x = 1;const int N = 10;int&amp; rn = N;        // error!const int&amp; rx = x;  // Reference lvalueconst int&amp; rN = N;  // Reference constant lvalueconst bool&amp; rB = true; // Reference constant rvalue\n\n\nThe left reference of the constant is usually used as a formal parameter of the function. At this time, the corresponding actual parameter cannot be modified inside the function through this reference to achieve the purpose of protecting the actual parameter.\n\nRvalue reference, move() and Move semanticstemplate &lt;typename T&gt; void my_swap(T &amp;a, T &amp;b) &#123;    T t = std::move(a);    a = std::move(b);    b = std::move(t);&#125;\n\nActually it is the swap() in cpp STL.The cpp STL also provides array exchange in the form of overloading.\ntemplate &lt;class T, std::size_t N&gt; void my_swap(T (&amp;a)[N], T (&amp;b)[N]) &#123;    if (&amp;a != &amp;b) &#123;        T *first1 = a;        T *last1 = first1 + N;        T *first2 = b;        for (; first1 != last1; ++first1, ++first2) &#123;            my_swap(*first1, *first2);        &#125;    &#125;&#125;\n\nattribute在C++中，__attribute__是一种GCC编译器提供的扩展语法，用于在函数、变量、类型等声明中添加附加属性。它的语法形式为__attribute__((属性列表))。\n一些常见的属性和它们的说明：\n\n__attribute__((aligned(n)))：指定变量或结构体的对齐方式为n字节。例如，__attribute__((aligned(4))) int x;将x的对齐方式设置为4字节。\n__attribute__((packed))：告诉编译器取消结构体的对齐，即以最小的字节对齐结构体成员。这在需要与外部系统或文件进行二进制数据交换时非常有用。\n__attribute__((noreturn))：用于标记函数不会返回。例如，__attribute__((noreturn)) void error();表示函数error不会返回。\n__attribute__((unused))：告诉编译器该变量可能未使用，可以抑制未使用变量的警告。例如，int x __attribute__((unused));告诉编译器x可能未使用。\n__attribute__((deprecated))：用于标记函数、变量或类型已被弃用。当使用被标记为弃用的元素时，编译器会发出警告。\n__attribute__((constructor))和__attribute__((destructor))：用于定义在程序启动前或结束后自动执行的函数。constructor属性用于在main函数执行之前自动调用的函数上，而destructor属性用于在程序结束前自动调用的函数上。\n\n\n__attribute__是GCC的扩展特性，不是C++标准的一部分，因此在使用时应该注意可移植性。\n\ndeclspecDeduce the type of statements when compiling. It can be used to define a variable.\nint a = 0;decltype(a) b = 1; // This means the type of &quot;b&quot; is &quot;int&quot;decltype(a + b) c = a + b; // c: int\n\ndeclspec用以推测表达式结果的类型，返回此类型；而__declspec(dllimport)是 Microsoft Visual C++ 编译器的一个扩展，用于在编译动态链接库（DLL）时指示一个函数或变量是从外部DLL中引入的。\n当你在一个程序中需要使用从外部DLL中导出的函数或变量时，你可以使用 declspec(dllimport) 关键字来告诉编译器这个函数或变量是从其他DLL中引入的，而不是在当前代码中定义的。这样，编译器在编译时会生成适当的代码，以便正确地链接到外部DLL中的内容。\n为了提高代码的可读性，请为 __declspec(dllimport) 定义宏，并使用此宏来声明导入的每个符号：\n#define DllImport   __declspec( dllimport )DllImport int  j;DllImport void func();\n\n虽然在函数声明中使用 __declspec(dllimport) 是可选的，但如果你使用此关键字，编译器会生成更高效的代码。 不过，必须对导入的可执行文件使用 **__declspec(dllimport)**，以访问 DLL 的公共数据符号和对象。 请注意，DLL 的用户仍需要与导入库链接。\n可以对 DLL 和客户端应用程序使用相同的头文件。 为此，请使用特殊的预处理器符号来指示是生成 DLL 还是生成客户端应用程序。 例如：\n#ifdef _EXPORTING   #define CLASS_DECLSPEC    __declspec(dllexport)#else   #define CLASS_DECLSPEC    __declspec(dllimport)#endifclass CLASS_DECLSPEC CExampleA : public CObject&#123; ... class definition ... &#125;;\n\nOtherexplicit 关键字可以帮助你在类的构造函数中明确地指定类型转换的行为，从而提高代码的可读性和安全性。\noptional在C++中，std::optional是C++17标准引入的一个类模板，用于表示一个可能存在或可能不存在的值。它提供了一种更安全、更语义清晰的方式来处理可能缺失的值，而不需要使用传统的空指针或特殊值。std::optional可以看作是一种对可能的值进行了封装的容器，它要么包含一个有效的值，要么为空（不包含任何值）。\n使用std::optional的主要好处包括：\n\n避免空指针异常：传统的空指针可能在访问时引发未定义行为，而std::optional通过类型系统和成员函数来明确指示值的存在或不存在，从而避免了潜在的运行时错误。\n\n更好的语义表达：std::optional能够更清晰地表达一个值是可选的，而不需要通过注释或命名来传达这种信息。\n\n避免特殊值：使用std::optional可以避免使用特殊值（例如-1、0或空字符串）来表示缺失的值，从而增加了代码的可读性和维护性。\n\n优雅的值处理：std::optional提供了一些成员函数，如has_value()、value()和value_or()，使得对可能存在的值进行访问和处理更加优雅和安全。\n\n\n以下是一个简单的示例，展示了如何在C++中使用std::optional：\n#include &lt;iostream&gt;#include &lt;optional&gt;std::optional&lt;int&gt; divide(int a, int b) &#123;    if (b != 0) &#123;        return a / b;    &#125; else &#123;        return std::nullopt; // 表示缺失的值    &#125;&#125;int main() &#123;    std::optional&lt;int&gt; result = divide(10, 2);    if (result.has_value()) &#123;        std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result.value() &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Division by zero&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;\n\n在这个示例中，std::optional被用来包装除法操作的结果，以便在可能出现除零错误时能够明确地表示值的缺失。\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","cpp"]},{"title":"C++零碎笔记","url":"/2023/12/28/note/Programming/Language/cpp-experience/","content":"\n遇到的细碎的问题及其解决方法。\n\n\n\n函数参数传递pass by value: 在栈区开辟了形参的内存空间，并调用拷贝构造函数把实参复制给形参，如果资源较大，拷贝消耗较大。\npass by reference: 本质上是传递指针，通过指针间接寻址。\n\n注意：当传递内置类型时，如int、char，指针占用的内存空间高于变量所占用的内存空间。而寻址会降低程序的效率，应当使用值传递并使用std::move。传递STL容器时也可以使用值传递加移动语句。\n\n函数返回值在现代 C++ 中，返回临时对象实际上是可以的，因为编译器会进行返回值优化 (RVO - Return Value Optimization) 和移动语义优化。\n\n安全的返回方式:\n\n// 完全可以这样写std::string getName() &#123;    std::string name = &quot;test&quot;;    return name;  // 编译器会优化，不会有额外复制&#125;// vector 也可以直接返回std::vector&lt;int&gt; getNumbers() &#123;    std::vector&lt;int&gt; nums = &#123;1, 2, 3&#125;;    return nums;  // 同样会被优化&#125;\n\n\n不安全的返回方式:\n\n// 危险！返回局部变量的指针或引用int* getValuePtr() &#123;    int value = 42;    return &amp;value;  // 错误：返回栈上变量的地址&#125;// 危险！返回局部变量的引用int&amp; getValueRef() &#123;    int value = 42;    return value;  // 错误：返回栈上变量的引用&#125;\n\n\n关于对象返回的一般规则:\n\n\n返回值类型的对象是安全的（依赖 RVO 和移动语义）\n不要返回局部变量的指针或引用\n如果对象很大，考虑使用引用参数或智能指针\n如果是自定义类，确保实现了移动构造函数和移动赋值运算符\n\n\n性能考虑:\n\n// 现代C++中这样写很好std::vector&lt;int&gt; createVector() &#123;    return std::vector&lt;int&gt;&#123;1, 2, 3&#125;;  // 编译器会优化&#125;// 如果对象很大或构造成本高，可以用引用参数void createLargeObject(LargeObject&amp; out) &#123;    // 直接修改 out&#125;\n\n总结：\n\n返回临时对象在现代 C++ 中是安全的\n但要避免返回指向局部变量的指针或引用\n对于大对象或特殊情况，可以考虑使用引用参数\n确保你的类支持移动语义（如果需要的话）\n\n\n如果没有移动构造函数，返回一个临时对象会再调用时创建一个新的对象（调用拷贝构造函数），如果没有手动实现的拷贝构造函数，浅拷贝可能出现内存泄漏。\n不考虑代码设计问题，最安全的方式是传入需要修改的对象引用，直接对对象进行修改。\n\nOpenGL手动控制帧率通过计算渲染当前帧所消耗的时间，对比目标帧率时一帧应该消耗的时间，如果渲染当前帧所需时间更短，则让当前线程休眠目标帧率应消耗时间与当前帧渲染时间之差。\nauto framerate = 120;// main loop 中auto     time     = Time::GetTime();Timestep timestep = time - m_LastFrameTime;m_LastFrameTime   = time;          auto sleepDuration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::duration&lt;float&gt;(1.0 / framerate - timestep.GetSeconds()));if (1.0 / framerate &gt; timestep.GetSeconds())    std::this_thread::sleep_for(sleepDuration);\n\n但事实上这样会导致帧率的不稳定，目前还没找到更好的办法。\n降低帧率最好的方法仍然是开启VSync。\nwarning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失一般是使用中文字符集编写的源代码，使用utf-8编码打开，会出现乱码，编译选项中添加/utf-8即可。\n如xmake.lua：\nadd_cxxflags(&quot;/utf-8&quot;)\n\n参数包（parameter pack）参数包是 C++11 中引入的一个特性，允许模板接受任意数量的参数。\n参数包在模板中表示为 ...，可以出现在模板参数列表、函数参数列表、函数参数类型列表、模板参数列表中，用来表示可变数量的参数。\n使用方法（摘自cppreference）1. 在变参类模板中使用可以用任意数量的模板实参实例化：\ntemplate&lt;class... Types&gt;struct Tuple &#123;&#125;; Tuple&lt;&gt; t0;           // Types 不包含实参Tuple&lt;int&gt; t1;        // Types 包含一个实参：intTuple&lt;int, float&gt; t2; // Types 包含两个实参：int 与 floatTuple&lt;0&gt; error;       // 错误：0 不是类型\n\n变参函数模板可以用任意数量的函数实参调用（模板实参通过模板实参推导推导）：\ntemplate&lt;class... Types&gt;void f(Types... args); f();       // OK：args 不包含实参f(1);      // OK：args 包含一个实参：intf(2, 1.0); // OK：args 包含两个实参：int 与 double\n\n类模板中，形参包必须是类模板形参列表中的最后一个。\ntemplate&lt;typename U, typename... Ts&gt;    // OK：能推导出 Ustruct valid;// template&lt;typename... Ts, typename U&gt; // 错误：Ts... 不在结尾// struct Invalid;\n\n函数模板则可以出现在前面，只要其后所有的形参都可以从函数实参推导或默认拥有实参即可。\ntemplate&lt;typename... Ts, typename U, typename=void&gt;void valid(U, Ts...);    // OK：能推导出 U// void valid(Ts..., U); // 不能使用：Ts... 在此位置是不推导语境 valid(1.0, 1, 2, 3);     // OK：推导出 U 是 double，Ts 是 &#123;int, int, int&#125;\n\n2.变参函数模板的函数形参列表中使用可以在变参函数模板的函数形参列表中使用，表示多个类型的形参。\n#include &lt;iostream&gt;template &lt;typename... Args&gt;void printAll(Args... args)&#123;    ((std::cout &lt;&lt; args &lt;&lt; std::endl), ...); // c++17&#125;int main()&#123;    printAll(1, 2, 3, &quot;hello&quot;, 3.14);    return 0;&#125;\n\n在这个示例中，printAll 函数接受任意数量的参数，使用折叠表达式展开参数包，并打印所有参数。\n可以使用类型约束加包名的形式定义：\n#include &lt;iostream&gt;template &lt;std::intergal... Args&gt;void printAll(Args... args)&#123;    ((std::cout &lt;&lt; args &lt;&lt; std::endl), ...); // c++17&#125;int main()&#123;    printAll(1, 2, 3, 4, 5);\t\t\t//可行，都是整型    printAll(1, 2, 3, &quot;hello&quot;, 3.14); \t//不可行，因为形参包的参数类型被约束为整型    return 0;&#125;\n\nOpenGL世界坐标与窗口坐标世界坐标就是物体在所创建的投影中的实际坐标，这些物体被投影矩阵转化成屏幕空间标准化坐标（NDC坐标），这些两个坐标（即世界坐标与NDC坐标）是通过mvp矩阵进行转化的。\n而窗口坐标是显示在窗口中的像素的坐标，它与NDC可以通过归一化来转换。\n因此，在OpenGL中，当鼠标点击窗口中的每一个坐标时，可以通过一系列转换，将此坐标转换为世界坐标，以此来映射一些动作。\nauto&amp; app = Application::Get();float x = (2.0f * Input::GetMouseX()) / app.GetWindow().GetWidth() - 1.0f;float y = 1.0f - (2.0f * Input::GetMouseY()) / app.GetWindow().GetHeight();// Mouse always in z plane, so z === 1.0float z = 1.0f;glm::vec4 screenPos = glm::vec4(x, y, z, 1.0f);glm::vec4 worldPos  = glm::inverse(m_Camera-&gt;GetViewProjectionMatrix()) * screenPos;// normalize, devide wworldPos /= worldPos.w;// DION_WARN(&quot;x = &#123;0&#125;, y = &#123;1&#125;&quot;, Input::GetMouseX(), Input::GetMouseY());// DION_WARN(&quot;Postion = &#123;0&#125; &#123;1&#125;&quot;, worldPos.x, worldPos.y);int chessX = static_cast&lt;int&gt;(std::round(worldPos.x));int chessY = static_cast&lt;int&gt;(std::round(worldPos.y));if (chessX &gt;= -7 &amp;&amp; chessX &lt;= 7 &amp;&amp; chessY &gt;= -7 &amp;&amp; chessY &lt;= 7)&#123;    m_ChessBoard.Drop(chessX, chessY, ChessBoard::ChessColor::White);&#125;\n\n总体步骤为：\n\n获取窗口坐标x，y\n将窗口坐标转换为NDC坐标，此时坐标每个轴的值应在（-1，1）之间，z轴始终1.0f\n获取投影矩阵和视角矩阵，如果有模型矩阵也要加上（即MVP矩阵）\n获取转换矩阵的逆矩阵，与NDC坐标相乘，所得的坐标除以w轴以标准化\n\nC++获取一个float值最近的整数四舍五入：\nfloat num = 3.6f;int rounded = static_cast&lt;int&gt;(std::round(num));\n\n向下舍入：\nfloat num = 3.6f;int floored = static_cast&lt;int&gt;(std::floor(num));\n\n向上舍入：\nfloat num = 3.6f;int ceiled = static_cast&lt;int&gt;(std::ceil(num));\n\n截取整数部分：\nfloat num = 3.6f;int truncated = static_cast&lt;int&gt;(num);// 直接使用类型转换\n\nGLFW窗口图标设置int            width, height, channels;unsigned char* image = stbi_load(&quot;./Gobang/assets/gobang.png&quot;, &amp;width, &amp;height, &amp;channels, 4);if (image)&#123;    GLFWimage images[1];    images[0].width  = width;    images[0].height = height;    images[0].pixels = image;    glfwSetWindowIcon((GLFWwindow*)window, 1, images);    stbi_image_free(image);&#125;else&#123;    std::cerr &lt;&lt; &quot;Failed to load icon image&quot; &lt;&lt; std::endl;&#125;\n\n多线程通信使用条件变量可以实现进程间的通信，以打断耗时循环。\nstd::mutex              mtx;std::condition_variable cv;bool                    g_stop = false;void childThreadHandle()&#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    g_stop = false;    while(!g_stop)&#123;            auto timeout = std::chrono::seconds(10);\t\t\tcv.wait_for(lock, timeout, [] &#123; return g_stop; &#125;);    &#125;&#125;// In main or other threadvoid stop()&#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx);    g_stop = true;    cv.notify_all();&#125;\n\nDouble And Floatfloat a = 0.8f;a = 0.9; // warning C4244: “参数”: 从“double”转换到“float”，可能丢失数据\n\n浮点数默认是双精度浮点数，后面添加f来告诉编译器这是float。\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","cpp"]},{"title":"C++的动态库与静态库","url":"/2023/11/29/note/Programming/Language/cpp_lib/","content":"在C++中，动态库（Dynamic Link Library，DLL）和静态库（Static Library）是两种不同的库文件，它们在程序中的链接方式和运行时行为上有一些重要的异同点。\n\n\n动态库与静态库的相同点\n库的作用： 无论是动态库还是静态库，它们的目的都是为了将代码模块化，以便在多个程序中共享和重复使用。\n\n包含编译后的二进制代码： 两者都包含了已经编译好的二进制代码，可以被程序调用。\n\n\n动态库与静态库不同点\n链接方式\n\n动态库： 在程序运行时动态加载，链接是在运行时进行的。动态库的代码并不在编译时与程序代码直接链接，而是在运行时由操作系统动态加载。\n静态库： 在程序编译时被链接到程序中。编译器在编译时将库的代码和程序的代码合并成一个可执行文件。\n\n\n文件扩展名\n\n动态库： 通常有不同的扩展名，如.dll（Windows，Dynamic Link Library）或.so（Linux，Shared Object）。\n静态库： 通常有不同的扩展名，如.lib（Windows，Library）或.a（Linux，Archive）。\n\n\n文件大小\n\n动态库： 通常比静态库小，因为多个程序可以共享一个动态库的实例。\n静态库： 通常较大，因为每个使用该库的程序都会包含其完整的副本。\n\n\n更新和维护\n\n动态库： 如果动态库的代码发生变化，只需替换动态库文件即可。程序无需重新编译。\n静态库： 如果静态库的代码发生变化，必须重新编译并链接使用该库的程序。\n\n\n内存使用\n\n动态库： 共享一份内存，因此在系统中只有一个副本。\n静态库： 每个使用该库的程序都有其自己的副本，因此可能会占用更多内存。\n\n\n移植性\n\n动态库： 更易于实现跨平台的移植，因为动态库可以在不同平台上具有相同的接口。\n静态库： 在不同平台上可能需要不同的库文件。\n\n\n\n在实际应用中，选择使用动态库还是静态库取决于项目的需求和设计考虑。通常，动态库在共享代码、更新维护和节省内存方面具有优势，而静态库在性能和依赖管理方面可能更有优势。\n\n总结：静态库相当于添加额外的编译单元，直接链接到可执行文件中；而动态库只是将符号链接到可执行文件，当需要调用库的内容时，从动态库文件中调用。\n\n不同平台\n不同操作系统和硬件架构之间存在差异，导致在编译和链接时产生的二进制代码也有所不同。\n\n不同的操作系统有不同的系统调用、API和二进制接口。一个在Windows上编译的库通常不能直接在Linux上使用，反之亦然。\n不同的硬件体系结构（如x86、x86_64、ARM等）具有不同的指令集和内存布局。库中包含的机器代码通常是特定于体系结构的，因此需要为特定体系结构进行编译。\n不同的编译器和工具链可能会对代码生成、调试信息等方面有所不同，使用不同的编译器编译的库可能是不兼容的。\n代码差异静态库的代码正常写，可以直接编译链接，而动态库则需要定义哪些需要被导出，不同平台的顶踹方式有所不同。\n在Windows平台上使用 __declspec(dllexport) 和 __declspec(dllimport) 来指定导出和导入符号。\n在Linux&#x2F;Unix（MacOS）平台上使用 __attribute__((visibility(&quot;default&quot;))) 来指定导出符号。\n跨平台使用时，使用宏定义不同平台的导出代码：\n#ifdef __WIN32__    #ifdef LIBRARY_EXPORTS        #define MY_API __declspec(dllexport)    #else        #define MY_API __declspec(dllimport)    #endif#else    #define MY_API __attribute__((visibility(&quot;default&quot;)))#endif// 在动态库中导出符号class MY_API MyClass &#123;public:    void myFunction();&#125;;\n\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","cpp"]},{"title":"JavaScript","url":"/2023/07/11/note/Programming/Language/javascript/","content":"\n📒  JavaScript学习笔记\n\n\n\n基础概念与HTML的交互\n可以在 HTML 文档中放入不限数量的脚本。\n\n脚本可位于 HTML 的&lt;body&gt;或 &lt;head&gt; 部分中，或者同时存在于两个部分中。\n\n通常的做法是把函数放入&lt;head&gt;部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。\n\n\n第一个程序&lt;body&gt;    &lt;h1&gt;我的第一段 JavaScript&lt;/h1&gt;    &lt;p id=&quot;demo&quot;&gt;        JavaScript 能改变 HTML 元素的内容。    &lt;/p&gt;    &lt;script&gt;        document.write(&quot;&lt;h1&gt;TITLE&lt;/h1&gt;&quot;);        function myFunction() &#123;            x = document.getElementById(&quot;demo&quot;);  // 找到元素            x.innerHTML = &quot;Hello JavaScript!&quot;;    // 改变内容        &#125;    &lt;/script&gt;    &lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;/body&gt;\n\n\nHTML 输出流中使用 document.write，相当于添加在原有html代码中添加一串html代码。而如果在文档加载后使用（如使用函数），会覆盖整个文档。\n\n使用函数来执行document.write代码如下：\n&lt;script&gt;    function myfunction()&#123;        document.write(&quot;使用函数来执行document.write，即在文档加载后再执行这个操作，会实现文档覆盖&quot;);    &#125;    document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);    document.write(&quot;&lt;p&gt;这是一个段落。&lt;/p&gt;&quot;);&lt;/script&gt;&lt;p&gt;    您只能在 HTML 输出流中使用 &lt;strong&gt;document.write&lt;/strong&gt;。    如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myfunction()&quot;&gt;点击这里&lt;/button&gt;\n\n引入外部js文件&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n外部 javascript 文件不使用 &lt;script&gt; 标签，直接写 javascript 代码。\n\n简单学习数字、字符、操作符\n分号可以省略，但特殊情况会引起错误\n\nJavascript 只有一种数字类型(即 64位 IEEE 754 双精度浮点 double)，有52位表示尾数，可以精确到9x10^15的整数\n\n\n// 有三种非数字的数字类型Infinity; // 1/0 的结果-Infinity; // -1/0 的结果NaN; // 0/0 的结果\n\n\n单引号或双引号构建字符串，字符串用+拼接，字符串也可以用&lt;&gt;号来比较\n\n使用==比较时会进行类型转换，&#39;5&#39;==5返回true，null==undefined返回true；但如果用===则不会转换类型，上述两种会返回false。\n\n不同类型的变量相加会导致奇怪的行为：\n 13 + !0; //14&quot;13&quot; + !0; // &#x27;13true&#x27;\n\ncharAt(int num)可以得到字符串中位于num的字符\n\nsubstring(int startPos, int length)可以得到从startPos开始的length长度的子串，\n\nlength是一个属性，不要用()，&quot;hello&quot;.lenght\n\n\n // 还有两个特殊的值：`null`和`undefined`null;      // 用来表示刻意设置的空值undefined; // 用来表示还没有设置的值(尽管`undefined`自身实际是一个值\n\n // false, null, undefined, NaN, 0 和 &quot;&quot; 都是假的；其他的都视作逻辑真// 注意 0 是逻辑假而  &quot;0&quot;是逻辑真，尽管 0 == &quot;0&quot;。\n\n变量、数组、对象\n变量声明用var，无需指定类型，不加var表示全局变量，未初始化且未被赋值的变量为undefined\n\n变量的计算没有别的特点（简写，自增自减）\n\n数组可以是任意类型的有序列表，var myArray = [&quot;Hello&quot;, 45, true];\n\n数组可以下标访问；数组长度可变，push(&lt;\\element&gt;)\n\n\n // javascript中的对象相当于其他语言中的“字典”或“映射”：是键-值对的无序集合。var myObj = &#123;key1: &quot;Hello&quot;, key2: &quot;World&quot;&#125;;\n\n\n键值对，键是字符串，如何键本身是合法的js标识符，则可以不加引号；值可以是任意类型\n对象属性的访问可以通过下标，myObj[&quot;my other key&quot;]; // = 4，也可以用myObj.myKey;\n对象是可变的，更改值，增加键，访问未定义的值，返回undefined\n\n逻辑与控制结构\nif、while、for与c无差别\n\n // &amp;&amp; 和 || 是“短路”语句，它在设定初始化值时特别有用 var name = otherName || &quot;default&quot;;\n\n // `switch`语句使用`===`检查相等性。// 在每一个case结束时使用 &#x27;break&#x27;// 否则其后的case语句也将被执行。 grade = &#x27;B&#x27;;switch (grade) &#123;    case &#x27;A&#x27;:        console.log(&quot;Great job&quot;);        break;    case &#x27;B&#x27;:        console.log(&quot;OK job&quot;);        break;    case &#x27;C&#x27;:        console.log(&quot;You can do better&quot;);        break;    default:        console.log(&quot;Oy vey&quot;);        break;&#125;\n\n函数、作用域、闭包 // JavaScript 函数由`function`关键字定义function myFunction(thing)&#123;    return thing.toUpperCase();&#125;myFunction(&quot;foo&quot;); // = &quot;FOO&quot;\n\n\n被返回的值必须开始用return关键字的那一行，否则由于分号的自动补齐，会返回undefined\n\n// 在使用Allman风格的时候要注意.function myFunction()&#123;    return // &lt;- 分号自动插在这里    &#123;        thisIsAn: &#x27;object literal&#x27;    &#125;&#125;myFunction(); // = undefined\n\n\n函数是一等对象，也可以赋值给一个变量，并且可以作为参数传递\n\n // 函数对象甚至不需要声明名称 —— 你可以直接把一个函数定义写到另一个函数的参数中setTimeout(function()&#123;    // 这段代码将在5秒钟后被调用&#125;, 5000);\n\n\n函数有自己的作用域，而其他代码没有\n if (true)&#123;    var i = 5;&#125;i; // = 5 - 并非我们在其他语言中所期望得到的undefined// 这就导致了人们经常使用的“立即执行匿名函数”的模式，// 这样可以避免一些临时变量扩散到全局作用域去。(function()&#123;    var temporary = 5;    // 我们可以访问修改全局对象（&quot;global object&quot;）来访问全局作用域，    // 在web浏览器中是`window`这个对象。     // 在其他环境如Node.js中这个对象的名字可能会不同。    window.permanent = 10;&#125;)();temporary; // 抛出引用异常ReferenceErrorpermanent; // = 10\n\n闭包： 如果一个函数在另一个函数中定义，那么这个内部函数就拥有外部函数的所有变量的访问权，即使在外部函数结束之后。\n function sayHelloInFiveSeconds(name)&#123;    var prompt = &quot;Hello, &quot; + name + &quot;!&quot;;    // 内部函数默认是放在局部作用域的，    // 就像是用`var`声明的。    function inner()&#123;        alert(prompt);    &#125;    setTimeout(inner, 5000);    // setTimeout是异步的，所以 sayHelloInFiveSeconds 函数会立即退出，    // 而 setTimeout 会在后面调用inner    // 然而，由于inner是由sayHelloInFiveSeconds“闭合包含”的，    // 所以inner在其最终被调用时仍然能够访问`prompt`变量。&#125;sayHelloInFiveSeconds(&quot;Adam&quot;); // 会在5秒后弹出 &quot;Hello, Adam!&quot;\n\n对象、构造函数和原型\n对象中可以有成员函数，用.调用，this指针仍然有效\n\n // 但这个函数访问的其实是其运行时环境，而非定义时环境，即取决于函数是如何调用的。// 所以如果函数被调用时不在这个对象的上下文中，就不会运行成功了。var myFunc = myObj.myFunc;myFunc(); // = undefined\n\n\n可以在对象的定义之外定义一个函数，然后将函数指定为一个对象的函数：\n var myOtherFunc = function()&#123;    return this.myString.toUpperCase();&#125;// myObj.myString == &quot;hello world!&quot;;myObj.myOtherFunc = myOtherFunc;myObj.myOtherFunc(); // = &quot;HELLO WORLD!&quot;\n\n // 当我们通过`call`或者`apply`调用函数的时候，也可以为其指定一个执行上下文。var anotherFunc = function(s)&#123;    return this.myString + s;&#125;anotherFunc.call(myObj, &quot; And Hello Moon!&quot;); // = &quot;Hello World! And Hello Moon!&quot;// `apply`函数几乎完全一样，只是要求一个array来传递参数列表。anotherFunc.apply(myObj, [&quot; And Hello Sun!&quot;]); // = &quot;Hello World! And Hello Sun!&quot;// 当一个函数接受一系列参数，而你想传入一个array时特别有用。Math.min(42, 6, 27); // = 6Math.min([42, 6, 27]); // = NaN (uh-oh!)Math.min.apply(Math, [42, 6, 27]); // = 6// 但是`call`和`apply`只是临时的。如果我们希望函数附着在对象上，可以使用`bind`。var boundFunc = anotherFunc.bind(myObj);boundFunc(&quot; And Hello Saturn!&quot;); // = &quot;Hello World! And Hello Saturn!&quot;\n\n // `bind` 也可以用来部分应用一个函数（柯里化）。var product = function(a, b)&#123; return a * b; &#125;var doubler = product.bind(this, 2);doubler(8); // = 16\n\n\n构造函数：调用一个函数时前加上new关键字，会创建一个对象，这个函数一般是设计专门用来构造此对象的函数；此函数可以用this来访问对象\n\n原型：其实就是类的继承\n\n指定原型创建对象有两个方法\n\n// 第一种方式是 Object.create，这个方法是在最近才被添加到Js中的，// 因此并不是所有的JS实现都有这个方法var myObj = Object.create(myPrototype);myObj.meaningOfLife; // = 43// 第二种方式可以在任意版本中使用，不过必须通过构造函数。// 构造函数有一个属性prototype。但是它 *不是* 构造函数本身的原型；相反，// 是通过构造函数和new关键字创建的新对象的原型。MyConstructor.prototype = &#123;    myNumber: 5,    getMyNumber: function()&#123;        return this.myNumber;    &#125;&#125;;var myNewObj2 = new MyConstructor();myNewObj2.getMyNumber(); // = 5myNewObj2.myNumber = 6myNewObj2.getMyNumber(); // = 6\n\n// 字符串和数字等内置类型也有通过构造函数来创建的包装类型var myNumber = 12;var myNumberObj = new Number(12);myNumber == myNumberObj; // = true// 但是它们并非严格等价typeof myNumber; // = &#x27;number&#x27;typeof myNumberObj; // = &#x27;object&#x27;myNumber === myNumberObj; // = falseif (0)&#123;    // 这段代码不会执行，因为0代表假&#125;\n\n // 不过，包装类型和内置类型共享一个原型，// 所以你实际可以给内置类型也增加一些功能，例如对string：String.prototype.firstCharacter = function()&#123;    return this.charAt(0);&#125;&quot;abc&quot;.firstCharacter(); // = &quot;a&quot;// 这个技巧经常用在“代码填充”中，来为老版本的javascript子集增加新版本js的特性，// 这样就可以在老的浏览器中使用新功能了。// 比如，我们知道Object.create并没有在所有的版本中都实现，// 但是我们仍然可以通过“代码填充”来实现兼容：if (Object.create === undefined)&#123; // 如果存在则不覆盖    Object.create = function(proto)&#123;        // 用正确的原型来创建一个临时构造函数        var Constructor = function()&#123;&#125;;        Constructor.prototype = proto;        // 之后用它来创建一个新的对象        return new Constructor();    &#125;&#125;\n\n更多概念ansyc与awaitasync 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。\nawait 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。\n","categories":["递归这个世界 · 编程","编程语言"],"tags":["Programming","Web"]},{"title":"Project Manager","url":"/2023/05/25/note/Programming/Projects/projectmanager/","content":"需求：\n\n可以创建以 CMake ＋ make 为构建工具的 C++项目\n可以添加或删除 C++ 类，自动生成 .h 和 .cpp 文件，并补全必要代码\n可以使用命令进行构建和运行项目\n可以读取配置文件信息，如果没有，会初始化创建一个配置文件，配置文件信息包括：项目的路径，该路径中的所有项目，指定当前项目\n\n\n\n命令行参数及作用\n\n\nlong arg\narg\ndo\n\n\n\n--list\n-l\nshow the whole inforamtion\n\n\n--createproject\n-c\ncreate project\n\n\n--delproject\n-d\ndelete a prject\n\n\n--addclass\n-a\nadd class\n\n\n--delclass\nnone\ndelete a class\n\n\n--build\n-b\nbuild without run\n\n\n--run\n-r\nbuild and run\n\n\n--setproject\n-s\nset the current project\n\n\n--setpath\nnone\nset the project path\n\n\n--help\n-h\nshow help information\n\n\n项目地址https://gitee.com/sential/projectmanager\n安装脚本#!/bin/bashcdrm -rf ./projectmanagergit clone git@gitee.com:sential/projectmanager.gitcd projectmanager/buildrm -rf ./*cmake ..makesudo cp ./pm /usr/bin/pm\n\n开发过程中学到的东西命令行参数使用getopt()函数，原型为：int getopt(int argc, char *const *argv, const char *shortopts)\n或如果需要长参数，使用getopt_long()函数，原型为： int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind)\n使用方法是先创建三个参数，分别为命令行参数opt用以判定参数到底是哪一个，参数索引option_index，和长参数结构体数组本身long_options[]\n其中long_options[]的option类型的结构的，原型为：\nstruct option &#123;    const char *name;       // name is the name of the long option.    int         has_arg;    //has_arg is: no_argument (or 0) if the option does not take an argument;                            //required_argument (or 1) if the option requires an argument;                             //or optional_argument (or 2) if the option takes an optional argument.    int        *flag;       //flag specifies how results are returned for a long option. If flag is NULL, then getopt_long() returns val. (For example, the calling program may set val to the equivalent short option character.) Otherwise, getopt_long() returns 0, and flag points to a variable which is set to val if the option is found, but left unchanged if the option is not found.    int         val;        //val is the value to return, or to load into the variable pointed to by flag.    // The last element of the array has to be filled with zeros.&#125;;\n\n创建参数变量：\nint opt, option_index = 0;   option long_options[] = &#123;       &#123;&quot;create&quot;, 1, nullptr, &#x27;c&#x27;&#125;,  &#123;&quot;addclass&quot;, 1, nullptr, &#x27;a&#x27;&#125;,       &#123;&quot;setproj&quot;, 1, 0, &#x27;s&#x27;&#125;,       &#123;&quot;delproj&quot;, 1, nullptr, &#x27;d&#x27;&#125;,       &#123;&quot;list&quot;, 0, nullptr, &#x27;l&#x27;&#125;,    &#123;&quot;build&quot;, 0, nullptr, &#x27;b&#x27;&#125;,       &#123;&quot;run&quot;, 0, nullptr, &#x27;r&#x27;&#125;,     &#123;&quot;help&quot;, 0, nullptr, &#x27;h&#x27;&#125;,       &#123;&quot;setpath&quot;, 1, nullptr, &#x27;S&#x27;&#125;, &#123;&quot;delclass&quot;, 1, nullptr, &#x27;D&#x27;&#125;,   &#125;;\n\n然后创建一个获取参数的循环，使用函数getopt_long不断的获取参数，用switch判断参数是哪个，然后执行相应的动作\nwhile ((opt = getopt_long(argc, argv, &quot;lbra:c:hd:s:D:S:&quot;, long_options,                             &amp;option_index)) != -1) &#123;       switch (opt) &#123;       case &#x27;l&#x27;:           pm.list();           break;       case &#x27;c&#x27;:           pm.setCurrentProject(optarg);           pm.createProject();           break;       case &#x27;a&#x27;:           pm.addClass(pm.currentProject, optarg);           break;       case &#x27;b&#x27;:           pm.buildWithoutRun();           break;       case &#x27;r&#x27;:           pm.run();           break;       case &#x27;d&#x27;:           pm.delProject(optarg);           break;       case &#x27;h&#x27;:           pm.showHelp();           break;       case &#x27;s&#x27;:           pm.setCurrentProject(optarg);           break;       case &#x27;S&#x27;:           pm.setDefaultPath(optarg);           break;       case &#x27;D&#x27;:           pm.delClass(optarg);           break;       &#125;   &#125;\n\n打印彩色字符在输出流的字符前加上\\033[1m，可让字符高亮显示，[后的数字替换成其他可实现更多的效果：\n\n\n\ncode\n效果\n\n\n\n1\n让输出的字符高亮显式\n\n\n3\n输出斜体字\n\n\n4\n给输出的字符加上下划线\n\n\n5\n让输出的字符闪烁显式\n\n\n7\n设置反显效果，即把背景色和字体颜色反过来显示\n\n\n30\n表示黑色\n\n\n31\n表示红色\n\n\n32\n表示绿色\n\n\n33\n表示黄色\n\n\n34\n表示蓝色\n\n\n35\n表示紫色\n\n\n36\n表示浅蓝色\n\n\n37\n表示灰色\n\n\n40\n表示背景为黑色\n\n\n41\n表示背景为红色\n\n\n42\n表示背景为绿色\n\n\n43\n表示背景为黄色\n\n\n44\n表示背景为蓝色\n\n\n45\n表示背景为紫色\n\n\n46\n表示背景为浅蓝色\n\n\n47\n表示背景为灰白色\n\n\n0\n清除所有格式\n\n\n输出的格式像是一个状态机，输出流加入\\033[31m后的所有字符都会是红色，取消这个效果要加上\\033[0m，然后再进行其他的操作。\nUse bash by Stringstd::string cmd =    &quot;cd &quot; + projectPath + &quot;; mv -f &quot; + projectName + &quot; ./.dion_trash&quot;;system(cmd.c_str());\n","categories":["递归这个世界 · 编程","项目"],"tags":["CPP","CMake"]},{"title":"Clion配置xmake","url":"/2023/12/05/note/Programming/evn/Clion-xmake/","content":"Clion拥有强大的智能补全和改错功能，习惯了xmake的随处可用，就像在Clion上配置xmake构建的工程，核心仍然是compile_commands.json和xmake命令行。\n\n\n添加XMake自定义构建目标将一个xmake工程作为clion的项目打开。\n打开File | Settings | Build, Execution, Deployment | Custom Build Targets，添加一个新的target：\n\n名字随便填，设置Build：\n\n可以使用宏来设置路径，设置完成后如下图：\n\nclean同理：\n\n完成后：\n\n为工程添加配置\n添加一个Configurations，选择Custom Build Application：\n\n选择刚刚创建的XMake，并设置可执行文件的路径：\n\n\n注意图上是在debug目录下，xmake默认构建方式可能是release，可以根据自己的需要设置。\n\nxmake改成debug模式：\nxmake f -m debug\n\n这样就可以编译运行和debug了：\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","Clangd","XMake","Clion"]},{"title":"GDB 的使用","url":"/2023/05/25/note/Programming/evn/GDB/","content":"Compile the source file to the binary file.Add argument -g to generate a GDB binary file.\n\n\ngcc -g source.c -o outputg++ -g source.cpp -o outputls -atotal 52K-rw-r--r-- 1 dionysen dionysen  450 Oct  5 22:26 binary-search.cpp-rw-r--r-- 1 dionysen dionysen 2.5K Oct  2 14:29 linked-list.cpp-rw-r--r-- 1 dionysen dionysen  411 Oct  2 14:41 node.cpp-rwxr-xr-x 1 dionysen dionysen  37K Oct  5 23:04 output\n\n\n\n\nCommand\nFull name\nDo somthing\n\n\n\ngdb output\n\n\n\n\nr\nrun\nRun current program\n\n\nb\nbreak\nSet a breakpoint at [function] or [line] (in file)\n\n\nc\ncontinue\nContinue running your program (after stopping, e.g. at a breakpoint).\n\n\nn\nnext\nExecute next program line (after stopping); step over any function calls in the line.\n\n\ns\nstep\nExecute next program line (after stopping); step into any function calls in the line.\n\n\nl\nlist\nType the text of the program in the vicinity of where it is presently stopped.\n\n\np\nprint\nDisplay the value of an expression.\n\n\nwatch\nwatch\nSet a watchpoint in an address of expression\n\n\ni b\ninfo break\nCheck information of breakpoints.\n\n\nk\nkill\nKill the program being debugged.\n\n\nq\nquit\nExit from GDB.\n\n\n\nYou can use shell [args] to execute a shell command.\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","Linux","C","Debug"]},{"title":"Git 的使用","url":"/2023/05/25/note/Programming/evn/Git/","content":"分布式版本控制系统，适合个人、中小企业使用。\n\n\nInstallationsudo pacman -S git\n\nUsage基本配置配置git 的用户名和邮箱：\ngit config --global user.name &quot;dionysen&quot;git config --global user.email &quot;solongnight@outlook.com&quot;\n\n新建一个仓库Initiate git repository on the local:\ngit init  \n\nor set the file path:\ngit init path/to/repo\n\nA repository was created, but it is empty.You can add some files to the repository:\ngit add [filename]  // e.g. &quot;git add .&quot;\n\nThen you add this files to the stages and you need to commit this to the repository.\ngit commit -a -m &quot;Changed some files&quot;\n\n-a does not commit any new files.-m means that you should give the commit message.Add a remote repository:\ngit remote add origin git@gitee.com:sential/source.git\n\nPush the local repository to the remote repository:\ngit push origin master\n\n\n若要在一个新的设备上使用远程仓库，首先将此仓库克隆到本地：\n\ngit clone git@gitee.com:sential/source.git# 值得注意的是gitee的仓库公钥管理方式导致必须使用ssh克隆，否则难以实现无密码修改远程仓库# 官方提示：使用SSH公钥可以让你在你的电脑和 Gitee 通讯的时候使用安全连接（Git的Remote要使用SSH地址）\n\n添加个人公钥然后按照 gitee 上的提示添加个人公钥:\nssh-keygen -t ed25519 -C &quot;xxxxx@xxxxx.com&quot;  # Generating public/private ed25519 key pair...cat ~/.ssh/id_ed25519.pub# ssh-ed25519 AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....ssh -T git@gitee.com\n\n与远程仓库同步每次编辑时要执行。\ngit pull origin master# 然后开始编辑# 完成后执行：git add .git commit -a -m &quot;Changed some files&quot;git push origin master\n\n或者每次编辑完成后，在另一处pull一次，那样不用每次编辑前都要再拉去一下了。写两个脚本自动拉取和提交。\n\n当没有拉取最新版本的远程仓库同时又修改了本地仓库时，拉取会提示错误，需要选择合并或者放弃某一端，如果放弃本地仓库，执行以下命令：\n\ngit reset --hardgit pull origin master\n\n分支切换查看分支：\ngit branch -a \t# 查看远程分支git branch \t\t# 查看本地分支\n\n新建分支：\ngit checkout -b linux origin/linux#完成新分支的修改后git add .git commit -a -m &quot;Changed some files&quot;git push --set-upstream origin origin/linux\n\n之后即可正常使用，切换分支使用命令：\ngit checkout main # 切换到主分支\n\n不修改.gitignore的情况下忽略本地修改如想忽略项目文件夹下的.vscode中的settings.json\ngit update-index --skip-worktree .vscode/settings.json\n\n如果时间久了，忘了哪些文件被忽略了，那么可以通过 git ls-files -v 来查看，其结果中第一列打 S 标记的项目就是被忽略（Skip-worktree）的项目（关于符号的更多说明可以参考官方文档）。我们可以通过 grep 或是 PowerShell 中的 Select-String 来将这些项目过滤出来。\ngit ls-files -v | grep -E -i .vscode/settings.json\n\npowershell:\ngit ls-files -v | Select-String -Pattern .vscode/settings.json\n\n如何拉取远程分支出现冲突，可能需要恢复忽略，解决冲突：\ngit update-index --no-skip-worktree .vscode/settings.json\n\n查看仓库状态git status\n\n差异比较\n显示出branch1和branch2中差异的部分\n\ngit diff branch1 branch2 --stat\n\n\n显示指定文件的详细差异\n\ngit diff branch1 branch2 具体文件路径\n\n\n显示出所有有差异的文件的详细差异\n\ngit diff branch1 branch2\n\n\n查看branch1分支有，而branch2中没有的log\n\ngit log branch1 ^branch2\n\n\n查看branch2中比branch1中多提交了哪些内容\n\ngit log branch1..branch2\n\n\n注意，列出来的是两个点后边（此处即dev）多提交的内容。\n\n\n不知道谁提交的多谁提交的少，单纯想知道有是吗不一样\n\ngit log branch1...branch2\n\n\n在上述情况下，在显示出没个提交是在哪个分支上\n\ngit log --lefg-right branch1...branch2\n\n\n注意 commit 后面的箭头，根据我们在 –left-right branch1…branch2 的顺序，左箭头 &lt; 表示是 branch1 的，右箭头 &gt; 表示是branch2的。\n\n子模块管理添加子模块：\ngit submodule add &lt;URL-to-module1&gt; devices/module1\n\nGit会自动为子模块创建一个独立的目录，并从远程仓库中克隆子模块的代码到这个目录中。\n一般情况要在子模块中对子模块进行操作，如修改后提交和推送。\n确保子模块是最新的：\ngit submodule update --remote\n\n子模块处理好之后，父模块在提交和推送时会包含子模块的改动。\n\n远程删除分支后，本地可能还会保留记录，使用如下命令与远程同步\n\ngit remote prune origin\n\nwarning: redirecting to https://xxxxx.git服务器安全提醒，重新配置origin：\ngit remote remove origingit remote add origin https://xxxx.git\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["Linux","Git"]},{"title":"OpenGL开发环境搭建","url":"/2023/06/09/note/Programming/evn/OpenGL-env/","content":"\n🔨学习OpenGL，在不同平台使用不同工具构建项目的方法。\n\n\n\nArchlinuxArchlinux 配置 OpenGL 开发环境 (glfw + glad)\nGLFW\n\n安装glfw库\nsudo pacman -S glfw-x11\n\n\nGLAD\n\n\n\n在此网站选择需要的版本https://glad.dav1d.de，点击GRNERATE，下载生成的zip文件，解压后将其放到项目文件夹中。\n文件目录为：\n├── CMakeLists.txt├── glad│   ├── include│   │   ├── glad│   │   │   └── glad.h│   │   └── KHR│   │       └── khrplatform.h│   └── src│       └── glad.c└── main.cpp\n\nCMakeLists.txt可以写成如下：\ncmake_minimum_required(VERSION 3.14)project(OpenglTest)set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # Make sure clang can find .h fileset(CMAKE_CXX_STANDARD 11)set(SOURCE_FILES main.cpp glad/src/glad.c) # src filesinclude_directories(glad/include) # include filesadd_executable(OpenglTest $&#123;SOURCE_FILES&#125;)target_link_libraries(OpenglTest glfw) # link the glfw library\n\nArchlinux 安装glew并配置CMakesudo pacman -S glewlwyd glew1.10 glew\n\n在项目中的CMakeLists.txt中配置：\ncmake_minimum_required(VERSION 3.14)project(OpenglTest)find_package(OpenGL REQUIRED)if(NOT OPENGL_FOUND)     message(&quot;ERROR: OpenGL not found&quot;)endif(NOT OPENGL_FOUND)set(CMAKE_EXPORT_COMPILE_COMMANDS ON)set(CMAKE_CXX_STANDARD 11)set(SOURCE_FILES main.cpp)# include_directories(glad/include)add_executable(OpenglTest $&#123;SOURCE_FILES&#125;)find_package(GLEW REQUIRED)target_link_libraries(OpenglTest glfw GLEW::GLEW libGL.so)\n\n编写代码main.cpp：\n#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;int main(void) &#123;    // glfw: initialize and configure    // ------------------------------    if (!glfwInit())     &#123;        return -1;    &#125;    // glfw window creation    // --------------------    GLFWwindow *window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);    if (window == NULL)    &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    &#125;    glfwMakeContextCurrent(window);    if (GLEW_OK != glewInit())    &#123;        std::cout &lt;&lt; &quot;Error!&quot; &lt;&lt; std::endl;    &#125;        while (!glfwWindowShouldClose(window))     &#123;        glClear(GL_COLOR_BUFFER_BIT);        glBegin(GL_TRIANGLES);        glVertex2f(-0.5f, -0.5f);        glVertex2f(0.0f, 0.5f);        glVertex2f(0.5f, -0.5f);        glEnd();        glfwSwapBuffers(window);        glfwPollEvents();    &#125;    // glfw: terminate, clearing all previously allocated GLFW resources.    // ------------------------------------------------------------------    glfwTerminate();    return 0;&#125;\n\n编译运行：\n\nWindows 10&#x2F;11Visual Studio on Windows 配置 OpenGL 开发环境（使用解决方案链接库）\nGLFW（手动编译，没有必要）\n\n下载CMake（x64）：https://github.com/Kitware/CMake/releases/download/v3.26.4/cmake-3.26.4-windows-x86_64.msi\n下载GLFW源码：https://github.com/glfw/glfw/releases/download/3.3.8/glfw-3.3.8.zip，并解压\n打开CMake-GUI，设置如下：\n \n\n点击Configure，选择自己需要的VS版本和架构：\n\n\n点击Generate，会源文件中生成一个build文件夹，用 VS 打开其中的GLFW.sln，生成，然后将生成的dll文件放置好\n\nGLFW\n\n直接下载Windows版本的预编译文件，其中有includes和dll文件，链接到项目即可使用\n\nGLAD\n\n与Linux版本相同，均为将源代码文件包含到项目中\nVisual Studio 使用 CMake 配置 glfw + glad其他与上文大致相同，下载编译glfw，生成下载对应的glad，然后将编译好的glfw库文件和glad的源文件放到项目文件夹中，文件结构如下图：\n\n然后在CMakeLists.txt中配置：\n# CMakeList.txt: opengl_test 的 CMake 项目，在此处包括源代码并定义# 项目特定的逻辑。#cmake_minimum_required (VERSION 3.8)# Enable Hot Reload for MSVC compilers if supported.if (POLICY CMP0141)  cmake_policy(SET CMP0141 NEW)  set(CMAKE_MSVC_DEBUG_INFORMATION_FORMAT &quot;$&lt;IF:$&lt;AND:$&lt;C_COMPILER_ID:MSVC&gt;,$&lt;CXX_COMPILER_ID:MSVC&gt;&gt;,$&lt;$&lt;CONFIG:Debug,RelWithDebInfo&gt;:EditAndContinue&gt;,$&lt;$&lt;CONFIG:Debug,RelWithDebInfo&gt;:ProgramDatabase&gt;&gt;&quot;)endif()project (&quot;opengl_test&quot;)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include) #添加包含的头文件link_directories(lib) #添加要链接的lib文件# 将源代码添加到此项目的可执行文件。file(COPY &quot;lib&quot; DESTINATION $&#123;CMAKE_BINARY_DIR&#125;)file(GLOB_RECURSE  src_dir &quot;./src/*.c&quot; &quot;./src/*.h&quot; &quot;./src/*.cpp&quot; )add_executable (opengl_test &quot;main.cpp&quot; $&#123;src_dir&#125;)if (CMAKE_VERSION VERSION_GREATER 3.12)  set_property(TARGET opengl_test PROPERTY CXX_STANDARD 20)endif()# TODO: 如有需要，请添加测试并安装目标。target_link_libraries(opengl_test glfw3 opengl32)\n\n将OpenGL基础 | DIONYSEN BLOG的源码添加到main.cpp，编译运行：\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["Linux","OpenGL","Windows"]},{"title":"VSCode Clangd配置","url":"/2023/09/14/note/Programming/evn/clangd/","content":"\n\n\n使用clangd作为语法检查工具，跨平台，简单易用，方便更换环境。\n\n\n\nVSCode配置clangd下载安装llvm，并将bin文件夹添加到环境变量中。\nVSCode中安装clangd插件，如果路径中找不到clangd，会提示安装clangd，点击是就可以。\n\n打开设置，打开json文件：\n&#123;    &quot;workbench.tree.indent&quot;: 10,    &quot;workbench.colorTheme&quot;: &quot;GitHub Dark&quot;,    &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;,    &quot;workbench.tree.renderIndentGuides&quot;: &quot;always&quot;,    &quot;workbench.activityBar.location&quot;: &quot;hidden&quot;,    // Editor    &quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;,&#x27;Courier New&#x27;, Monaco, Menlo, &#x27;Droid Sans Mono&#x27;, Hack,   Consolas, monospace, Monaco&quot;,    &quot;editor.fontWeight&quot;: &quot;400&quot;,    &quot;editor.lineHeight&quot;: 1.7,    &quot;editor.wordWrap&quot;: &quot;on&quot;,    &quot;editor.smoothScrolling&quot;: true,    &quot;editor.mouseWheelZoom&quot;: true,    &quot;editor.guides.indentation&quot;: true,    &quot;editor.fontSize&quot;: 16,    &quot;editor.links&quot;: false,    &quot;editor.inlayHints.enabled&quot;: &quot;off&quot;,    &quot;editor.stickyScroll.enabled&quot;: true,    &quot;editor.minimap.enabled&quot;: true,    &quot;editor.minimap.showSlider&quot;: &quot;always&quot;,    &quot;editor.scrollbar.vertical&quot;: &quot;hidden&quot;,    &quot;files.autoSave&quot;: &quot;onFocusChange&quot;,    // Termial    &quot;terminal.integrated.fontSize&quot;: 15,    &quot;terminal.integrated.fontFamily&quot;: &quot;&#x27;Courier New&#x27;, Monaco&quot;,    &quot;terminal.integrated.fontWeight&quot;: &quot;normal&quot;,    &quot;terminal.integrated.enableMultiLinePasteWarning&quot;: false,    // Miscellaneous    &quot;git.enabled&quot;: false,    &quot;git.ignoreMissingGitWarning&quot;: true,    &quot;git.openRepositoryInParentFolders&quot;: &quot;never&quot;,    &quot;explorer.confirmDelete&quot;: false,    &quot;extensions.ignoreRecommendations&quot;: true,    // Custom    &quot;command-runner.commands&quot;: &#123;        &quot;run&quot;: &quot;cls; xmake; .\\\\build\\\\windows\\\\x64\\\\debug\\\\opengl.exe&quot;,    &#125;,    // Compiler    &quot;clangd.path&quot;: &quot;c:\\\\Users\\\\dionysen\\\\AppData\\\\Roaming\\\\Code\\\\User\\\\globalStorage\\\\llvm-vs-code-extensions.vscode-clangd\\\\install\\\\17.0.3\\\\clangd_17.0.3\\\\bin\\\\clangd.exe&quot;,     &quot;window.commandCenter&quot;: false,    &quot;workbench.layoutControl.enabled&quot;: false,    &quot;clangd.arguments&quot;: [        // 让 Clangd 生成更详细的日志        &quot;--log=verbose&quot;,        // 输出的 JSON 文件更美观        &quot;--pretty&quot;,        // compelie_commands.json 文件的目录位置(相对于工作区，由于 CMake 生成的该文件默认在 build 文件夹中，故设置为 build)        &quot;--compile-commands-dir=.&quot;,        // 允许补充头文件        &quot;--header-insertion=iwyu&quot;,    ],&#125;\n\n此时就可以正常使用了，可以使用不同的构建工具来生成compile_commands.json来让clangd识别你的头文件和源文件。如使用xmake创建一个工程：\nPS C:\\Users\\dionysen\\test&gt; xmake create -P ./hellocreate hello ...  [+]: src\\main.cpp  [+]: xmake.lua   [+]: .gitignorecreate ok!       \n\n在工程目录下创建文件夹headers，并在其下创建文件func.h，可以看到已经可以自动补全了并提示错误或警告了：\n\n此时在main.cpp中包含头文件func.h会提示找不到：\n\n因为clangd不知道要去哪里搜索你的头文件，compile_commands.json文件用以记录文件目录、编译指令等，故名编译数据库。\n在xmake.lua中添加add_includedirs(&quot;./headers&quot;)\nadd_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)target(&quot;hello&quot;)    set_kind(&quot;binary&quot;)    add_files(&quot;src/*.cpp&quot;)    add_includedirs(&quot;./headers&quot;)\n\nheaders文件夹下的所有.h文件都会被添加到编译数据库中。然后使用xmake生成compile_commands.json，终端中输入：\nPS C:\\Users\\dionysen\\test\\hello&gt; xmake project -k compile_commandschecking for platform ... windowschecking for architecture ... x64checking for Microsoft Visual Studio (x64) version ... 2022checking for Microsoft C/C++ Compiler (x64) version ... 19.37.32825create ok!\n\n\n目录中会出现compile_commands.json文件，在voscode的设置json文件中设置compile_commands.json文件的路径.即与xmake.lua同一个文件夹。\n&quot;clangd.arguments&quot;: [    &quot;--compile_commands_dir=.&quot;,    &quot;--clang-tidy&quot;,                 // 开启clang-tidy    &quot;--all-scopes-completion&quot;,      // 全代码库补全    &quot;--completion-style=detailed&quot;,  // 详细补全        &quot;--background-index&quot;],\n\n此时发现错误提示都不见了：\n\n编译运行也没有问题：\n\n使用clang-format格式化代码设置中找到\n开启之后会在保存文件时自动格式化代码，很是方便。\nctri+shift+p开发命令面板，输入format，找到选项\n\n选择\n将默认格式化工具设置为clangd，然后clangd就会根据工作目录下的.clang-format进行格式化了，以下是.clang-format的备份：\n--- BasedOnStyle: Microsoft# 访问说明符(public、private等)的偏移AccessModifierOffset: -2# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)AlignAfterOpenBracket: AlwaysBreak# 连续赋值时，对齐所有等号AlignConsecutiveAssignments: true# 连续声明时，对齐所有声明的变量名AlignConsecutiveDeclarations: true# 左对齐逃脱换行(使用反斜杠换行)的反斜杠AlignEscapedNewlinesLeft: true# 水平对齐二元和三元表达式的操作数AlignOperands: true# 对齐连续的尾随的注释AlignTrailingComments: true# 允许函数声明的所有参数在放在下一行AllowAllParametersOfDeclarationOnNextLine: false# 允许短的块放在同一行AllowShortBlocksOnASingleLine: true# 允许短的case标签放在同一行AllowShortCaseLabelsOnASingleLine: false# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), AllAllowShortFunctionsOnASingleLine: Inline# 允许短(只有一行时)的if语句保持在同一行AllowShortIfStatementsOnASingleLine: false# 允许短的循环保持在同一行AllowShortLoopsOnASingleLine: true# 总是在定义返回类型后换行(deprecated)AlwaysBreakAfterDefinitionReturnType: None# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)AlwaysBreakAfterReturnType: None# 总是在多行string字面量前换行AlwaysBreakBeforeMultilineStrings: false# 总是在template声明后换行AlwaysBreakTemplateDeclarations: false# false表示函数实参要么都在同一行，要么都各自一行BinPackArguments: true# false表示所有形参要么都在同一行，要么都各自一行BinPackParameters: true# 使用Microsoft风格，故不再配置# # 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)# BreakBeforeBinaryOperators: NonAssignment# # 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), # #   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), # #   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom# #   注：这里认为语句块也属于函数# BreakBeforeBraces: Custom# # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效# BraceWrapping:   #   # class定义后面#   AfterClass: true#   # 控制语句后面#   AfterControlStatement: false#   # enum定义后面#   AfterEnum: false#   # 函数定义后面#   AfterFunction: true#   # 命名空间定义后面#   AfterNamespace: false#   # ObjC定义后面#   AfterObjCDeclaration: false#   # struct定义后面#   AfterStruct: false#   # union定义后面#   AfterUnion: false#   # catch之前#   BeforeCatch: true#   # else之前#   BeforeElse: true#   # 缩进大括号#   IndentBraces: true# 在三元运算符前换行BreakBeforeTernaryOperators: true# 在构造函数的初始化列表的逗号前换行BreakConstructorInitializersBeforeComma: true# 每行字符的限制，0表示没有限制# ColumnLimit: 200# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变CommentPragmas: &#x27;^ IWYU pragma:&#x27;# 构造函数的初始化列表要么都在同一行，要么都各自一行ConstructorInitializerAllOnOneLineOrOnePerLine: true# 构造函数的初始化列表的缩进宽度ConstructorInitializerIndentWidth: 4# 延续的行的缩进宽度ContinuationIndentWidth: 4# 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格Cpp11BracedListStyle: false# 继承最常用的指针和引用的对齐方式DerivePointerAlignment: false# 关闭格式化DisableFormat: false# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)ExperimentalAutoDetectBinPacking: false# 需要被解读为foreach循环而不是函数调用的宏ForEachMacros: [ foreach, Q_FOREACH, BOOST_FOREACH ]# 缩进case标签IndentCaseLabels: false# 缩进宽度IndentWidth: 4# 函数返回类型换行时，缩进函数声明或函数定义的函数名IndentWrappedFunctionNames: false# 保留在块开始处的空行KeepEmptyLinesAtTheStartOfBlocks: true# 开始一个块的宏的正则表达式MacroBlockBegin: &#x27;&#x27;# 结束一个块的宏的正则表达式MacroBlockEnd: &#x27;&#x27;# 连续空行的最大数量MaxEmptyLinesToKeep: 1# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), AllNamespaceIndentation: Inner# 在call(后对函数调用换行的penaltyPenaltyBreakBeforeFirstCallParameter: 19# 在一个注释中引入换行的penaltyPenaltyBreakComment: 300# 指针和引用的对齐: Left, Right, MiddlePointerAlignment: Left# 允许重新排版注释ReflowComments: true# 允许排序#includeSortIncludes: true# 在赋值运算符之前添加空格SpaceBeforeAssignmentOperators: true# 开圆括号之前添加一个空格: Never, ControlStatements, AlwaysSpaceBeforeParens: ControlStatements# 在空的圆括号中添加空格SpaceInEmptyParentheses: false# 在尾随的评论前添加的空格数(只适用于//)SpacesBeforeTrailingComments: 2# 在尖括号的&lt;后和&gt;前添加空格SpacesInAngles: false# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, AlwaysUseTab: Never\n\nDebug参考VS code 安装插件 lldb 调试 CPP 程序。\n注意使用xmake时要配置为debug模式：\nxmake f --mode=debug\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","Linux","Clangd"]},{"title":"Vim 使用 coc-nvim 的 coc-clangd 关闭参数提示","url":"/2023/06/12/note/Programming/evn/coc-nvim-inlay-hint/","content":"在Vim中使用Coc-nvim提供的coc-clangd，会默认开启Inlay-hint，也即如图所示的参数提示，它可以帮助我们快速分辨参数，但有时候也会影响代码的整洁和对代码长度的估量，除去的方法为在Coc-config中关闭inlayHint.enable选项。\n\n\n\n\n在Vim中输入命令CocConfig，回车\n将inlayHint.enable选项设置为false\n\n然后即可看到Inlay-hint的效果已经不见了\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","Linux","Clangd","Vim"]},{"title":"Clangd Config CMakeLists. txt","url":"/2023/05/25/note/Programming/evn/cpp_config/","content":"Vim using Coc-nvim plugin clangd-lsp need to read CMakeLists.txt so that it can auto-complete your code.If your project builds with CMake, it can generate this file. You should enable it with:\ncmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1\n\nOr add to CMakeLists.txt:\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\ncompile_commands.json will be written to your build directory. If your build directory is $SRC or $SRC/build, clangd will find it. Otherwise, symlink or copy it to $SRC, the root of your source tree.\nln -s ~/myproject-build/compile_commands.json ~/myproject/\n\nGenerated compile_commands.json can support auto completion for third party libraries.\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","Linux","CMake","Clangd"]},{"title":"Cursor 使用 cppvsdbg","url":"/2025/06/10/note/Programming/evn/cursor-cppvsdbg/","content":"\nFrom https://gist.github.com/Ouroboros/1a1e0b9c8bcbac2a519516aa5a12a52b\n\n\n\nRequire:\n\nCursor\ncpptools-extension v1.23.5或v1.23.6\n\n步骤\n打开%USERPROFILE%\\.cursor\\extensions\\ms-vscode.cpptools-1.23.5-win32-x64\\package.json\n\n&quot;type&quot;: &quot;cppvsdbg&quot;,\n&quot;label&quot;: &quot;C++ (Windows)&quot;,\n&quot;when1&quot;: &quot;workspacePlatform == windows&quot;, // 删除这一行\n\n\n安装Microsoft “Hex Editor” extension - https://marketplace.cursorapi.com/items?itemName=ms-vscode.hexeditor，插件商店直接安装也可以\n\n使用Hex Editor打开%USERPROFILE%\\.cursor\\extensions\\ms-vscode.cpptools-1.23.5-win32-x64\\debugAdapters\\vsdbg\\bin\\vsdbg.dll\n\n二进制模式查找488D159E4B0600\n\n\n改成如下：\n\n重启插件即可\n\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","VScode","Cursor","cppvsdbg"]},{"title":"xmake分布式编译","url":"/2025/07/08/note/Programming/evn/distcc/","content":"\nXMake分布式编译\n\n\n\n如果集群不在同一个局域网下，需要内网穿透。\nFRP内网穿透本质上是一个反向代理，将拥有公网IP的服务端的特定端口代理到无公网IP的客户端的特定端口，实现通过公网IP访问服务端即可达到访问内网中客户端的目的。\n必要条件：拥有一个公网IP。\n步骤服务端\n下载FRP\n\n解压缩，配置服务端配置文件frps.toml\n\nbindPort=7000\n\n启动frps（记得防火墙要打开7000端口）\n\n\n自启动编辑sudo vim /etc/systemd/system/frp.service\n[Unit]Description=frpcAfter=network.target[Service]TimeoutStartSec=30ExecStart=/home/dionysen/frps/frps -c /home/dionysen/frps/frps.tomlExecStop=/bin/kill $MAINPID[Install]WantedBy=multi-user.target\n\n然后sudo systemctl enable frp --now即可。\n客户端\n下载FRP\n解压缩，编辑客户端配置文件frpc.toml：\n\nserverAddr = &quot;x.x.x.x&quot;serverPort = 7000[[proxies]]name = &quot;ssh&quot;type = &quot;tcp&quot;localIP = &quot;0.0.0.0&quot;localPort = 22remotePort = 6000[[proxies]]name = &quot;xmake-remote-build&quot;type = &quot;tcp&quot;localIP = &quot;127.0.0.1&quot;localPort = 9691remotePort = 9691[[proxies]]name = &quot;xmake-remote-cache&quot;type = &quot;tcp&quot;localIP = &quot;127.0.0.1&quot;localPort = 9692remotePort = 9692[[proxies]]name = &quot;xmake-distcc-build&quot;type = &quot;tcp&quot;localIP = &quot;127.0.0.1&quot;localPort = 9693remotePort = 9693\n\n其中x.x.x.x是公网IP，服务端口与服务端绑定的保持一致即可。\n下面的代理则是按需配置，我需要配置xmake的分布式编译、远程编译、远程缓存，所以加了三个，端口一一对应。\n第一个ssh是一个测试，即将服务端的6000端口方向代理到客户端的22端口，这样通过访问公网的x.x.x.x:6000即可访问到客户端的22端口，可作为配置成功与否的标志。（注意windows系统的sshd可有会有问题，这是sshd配置本身的问题，与frp无关）\nXMake分布式编译参考XMake分布式编译\n上面内网穿透配置完成后，即可进行配置分布式编译。\n拥有公网IP的服务器作为一个代理，此时与配置FRP时的客户端一起作为一个服务端（通过公网IP访问）。\n服务端初始化通过下面命令初始化，会生成token，也会显示配置文件的目录：\nxmake service\n\n显示为：\nxmake servicegenerating the config file to /Users/ruki/.xmake/service/server.conf ..an token(590234653af52e91b9e438ed860f1a2b) is generated, we can use this token to connect service.generating the config file to /Users/ruki/.xmake/service/client.conf ..&lt;distcc_build_server&gt;: listening 0.0.0.0:9693 ..\n\n编辑配置文件：\n&#123;    distcc_build = &#123;        listen = &quot;0.0.0.0:9693&quot;,        toolchains = &#123;            ndk = &#123; &#125;        &#125;,        workdir = [[C:\\Users\\Dionysen\\AppData\\Local\\.xmake\\service\\server\\distcc_build]]    &#125;,    known_hosts = &#123; &#125;,    logfile = [[C:\\Users\\Dionysen\\AppData\\Local\\.xmake\\service\\server\\logs.txt]],    recv_timeout = -1,    remote_build = &#123;        listen = &quot;0.0.0.0:9691&quot;,        workdir = [[C:\\Users\\Dionysen\\AppData\\Local\\.xmake\\service\\server\\remote_build]]    &#125;,    remote_cache = &#123;        listen = &quot;0.0.0.0:9692&quot;,        workdir = [[C:\\Users\\Dionysen\\AppData\\Local\\.xmake\\service\\server\\remote_cache]]    &#125;,    send_timeout = -1,    tokens = &#123;        &quot;caa8b09d49f02608e491d756f1107d55&quot;    &#125;&#125;\n\n其中distcc_build为分布式编译，remote_build为远程编译，remote_cache为远程编译缓存，这是三个服务，可以同时开启。个人开发者通常使用分布式编译和远程编译即可。\n启动服务xmake service  # 启动远程编译服务xmake service --distcc  # 启动分布式编译服务xmake service --ccache  # 启动远程缓存服务# 以 Daemon 模式开启服务xmake service --distcc --startxmake service --distcc --restartxmake service --distcc --stop\n\n客户端配置&#123;    distcc_build = &#123;        hosts = &#123;            &#123;                connect = &quot;x.x.x.x:9693&quot;,                token = &quot;caa8b09d49f02608e491d756f1107d55&quot;,                njob = 16, // 并行任务数            &#125;        &#125;    &#125;,    remote_build = &#123;        connect = &quot;x.x.x.x:9691&quot;,        token = &quot;caa8b09d49f02608e491d756f1107d55&quot;,        njob = 16    &#125;,    remote_cache = &#123;        connect = &quot;x.x.x.x:9692&quot;,        token = &quot;caa8b09d49f02608e491d756f1107d55&quot;    &#125;,    connect_timeout = 10000,    send_timeout = -1，    recv_timeout = -1&#125;\n\n客户端配置主要是公网IP和端口、token，以及并行任务数。\n连接cd projectdirxmake service --connect --distcc&lt;client&gt;: connect 127.0.0.1:9693 ..&lt;client&gt;: 127.0.0.1:9693 connected!\n\n我们也可以同时连接多个服务，比如分布式编译和远程编译缓存服务。\nxmake service --connect --distcc --ccache\n\n断开连接：\nxmake service --disconnect --distcc\n\n更多信息和使用方式可查阅xmake文档。\n问题总结fallback to the local compiler, &lt;socket: tcp4/1464.0&gt;: sendfile timeout!fallback to the local compiler, &lt;socket: tcp4/1460.0&gt;: sendfile timeout!fallback to the local compiler, &lt;socket: tcp4/1472.0&gt;: sendfile timeout!\n\n出现以上错误，是分布式编译过程中，发送文件超时导致，这与网络带宽关系很大，尤其是内网穿透还会涉及到公网服务器的网络带宽（购买的服务器有带宽限制）。\n这是需要平衡速度，主要修改的是超时时间和并行任务数，可以适当地增大超时时间，减小并行任务数来缓解此问题。\n-1表示无限等待。\nconnect_timeout = 10000,send_timeout = -1，recv_timeout = -1\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","xmake，distcc"]},{"title":"node-addon-api配置cmake-js","url":"/2024/11/17/note/Programming/evn/node-addon-api/","content":"Node-addon-api是一个node-module，用以简化使用 C++ 时 Node.js 提供的基于 C 的 Node-API 的使用。它以较低的开销提供 C++ 对象模型和异常处理语义。但是其配置有时候极其恶心，费劲心力，也无法正常使用，浪费人生。\n\n\nnode-addon-api 基于 Node-API，支持使用不同的 Node-API 版本。这样，使用它构建的插件就可以与支持目标 Node-API 版本的 Node.js 版本一起运行。但是，node-addon-api 支持模型仅支持活动的 LTS Node.js 版本。这意味着每年都会有一个新的主要版本，不再支持已停止使用的 Node.js LTS 版本。 当前版本的 node-addon-api 支持的最旧 Node.js 版本是 Node.js 18.x。\n构建可以使用两种工具：node-gyp、cmake-js。\nnode-gypnode-gyp is a build system based on the gyp-next fork of Google’s GYP tool and comes bundled with npm. GYP, and therefore node-gyp, requires that Python be installed.\nHistorically, node-gyp has been the tool of choice for building native addons. It has widespread adoption and documentation. However, some developers have run into limitations in node-gyp.\n当你电脑上有多个vs版本时，node-gyp需要指定msvs_version，否则就会出现以下错误，找不到可用的VS：\n\nnpm config set msvs_version=2015\n\n如果提示npm没有这个选项，就安装npm8：\nnpm install -g npm@^8\n\n然后就可以设置了。\n但我依然会出现找不到VS的情况，于是使用cmake-js.\nCMake.jsCMake.js is an alternative build system based on CMake.\nCMake.js is a good choice for projects that already use CMake or for developers affected by limitations in node-gyp. build_with_cmake is an example of a CMake-based native addon project.\nInstallnpm install -g npm@^8  # 安装npm8npm set config msvs-version=2015npm install -g cmake-js@^7.3.0\n\nStart官方示例：\ncmake_minimum_required(VERSION 3.15)cmake_policy(SET CMP0091 NEW)cmake_policy(SET CMP0042 NEW)project (your-addon-name-here)add_definitions(-DNAPI_VERSION=4)include_directories($&#123;CMAKE_JS_INC&#125;)file(GLOB SOURCE_FILES &quot;your-source files-location-here&quot;)add_library($&#123;PROJECT_NAME&#125; SHARED $&#123;SOURCE_FILES&#125; $&#123;CMAKE_JS_SRC&#125;)set_target_properties($&#123;PROJECT_NAME&#125; PROPERTIES PREFIX &quot;&quot; SUFFIX &quot;.node&quot;)target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;CMAKE_JS_LIB&#125;)if(MSVC AND CMAKE_JS_NODELIB_DEF AND CMAKE_JS_NODELIB_TARGET)  # Generate node.lib  execute_process(COMMAND $&#123;CMAKE_AR&#125; /def:$&#123;CMAKE_JS_NODELIB_DEF&#125; /out:$&#123;CMAKE_JS_NODELIB_TARGET&#125; $&#123;CMAKE_STATIC_LINKER_FLAGS&#125;)endif()\n\n使用方法几乎与cmake一样，命令为cmake-js。\ncmake-js configure -G &quot;Visual Studio 14 2015&quot; -A x64cmake-js compile -G &quot;Visual Studio 14 2015&quot; -A x64cmake-js cleancmake-js rebuild\n\n\ncmake-js不支持导出compile_commands.json，推荐使用VS打开了其在build文件夹生成的.sln，或使用VSCode的cmake插件+c++插件，可以自动识别CMakeLists.txt进行智能提示和补全。\n\nExample链接ODA库：\ncmake_minimum_required(VERSION 3.11)set(CMAKE_EXPORT_COMPILE_COMMANDS ON)cmake_policy(SET CMP0042 NEW)set(CMAKE_CXX_STANDARD 17)project(dwgExporter)include_directories($&#123;CMAKE_JS_INC&#125;)file(        GLOB        SOURCE_FILES        &quot;src/*.cpp&quot;        &quot;src/*.h&quot;)# set utf-8 for spdlog to support unicodeadd_compile_options(/utf-8)# set lib path before add_librarylink_directories($&#123;CMAKE_SOURCE_DIR&#125;/external/ODA/lib)link_directories($&#123;CMAKE_SOURCE_DIR&#125;/external/spdlog/lib)add_library($&#123;PROJECT_NAME&#125; SHARED $&#123;SOURCE_FILES&#125; $&#123;CMAKE_JS_SRC&#125;)set_target_properties($&#123;PROJECT_NAME&#125; PROPERTIES PREFIX &quot;&quot; SUFFIX &quot;.node&quot;)set_target_properties($&#123;PROJECT_NAME&#125; PROPERTIES        LINK_FLAGS &quot;/DELAYLOAD:node.exe&quot;)target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;CMAKE_JS_LIB&#125;)# Include Node-API wrappersexecute_process(COMMAND node -p &quot;require(&#x27;node-addon-api&#x27;).include&quot;        WORKING_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;        OUTPUT_VARIABLE NODE_ADDON_API_DIR)string(REGEX REPLACE &quot;[\\r\\n\\&quot;]&quot; &quot;&quot; NODE_ADDON_API_DIR $&#123;NODE_ADDON_API_DIR&#125;)target_include_directories($&#123;PROJECT_NAME&#125; PRIVATE $&#123;NODE_ADDON_API_DIR&#125;)# define NAPI_VERSION, nodejs 18.17.0 -&gt; 9add_definitions(-DNAPI_VERSION=9)# define _TOOLKIT_IN_DLL_ for ODAtarget_compile_definitions($&#123;PROJECT_NAME&#125;        PRIVATE        _TOOLKIT_IN_DLL_)target_link_libraries($&#123;PROJECT_NAME&#125;        kernel32        user32        gdi32        winspool        comdlg32        advapi32        shell32        ole32        oleaut32        uuid        odbc32        DelayImp        TD_Alloc        TD_Db        TD_DbCore        TD_DbEntities        TD_DbIO        TD_DbRoot        TD_Ge        TD_Gi        TD_Gs        TD_Root        TD_ExamplesCommon        TD_DrawingsExamplesCommon        TD_Key        SCENEOE        ACCAMERA        WipeOut        AcMPolygonObj15        ATEXT        RText        TD_SpatialIndex        UTF        ISM        TD_DynBlocks        spdlog)include_directories(        $&#123;CMAKE_SOURCE_DIR&#125;/src        $&#123;CMAKE_SOURCE_DIR&#125;/external/ODA/Include/Kernel/Include        $&#123;CMAKE_SOURCE_DIR&#125;/external/ODA/Include/Kernel/Extensions/ExServices        $&#123;CMAKE_SOURCE_DIR&#125;/external/ODA/Include/KernelBase/Include        $&#123;CMAKE_SOURCE_DIR&#125;/external/ODA/Include/Drawing/Include        $&#123;CMAKE_SOURCE_DIR&#125;/external/ODA/Include/Drawing/Extensions/ExServices        $&#123;CMAKE_SOURCE_DIR&#125;/external/spdlog/include)add_custom_command(TARGET $&#123;PROJECT_NAME&#125; POST_BUILD        COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_directory        &quot;$&#123;CMAKE_SOURCE_DIR&#125;/external/ODA/dll&quot;        &quot;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;CMAKE_BUILD_TYPE&#125;&quot;)\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","CMake","NodeJS"]},{"title":"Visual Studio 美化设置","url":"/2023/06/09/note/Programming/evn/vs-beautify/","content":"干净整洁的工作环境是必要的，而Visual Studio给人的感觉总是笨重繁杂又混乱的（如果你足够熟悉它，可能并不会这么觉得），于是把它变得尽量和 VS Code 一样整洁是一件令人舒适的事情。\n隐藏状态栏设置中取消勾选“显示状态栏”即可：\n\n文本编辑器相关如此设置：\n\n字体和颜色设置自己想要的：\n\n换上自己喜欢的主题，就可以得到一个清爽的文本编辑器界面：\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["Windows","Visual Studio"]},{"title":"VS code 安装插件 lldb 调试 CPP 程序","url":"/2023/06/13/note/Programming/evn/vscode-lldb-extension/","content":"VS code 安装插件 CodeLLDB 时，需要下载一个包，vadimcn&#x2F;codelldb，即使有代理，也难以自动完成。\n\n\n可以手动下载Release下的对应架构的vsix包，然后命令行安装：\ncode --install-extension codelldb-x86_64-linux.vsix\n\n然后编辑一个launch.json：\n&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;type&quot;: &quot;lldb&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Debug&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/path/to/your-debug-program&quot;, // 要制定需要debug的程序            &quot;args&quot;: [],            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;        &#125;    ]&#125;\n\n加上断点即可调试。\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","VScode","LLDB"]},{"title":"Windows命令行使用CMake","url":"/2023/06/20/note/Programming/tools/cmake-win/","content":"使用CMake命令行构建一个小工程编辑main.cpp：\n#include &lt;iostream&gt;int main() &#123;\tstd::cout &lt;&lt; &quot;Hello, Windows!\\n&quot;;\treturn 0;&#125;\n\n编辑CMakeLists.txt：\ncmake_minimum_required(VERSION 3.5.1)project(win32 VERSION 0.1.0)set(CMAKE_CXX_STANDARD 20)include(CTest)enable_testing()set(CMAKE_EXPORT_COMPILE_COMMANDS ON)set(CMAKE_BUILD_TYPE Debug)include_directories(includes)add_executable(win32 main.cpp)set(CPACK_PROJECT_NAME $&#123;PROJECT_NAME&#125;)set(CPACK_PROJECT_VERSION $&#123;PROJECT_VERSION&#125;)include(CPack)\n\n\n\n当前目录为：\n    目录: D:\\projMode                 LastWriteTime         Length Name----                 -------------         ------ ----d-----         2023/6/20      9:47                build-a----         2023/6/20      9:51            372 CMakeLists.txt-a----         2023/6/20      9:37             97 main.cpp\n\n进入build文件夹：\nPS D:\\proj&gt; cd .\\build\\\n\n输入命令cmake ..以创建CMakeCache：\nPS D:\\proj\\build&gt; cmake ..-- Building for: Visual Studio 17 2022-- Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.19045.-- The C compiler identification is MSVC 19.36.32534.0-- The CXX compiler identification is MSVC 19.36.32534.0-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: E:/VS2022/VC/Tools/MSVC/14.36.32532/bin/Hostx64/x64/cl.exe - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: E:/VS2022/VC/Tools/MSVC/14.36.32532/bin/Hostx64/x64/cl.exe - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done (7.5s)-- Generating done (0.1s)-- Build files have been written to: D:/proj/build\n\n输入命令cmake --build .编译：\nPS D:\\proj\\build&gt; cmake --build .MSBuild version 17.6.3+07e294721 for .NET Framework  1&gt;Checking Build System  Building Custom Rule D:/proj/CMakeLists.txt  main.cpp  win32.vcxproj -&gt; D:\\proj\\build\\Debug\\win32.exe  Building Custom Rule D:/proj/CMakeLists.txt\n\n此时可以看到build文件夹下多出了许多文件和一些文件夹：\n    目录: D:\\proj\\buildMode                 LastWriteTime         Length Name----                 -------------         ------ ----d-----         2023/6/20      9:57                CMakeFilesd-----         2023/6/20      9:57                Debugd-----         2023/6/20      9:56                Testingd-----         2023/6/20      9:57                win32.dird-----         2023/6/20      9:57                x64-a----         2023/6/20      9:56          45092 ALL_BUILD.vcxproj……\n\n其中Debug文件夹中就有生成的可执行文件：\nPS D:\\proj\\build&gt; cd .\\Debug\\PS D:\\proj\\build\\Debug&gt; ls    目录: D:\\proj\\build\\DebugMode                 LastWriteTime         Length Name----                 -------------         ------ -----a----         2023/6/20      9:57          58368 win32.exe-a----         2023/6/20      9:57        1265664 win32.pdb\n\n运行：\nPS D:\\proj\\build&gt; .\\Debug\\win32.exeHello, Windows!\n\nCMake使用glut库点此下载glut的bin文件，其中包含头文件、.dll和.lib文件，将其放到需要引用的工程中。\nstdlib.h(56,48): error C2381: “exit”: 重定义；”noreturn” 不同 [D:\\proj\\build\\win32.vcxproj]解决办法： 调换一下头文件的包含次序：\n#include &lt;windows.h&gt;#include &quot;./lib/glut.h&quot;\n\n 改成：\n#include &quot;./lib/glut.h&quot;#include &lt;windows.h&gt;\n\nLINK : fatal error LNK1104: 无法打开文件“glut32.lib” [D:\\proj\\build\\win32.vcxproj]……\n错误太多，配置太困难，还是使用VS吧。\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","Linux","Clangd","Vim"]},{"title":"使用xmake构建msdf-atlas-gen库","url":"/2024/05/23/note/Programming/tools/msdf-atlas-gen/","content":"直接集成此库作者使用cmake构建，因此可以直接集成到xmake项目中：\npackage(&quot;msdf-atlas-gen&quot;)    add_deps(&quot;cmake&quot;)    set_sourcedir(path.join(os.scriptdir(), &quot;Dionysen/vendor/msdf-atlas-gen&quot;))    on_install(function (package)        local configs = &#123;&#125;        table.insert(configs, &quot;-DCMAKE_BUILD_TYPE=&quot; .. (package:debug() and &quot;Debug&quot; or &quot;Release&quot;))        table.insert(configs, &quot;-DBUILD_SHARED_LIBS=&quot; .. (package:config(&quot;shared&quot;) and &quot;ON&quot; or &quot;OFF&quot;))        import(&quot;package.tools.cmake&quot;).install(package, configs)    end)package_end()add_requires(&quot;msdf-atlas-gen&quot;)\n\n\n❗️但此方法在macOS上链接时找不到符号。\n\n\n\n使用xmake重新构建在msdf-atlas-gen源码目录中新建make.lua，内容为：\nadd_requires(&quot;freetype&quot;, &quot;tinyxml2&quot;)target(&quot;msdf-atlas-gen&quot;)    set_kind(&quot;static&quot;)    add_packages(&quot;freetype&quot;, &quot;tinyxml2&quot;)    add_includedirs(        &quot;.&quot;,        &quot;msdfgen&quot;,        &quot;msdf-atlas-gen&quot;,        &quot;msdfgen/core&quot;,        &quot;msdfgen/ext&quot;,        &quot;artery-font-format&quot;, &#123;public = true&#125;    )    add_files(        &quot;msdfgen/*.cpp&quot;,        &quot;msdfgen/core/*.cpp&quot;,        &quot;msdfgen/ext/*.cpp&quot;,        &quot;msdf-atlas-gen/*.cpp&quot;    )    set_languages(&quot;cxx20&quot;)\n\n添加的依赖包视情况而定，因为有的包可以系统已经安装，编译时缺什么包添加什么包。\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","xmake"]},{"title":"Archlinux上使用MySQL（MariaDB）","url":"/2023/07/15/note/Programming/tools/mysql_install/","content":"\nMySQL 是 Oracle 开发的，分布广泛的多线程，多用户 SQL 数据库。\n\n\nArch Linux 支持 MariaDB，这是 MySQL 的社区开发分支，旨在实现嵌入式兼容性。Oracle 的 MySQL 降到了 AUR：mysqlAUR。另一个旨在完全兼容的分支是 Percona Server，可从 percona-server包 获得。\n\n\nPercona 也有 Oracle 的 InnoDB 存储引擎的分支，称为 XtraDB。MariaDB 和 Percona Server 都使用此分支。\n\n在Arch Linux上使用MySQL，可以使用官方库中的MariaDB，也可以使用AUR中的MySQL。\n\n\n安装MySQL打开终端，并使用以下命令安装MySQL\nsudo pacman -S mysql# Actually installed mariadb# oryay -S mysql\n\n\n如果安装的是mariadb，那么接下来所有命令中的mysql都用mariadb替换\n\n初始化安装完成后，运行以下命令来初始化MySQL数据库：\nsudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql\n\n启动MySQL服务：\n启动MySQL服务sudo systemctl start mysqld\n\n若要设置开机自启动，运行以下命令：\nsudo systemctl enable mysqld\n\n设置root用户密码运行以下命令来设置root用户的密码：\nsudo mysql_secure_installation\n\n按照提示，设置root密码并进行其他安全设置。\n连接到MySQL服务器运行以下命令以使用root用户连接到MySQL服务器：\nmysql -u root -p\n\n输入先前设置的root密码以进行身份验证。\n创建和管理数据库连接到MySQL服务器后，您可以使用SQL命令创建和管理数据库。以下是一些常用的命令示例：\n创建数据库：\nCREATE DATABASE mydatabase;\n\n使用数据库：\nUSE mydatabase;\n\n创建表：\nCREATE TABLE mytable (    id INT PRIMARY KEY,    name VARCHAR(50));\n\n插入数据：\nINSERT INTO mytable (id, name) VALUES (1, &#x27;John&#x27;);\n\n查询数据：\nSELECT * FROM mytable;\n\n更新数据：\nUPDATE mytable SET name = &#x27;Alice&#x27; WHERE id = 1;\n\n删除数据：\nDELETE FROM mytable WHERE id = 1;\n\n客户端常用命令连接到mysql\nmysql -u root -p\n\n输入\\h查看帮助：\nList of all client commands:Note that all text commands must be first on line and end with &#x27;;&#x27;?         (\\?) Synonym for `help&#x27;.clear     (\\c) Clear the current input statement.connect   (\\r) Reconnect to the server. Optional arguments are db and host.delimiter (\\d) Set statement delimiter.edit      (\\e) Edit command with $EDITOR.ego       (\\G) Send command to MariaDB server, display result vertically.exit      (\\q) Exit mysql. Same as quit.go        (\\g) Send command to MariaDB server.help      (\\h) Display this help.nopager   (\\n) Disable pager, print to stdout.notee     (\\t) Don&#x27;t write into outfile.pager     (\\P) Set PAGER [to_pager]. Print the query results via PAGER.print     (\\p) Print current command.prompt    (\\R) Change your mysql prompt.quit      (\\q) Quit mysql.costs     (\\Q) Toggle showing query costs after each queryrehash    (\\#) Rebuild completion hash.source    (\\.) Execute an SQL script file. Takes a file name as an argument.status    (\\s) Get status information from the server.system    (\\!) Execute a system shell command.tee       (\\T) Set outfile [to_outfile]. Append everything into given outfile.use       (\\u) Use another database. Takes database name as argument.charset   (\\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.warnings  (\\W) Show warnings after every statement.nowarning (\\w) Don&#x27;t show warnings after every statement.For server side help, type &#x27;help contents&#x27;\n\n简单使用连接：\nmysql -u root -p\n\n数据库操作：\nCREATE DATABASE &lt;/database_name&gt;; \t# 创建DROP DATABASE &lt;/database_name&gt;;\t\t# 删除USE &lt;/database_name&gt;;\t\t\t\t# 选择\n\n数据表操作：\nCREATE TABLE &lt;/table_name&gt; (column_name column_type);\t# 创建表CREATE TABLE IF NOT EXISTS &lt;/table_name&gt; (column_name column_type);\t# 不存在则创建表DROP TABLE &lt;/table_name&gt;; # 删除表INSERT INTO &lt;/table_name&gt; ( field1, field2,...fieldN )                       VALUES                       ( value1, value2,...valueN ); # 表中插入数据SELECT * FROM &lt;/table_name&gt;; # 从表中读取数据\n\n使用C++调用linux上下载mysqlcppconnector，将头文件和库文件放到相应位置，xmake.lua中添加add_links(&quot;mysqlcppconn&quot;)\n#include &lt;iostream&gt;#include &lt;jdbc/cppconn/resultset.h&gt;#include &lt;jdbc/cppconn/statement.h&gt;#include &lt;jdbc/mysql_connection.h&gt;#include &lt;jdbc/mysql_driver.h&gt;#include &lt;string&gt;int main(int argc, char **argv) &#123;    sql::mysql::MySQL_Driver *driver;    sql::Connection *con;    driver = sql::mysql::get_mysql_driver_instance();    con = driver-&gt;connect(&quot;tcp://0.0.0.0:3306&quot;, &quot;root&quot;, &quot;140917&quot;);    sql::Statement *stmt;    sql::ResultSet *res;    stmt = con-&gt;createStatement();    stmt-&gt;execute(&quot;USE mydatabase&quot;);    // 创建表    stmt-&gt;execute(        &quot;CREATE TABLE IF NOT EXISTS mytable (id INT, name VARCHAR(100))&quot;);    // 插入数据    stmt-&gt;execute(&quot;INSERT INTO mytable (id, name) VALUES (1, &#x27;John&#x27;)&quot;);    stmt-&gt;execute(&quot;INSERT INTO mytable (id, name) VALUES (2, &#x27;Jane&#x27;)&quot;);    // 查询并打印表内容    res = stmt-&gt;executeQuery(&quot;SELECT * FROM mytable&quot;);    std::cout &lt;&lt; &quot;Table Content:&quot; &lt;&lt; std::endl;    while (res-&gt;next()) &#123;        int id = res-&gt;getInt(&quot;id&quot;);        std::string name = res-&gt;getString(&quot;name&quot;);        std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id &lt;&lt; &quot;, Name: &quot; &lt;&lt; name &lt;&lt; std::endl;    &#125;    delete res;    delete stmt;    con-&gt;close();    delete con;    return 0;&#125;\n\n运行结果为：\nTable Content:ID: 1, Name: JohnID: 2, Name: Jane\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["Linux","MySQL","Database"]},{"title":"使用xmake构建c++项目","url":"/2023/06/23/note/Programming/tools/xmake/","content":"\n接受新的事物是不容易的，这意味要面临诸多陌生和不习惯，但xmake太简单易用了，从此cmake是路人。\n\n\n安装On linux：\ncurl -fsSL https://xmake.io/shget.text | bash# Orwget https://xmake.io/shget.text -O - | bash\n\nOn Windows：\nInvoke-Expression (Invoke-Webrequest &#x27;https://xmake.io/psget.text&#x27; -UseBasicParsing).Content\n\n或者直接使用包管理器安装。\n如archlinux：\nsudo pacman -Sy xmake\n\n使用创建项目cpp xmake create -P ./hello# -------- 以下为输出内容 --------create hello ...  [+]: src/main.cpp  [+]: xmake.lua  [+]: .gitignorecreate ok!\n\n此时目录为\nhello|-- src|   `-- main.cpp`-- xmake.lua\n\nxmake.lua的内容为：\nadd_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)  -- 添加debug和release模式target(&quot;hello&quot;)\t-- 项目名字    set_kind(&quot;binary&quot;) -- 设置生成二进制文件    add_files(&quot;src/*.cpp&quot;) -- 添加源文件\n\n在此基础上可以添加更多如头文件和链接库。\nOpenGL-demo环境为WSL-Archlinux。\n安装glfw：\nsudo pacman -S glfw-x11\n\n下载glad放到项目路径中：\n.|-- glad|   |-- include|   |   |-- KHR|   |   |   `-- khrplatform.h|   |   `-- glad|   |       `-- glad.h|   `-- src|       `-- glad.c|-- src|   `-- main.cpp`-- xmake.lua\n\nmain.cpp代码在这里。\nxmake.lua的内容为：\nadd_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)target(&quot;test-xmake&quot;)    set_kind(&quot;binary&quot;)    add_files(&quot;src/*.cpp&quot;, &quot;glad/src/glad.c&quot;) -- 添加glad的源文件，&quot;glad/src/glad.c&quot;当然也可以写成&quot;glad/src/*.c&quot;    add_includedirs(&quot;glad/include&quot;) -- 添加glad的头文件    add_links(&quot;glfw&quot;) -- 添加glfw库\n\n编译：\nxmake# 或xmake build# -------- 以下为输出内容 --------[ 20%]: cache compiling.release src/main.cpp[ 60%]: linking.release test-xmake[100%]: build ok, spent 1.136s\n\n运行：\n./build/linux/x86_64/release/test-xmake# 或xmake run\n\n\n功能生成compile_commands.jsonxmake project -k compile_commands\n\n如果有多个编译器，最好先设置好语法检查的编译器再生成：\nxmake f --toolchain=clangxmake project -k compile_commands\n\n使用mingw编译器xmake f -p mingw --sdk=/path/to/mingw/\n\n发现mingw编译速度很慢，换成msvc：\nxmake f --toolchain=msvc\n\n切换编译模式到debug&#x2F;releasexmake f -m debug\n\n\nf意为config，m意为mode\n\n添加远程库如glm，先编辑xmake.lua：\nadd_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)add_requires(&quot;glm&quot;) -- 必须添加依赖target(&quot;opengl&quot;)    add_rules(&quot;win.sdk.application&quot;)    set_kind(&quot;binary&quot;)    add_files(&quot;src/*.cpp&quot;,&quot;src/*.c&quot;)    add_includedirs(&quot;/include&quot;,&quot;/Dependencies/include/glad&quot;)    add_links(&quot;opengl32&quot;)    add_packages(&quot;glm&quot;) -- 然后添加包，之后xmake会自动添加include和link及其路径\n\n然后生成compile_commands以让编译器智能补全：\nxmake  #构建时会自动从远程仓库拉取xmake project -k compile_commands\n\n需要注意的是，添加依赖库的方式很多，常用是：\n①使用xmake的包管理器，可以使用vcpkg或conon的包，也可以使用xmake自己的包，添加的方式是：\nadd_requires(&quot;glfw&quot;) // 添加依赖add_packages(&quot;glfw&quot;) // 添加包\n\n②从源码编译成依赖库：\n如源码路径：\n└─spdlog    ├─include    │  └─spdlog    │      ├─cfg    │      ├─details    │      ├─fmt    │      │  └─bundled    │      └─sinks    └─src\n\n在spdlog文件下创建xmake.lua作为项目的子模块：\ntarget(&quot;spdlog&quot;)    set_kind(&quot;static&quot;) -- 设置为静态库类型\t-- 或动态库 set_kind(&quot;shared&quot;)     add_includedirs(&quot;./include&quot;, &#123;public = true&#125;) -- 让依赖此库的项目继承头文件    add_files(&quot;./src/*.cpp&quot;)    add_defines(&quot;SPDLOG_COMPILED_LIB&quot;) -- 编译成lib所需要宏\n\n然后再自己项目中的xmake.lua中包含并添加依赖：\ntarget(&quot;myPrj&quot;)\tsetkind(&quot;binary&quot;)\t\tincludes(&quot;./vendor/spdlog/xmake.lua&quot;) \t-- 包含spdlog项目\tadd_deps(&quot;spdlog&quot;)\t\t\t\t\t\t-- 添加依赖\t-- ...其他配置\n\nQt项目创建：\nxmake create -t qt.console testxmake create -t qt.static testxmake create -t qt.shared testxmake create -t qt.quickapp testxmake create -t qt.widgetapp test\n\n配置qt版本\nxmake f --qt=~/Qt/Qt5.9.1\n\n使用xmake生成Visual Studio项目xmake project -k vsxmake\n\n要注意，add_includedirs中的头文件并不会在VS中显示，需要额外使用add_headerfiles将头文件安装到工程中。\n下载xmake包使用内置镜像加速（github）xmake g --proxy_pac=github_mirror.lua\n\n\n不用自己编写 pac.lua，就可以直接使用它来加速 github 源的下载。\n更多内置镜像可以通过 xmake g --help 查看 --proxy_pac= 下列表。\n\n设置主题xmake的全局配置在家目录下的.xmake文件夹中，打开其中的xmake.conf可以看到：\n&#123;    proxy_pac = &quot;github_mirror.lua&quot;,    theme = &quot;default&quot;,    __version = &quot;2.8.6&quot;,    network = &quot;public&quot;&#125;\n\n其中的proxy_pac即是设置的代理，这里使用的是内置github加速，主题是默认。\n可选的主题有ninja、emoji、dark、light、powershell和plain.\n可以直接修改conf文件或使用全局配置修改主题：\nxmake g --theme=plain\n\nxmake.conf和运行前先构建xmake可以设置策略，使得每次使用xmake r运行前先构建，再运行。\nxmake f --policies=run.autobuild\n\n有时候会出现bug，设置完自动构建，xmake会把构建模式设置成release，可以同时设置：\nxmake f -m debug --policies=run.autobuild\n\n或者打开./xmake/windows/x64/xmake.conf手动修改（不推荐）：\n&#123;    __toolchains_windows_x64 = &#123;        &quot;msvc&quot;,        &quot;yasm&quot;,        &quot;nasm&quot;,        &quot;cuda&quot;,        &quot;rust&quot;,        &quot;swift&quot;,        &quot;go&quot;,        &quot;gfortran&quot;,        &quot;fpc&quot;,        &quot;nim&quot;    &#125;,    arch = &quot;x64&quot;,    buildir = &quot;build&quot;,    ccache = true,    host = &quot;windows&quot;,    kind = &quot;static&quot;,    mode = &quot;debug&quot;,    ndk_stdcxx = true,    network = &quot;public&quot;,    pkg_searchdirs = [[D:\\xmakerepo]],    plat = &quot;windows&quot;,    policies = &quot;run.autobuild&quot;,    proxy = &quot;socks5://127.0.0.1:7890&quot;,    proxy_hosts = &quot;github.com,gitlab.*,*.xmake.io&quot;,    proxy_pac = &quot;github_mirror.lua&quot;,    theme = &quot;default&quot;,    vs = &quot;2022&quot;&#125;\n\n\n\n导入CMake本地包使用msdf-atlas-gen包时，发现xmake官方repo中没有，因此从github上下载并以cmake的构建方式导入xmake中。\ngit clone --recursive https://github.com/Chlumsky/msdf-atlas-gen.git\n\n然后将其放到项目文件夹中，在xmake.lua中添加：\npackage(&quot;msdf-atlas-gen&quot;)    add_deps(&quot;cmake&quot;)    set_sourcedir(path.join(os.scriptdir(), &quot;./vendor/msdf-atlas-gen&quot;))  -- 这里给出包的源代码路径    on_install(function (package)        local configs = &#123;&#125;        table.insert(configs, &quot;-DCMAKE_BUILD_TYPE=&quot; .. (package:debug() and &quot;Debug&quot; or &quot;Release&quot;))        table.insert(configs, &quot;-DBUILD_SHARED_LIBS=&quot; .. (package:config(&quot;shared&quot;) and &quot;ON&quot; or &quot;OFF&quot;))        import(&quot;package.tools.cmake&quot;).install(package, configs)    end)package_end()add_requires(&quot;msdf-atlas-gen&quot;)\n\n然后就可以在项目中添加此包：\nadd_packages(&quot;msdf-atlas-gen&quot;)\n\n运行xmake，会提示安装msdf-atlas-gen，安装即可使用。安装时的依赖会根据包的作者配置的cmake进行查找和安装，此包使用vcpkg安装依赖，在linux或windows环境下要先安装vcpkg。\n但目前发现有一些bug，比如当一个包中依赖多个子项目时，xmake可能会找不到头文件，需要手动将包的头文件添加到xmake.lua中：\nadd_includedirs(&quot;./vendor/msdf-atlas-gen/msdf-atlas-gen&quot;,                &quot;./vendor/msdf-atlas-gen/msdfgen&quot;,                &quot;./vendor/msdf-atlas-gen/artery-font-format&quot;)\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n在window上链接预编译动态库add_linkdirs(&quot;path/to/lib&quot;)\n\n这样即已经设置了寻找库文件的路径，只需添加.lib文件即可：\nadd_links(&quot;your_lib&quot;)\n\n这样运行时会自动搜索将库文件的路径里的dll文件。\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n设置c++标准set_languages(&quot;c99&quot;, &quot;cxx11&quot;)\n\n可同时设置c和c++的标准。\n设置代理xmake g --proxy=&quot;socks5://127.0.0.1:7890&quot;\n\n\n\n","categories":["递归这个世界 · 编程","环境搭建与工具使用"],"tags":["CPP","Linux","xmake"]},{"title":"Games101-01-overview-of-computer-graphics","url":"/2025/02/21/note/Programming/CG/Games101/01-overview-of-computer-graphics/","content":"图形学概述。\n\n\n概述游戏、电影（阿凡达的面部捕捉）\n食物做的不太好。的确如此。\nAnimations，Zootopia（2016）毛发显示效果。毛发与光线作用，多跟毛发相互作用。复杂的几何形体如何渲染？\n图形学各种各样的应用。设计、碰撞模拟、可视化（医疗）、虚拟现实 VR、增强现实 AR、模拟。\n字体拓扑、矢量、点阵。\n字体放大也能很清晰。\nThe Quick Brown Fox Jumps Over The Lazy Dog.\n图形学为什么学习图形学：\n\n创造逼真的虚拟世界并与之交互\n需要了解物理世界的各个方面\n新的计算方法、显示、技术\n投影、曲线、表面的数学\n物理光照和着色\n3D 建模\n动画、模拟\n\n光线追踪比较慢，但效果很好。\n主要学习图形学知识、概念，学会之后图形学 API 与 3D 软件就可以非常快了，因为底层原理是一样的。\n图形学与计算机视觉：\n\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic","Games101"]},{"title":"Games101-01-review-of-linear-algebra","url":"/2025/02/21/note/Programming/CG/Games101/02-review-of-linear-algebra/","content":"线性代数。\n\n\n图形学依赖基础数学：线性代数(Linear algebra)、微积分(calculus)、统计学(statistics)\n基础物理：光学(Optics)、力学（Mechanics）\n杂项（Misc）：信号处理、数值分析\n前沿研究：波动光学、美学\n线性代数基础概念复习\n线性代数的几何意义更利于理解”线性代数到底是什么？”这个问题。\n\n向量(Vector)描述空间中的一个方向，拥有方向和长度两个属性。\n\n两个坐标相减即可得到。开始的位置不重要。\n向量的模是向量的长度。向量除以其模即为此向量的单位向量，单位向量与原向量方向相同，长度为1.\n\n（1）向量可以进行加减。\n\n平行四边形法则\n三角形法则\n代数上直接坐标相加\n\n（2）向量可以进行点乘和叉乘。\n\n**点乘(Dot product)**得到的是一个向量在另一个向量上的投影的长度，结果是数值。代数上直接两个坐标对应相乘后相加。\n\n点乘的结果也是两个向量夹角的余弦。\n因此在图形学中，点乘往往用以判断两个向量方向的关系。\n点乘符合乘法交换律、分配律。\n\n\n**叉乘(Cross product)**的得到的是一个垂直于两个向量所在平面的向量。\n\n右手螺旋定则：对于向量a叉乘b，大拇指与四指垂直，将手掌（四指）从a旋转到b，大拇指的方向即为结果向量的方向。\n结果向量的模等于a的模乘以b的mo再乘以夹角的正弦值。\n向量叉乘自己，结果为长度为0的向量。\n\n向量的叉乘可以写成矩阵形式。\n\n\n图形学中的叉乘作用是判断左或右，内或外。\n\n图形学中向量默认是列向量（习惯），相比是便于与矩阵相乘。\n\n坐标系x叉乘y得到的是z，则为右手坐标系。\n叉乘的应用判断一点是否在三角行内部。无论顺时针还是逆时针绕，都可以用点p是否在三条边的左（或右）来判断是在三角形内。\n矩阵矩阵相乘。不满足交换率，满足结合分配率。\n一个列向量看作一个Mx1的矩阵，可以与M列的矩阵相乘。\n一个坐标可以看作一个列向量，进而可以看做一个M行1列的矩阵，进而可以通过一个矩阵乘以它来完成一些变换。\n概念：对角阵，单位阵，逆矩阵，转置矩阵。逆矩阵与转置矩阵的分配率。\n向量的点乘和叉乘可以写成矩阵形式。\n\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic","Games101"]},{"title":"Games101-03-transformation","url":"/2025/02/21/note/Programming/CG/Games101/03-transformation/","content":"矩阵变换。\n\n\nLast LectureVectors, Dot product, Cross product, Matrix, Corrdiantion.\nTransformationModeling transformation.\n3D世界投影到2D的屏幕上，需要很多的变换。\n变换主要是针对坐标的变换，坐标理解为列向量，使用矩阵乘以此向量，可以将此向量变换为另一个向量，继而转化为坐标。这个矩阵即为变换矩阵。\n图形学中modeling变换矩阵是将物体从局部坐标变换到世界坐标，描述物体的顶点坐标最初都是在[-1,1]区间内的，经过modeling变换，不同的物体经过不同的变换（平移、旋转、缩放）有了不同的位置和大小，即在世界坐标中了。在世界坐标中的意思是其坐标不只在[-1,1]区间内，而是可以在任意地方。\nviewing变换是视角矩阵将世界坐标变换到相机的坐标。\nprojection变换是将三维世界中的坐标通过投影映射到屏幕上。\n剪切变换（Shear）待补充。\n向量与坐标二者不同点在于，向量只表示方向，而点是空间中的点。向量具有平移不变性。\n因此向量增加的一个维度(w)应该是0，这样使用平移矩阵乘以它得到的仍然是他自己。而坐标则不同，平移矩阵乘完得到的是平移后的坐标。\n\nvector + vector &#x3D; vector （向量相加依然是向量）\npoint - point &#x3D; vector （正好对应点减去一个点得到一个向量）\npoint + vector &#x3D; point （对应一个点的平移）\npoint + point &#x3D; ?? （中点）\n\n在齐次坐标中，点加上一个点得到的是这两个点的中点。因为w等于2了， 这样两个坐标相加除以w得到的就是中点。\n平移变换无法直接通过等维矩阵直接乘得来，使用高一维的矩阵来完成。\n引入齐次坐标是为了让所有变换都可以通过矩阵来完成，不需要额外的平移。\n\n逆变换逆矩阵可以完成逆变换。\n注意变换矩阵的顺序会对结果有不同的影响。顺序是从右到左乘。\n矩阵可以组合。按某一个点来旋转，可以分解为先将此点平移到原点，旋转后再平移回去。\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic","Games101"]},{"title":"Games101-04-transformation-cont","url":"/2025/02/21/note/Programming/CG/Games101/04-transformation-cont/","content":"矩阵变换。\n\n\n\n旋转矩阵的逆等于旋转矩阵的逆（正交矩阵）。\n\n任意旋转可以分解为分别绕xyz轴的旋转的组合。\n罗德里格斯旋转公式。\n万向节死锁\n四元数\n视图变换定义相机\n位置\n视角方向\n上向量\n\nvec3 position;vec3 direction;vec3 Up;\n\n约定屏幕垂直向外为z轴正方向，横向向右是x轴正方向，竖向向上是y轴正方向。\n首先，世界坐标是正常的坐标，每个物体有它自己的坐标，大小和方向。然后摄像机要看到这些物体，就得知道这些物体相对于摄像机的位置，也就是相对于以相机的位置为原点，相机面向方向为-z，上方向为y，做出的坐标轴的位置。这个问题本质上就是有两个已知的坐标轴，知道这两个坐标轴的相对位置、方向，同时知道物体相对于其中一个坐标轴（世界坐标）的位置，求此物体相对于另一个坐标轴的位置。\n可以通过两次旋转和一次平移来完成。\nLookAt矩阵上面已经分析了视图从世界坐标如何变换到摄像机坐标了，那么变换矩阵如何推到呢？\n首先要算出从世界坐标到摄像机坐标的变换矩阵，需要一定的参数：\n\n摄像机的位置（在世界坐标中）\n视线的方向\n上方向（WorldUp，即世界坐标中的Y轴方向）\n\n视线的方向是摄像机坐标z轴的负方向，此时我们只确定了一个坐标轴的方向，然后通过与世界坐标的Y轴叉乘，可以得到一个与Z轴垂直的x轴，因为摄像机的上方向虽然不确定，但我们为了保证摄像机看到的物体不会歪，摄像机坐标的上方向会与摄像机z轴与世界坐标Y轴所在的平面共面，故而Y与z叉乘的得到的就是摄像机坐标的x轴。\n然后再用x轴叉乘z轴，得到y轴。所有叉乘的结果都标准化为单位向量，便于计算。\n此时我们得到了在世界坐标中摄像机坐标三个轴的方向向量。同时我们又有摄像机的位置。位置可以通过平移变换，方向可以通过旋转变换。\n由于旋转矩阵都是正交矩阵，其逆矩阵等于其转置矩阵。因此直接将三个轴组成的矩阵转置即可得到变换矩阵的逆矩阵。\nLookAt矩阵的本质LookAt矩阵是一个4x4齐次变换矩阵，作用是将世界坐标系下的顶点坐标转换到以摄像机为原点的坐标系（视图空间）。其核心是：\n\n平移：将摄像机位置移动到世界坐标系原点。\n旋转：将摄像机的局部坐标系（U&#x2F;V&#x2F;W轴）对齐到标准坐标系（X&#x2F;Y&#x2F;Z轴）。\n\n推导步骤(1) 定义摄像机坐标系给定参数：\n\n摄像机位置 eyePos（世界坐标）。\n目标点 targetPos（视线方向）。\n上方向 upDir（通常为世界坐标的Y轴）。\n\n计算摄像机的三个正交基向量：\n\n视线方向（W轴）：$$ W &#x3D; \\text{normalize}(\\text{eyePos} - \\text{targetPos}) $$（指向摄像机后方，因OpenGL视图空间Z轴为负）。\n\n右方向（U轴）：$$ U &#x3D; \\text{normalize}(\\text{upDir} \\times W) $$（叉积保证与W和upDir正交）。\n\n上方向（V轴）：$$ V &#x3D; \\text{normalize}(W \\times U) $$（修正upDir可能不与W垂直的情况）。\n\n\n(2) 构造旋转矩阵将摄像机坐标系（U&#x2F;V&#x2F;W）对齐到世界坐标系（X&#x2F;Y&#x2F;Z）的旋转矩阵 R 是正交矩阵，其逆矩阵等于转置矩阵：$$R &#x3D; \\begin{bmatrix}U_x &amp; U_y &amp; U_z &amp; 0 \\V_x &amp; V_y &amp; V_z &amp; 0 \\-W_x &amp; -W_y &amp; -W_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$\n(3) 构造平移矩阵将摄像机位置平移至原点的平移矩阵 T：$$T &#x3D; \\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; -\\text{eyePos}_x \\0 &amp; 1 &amp; 0 &amp; -\\text{eyePos}_y \\0 &amp; 0 &amp; 1 &amp; -\\text{eyePos}_z \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$\n(4) 合并为LookAt矩阵视图矩阵是旋转和平移的复合变换：$$M_{\\text{View}} &#x3D; R \\cdot T &#x3D; \\begin{bmatrix}U_x &amp; U_y &amp; U_z &amp; -U \\cdot \\text{eyePos} \\V_x &amp; V_y &amp; V_z &amp; -V \\cdot \\text{eyePos} \\-W_x &amp; -W_y &amp; -W_z &amp; W \\cdot \\text{eyePos} \\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$\n\n关键点\n正交矩阵性质：旋转矩阵的逆等于转置，简化计算。\n右手坐标系：OpenGL中摄像机Z轴指向屏幕内（负方向）。\n基变换：LookAt矩阵本质是将世界坐标系的基向量变换为摄像机坐标系的基向量。\n\n投影变换正交投影相等于透视投影的相机无限远。\n透视投影可以理解为将视锥体挤压到NDC范围内，然后再做正交投影。\n","categories":["递归这个世界 · 编程","Game Engine"],"tags":["C++","Compute Graphic","Games101"]}]